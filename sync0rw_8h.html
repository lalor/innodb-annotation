<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/sync0rw.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sync0rw.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0counter_8h_source.html">ut0counter.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync0rw_8ic.html">sync0rw.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sync0rw.h:</div>
<div class="dyncontent">
<div class="center"><img src="sync0rw_8h__incl.png" border="0" usemap="#include_2sync0rw_8h" alt=""/></div>
<map name="include_2sync0rw_8h" id="include_2sync0rw_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sync0rw_8h__dep__incl.png" border="0" usemap="#include_2sync0rw_8hdep" alt=""/></div>
<map name="include_2sync0rw_8hdep" id="include_2sync0rw_8hdep">
</map>
</div>
</div>
<p><a href="sync0rw_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__t.html">rw_lock_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrw__lock__debug__t.html">rw_lock_debug_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a307d47401046e3092b4db2252e2d5e20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307d47401046e3092b4db2252e2d5e20"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_S_LATCH</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:ac4153a08cf54353103c0dd6b969f5a09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4153a08cf54353103c0dd6b969f5a09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_X_LATCH</b>&#160;&#160;&#160;2</td></tr>
<tr class="memitem:a6b729f2ee198ffed52628341cb3a9a0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b729f2ee198ffed52628341cb3a9a0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RW_NO_LATCH</b>&#160;&#160;&#160;3</td></tr>
<tr class="memitem:ac0b2662477d6b776c1e7ace4c29949ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0b2662477d6b776c1e7ace4c29949ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>X_LOCK_DECR</b>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="memitem:aa8c004f4cee18ed2d0f57d12a4395386"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#aa8c004f4cee18ed2d0f57d12a4395386">rw_lock_create</a>(K, L, level)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a9c2f169de074960e3c2619e04974be1a">rw_lock_create_func</a>((L), (level), #L, __FILE__, __LINE__)</td></tr>
<tr class="memitem:a75ab160551c85fc478837cda173ef4d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a75ab160551c85fc478837cda173ef4d0">rw_lock_s_lock</a>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a>((M), 0, __FILE__, __LINE__)</td></tr>
<tr class="memitem:a3c4f7fd32176ef5360016d0352780e47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c4f7fd32176ef5360016d0352780e47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_inline</b>(M, P, F, L)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a>((M), (P), (F), (L))</td></tr>
<tr class="memitem:a315e7c36f136ff80f9d25f7e4487f9b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a315e7c36f136ff80f9d25f7e4487f9b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_gen</b>(M, P)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="memitem:accf37bcc3e9b519fa56b6b6ac57d9114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accf37bcc3e9b519fa56b6b6ac57d9114"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_gen_nowait</b>(M, P)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a359cd00fb32985538e22e25bf623a6d1">rw_lock_s_lock_low</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="memitem:ab7973a87a4b5f0e81c38b4ddc5752078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7973a87a4b5f0e81c38b4ddc5752078"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_lock_nowait</b>(M, F, L)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a359cd00fb32985538e22e25bf623a6d1">rw_lock_s_lock_low</a>((M), 0, (F), (L))</td></tr>
<tr class="memitem:a8b4a82c5c95e70ada76ea54fcd1ec3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b4a82c5c95e70ada76ea54fcd1ec3e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_unlock_gen</b>(L, P)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a841d018693f38edcea0e3316f47761c2">rw_lock_s_unlock_func</a>(P, L)</td></tr>
<tr class="memitem:ad3004dd4636535a3aab2cecfdb7dae54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3004dd4636535a3aab2cecfdb7dae54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func</a>((M), 0, __FILE__, __LINE__)</td></tr>
<tr class="memitem:a3c18777721b02a69abdd8f09f9a878a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c18777721b02a69abdd8f09f9a878a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_inline</b>(M, P, F, L)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func</a>((M), (P), (F), (L))</td></tr>
<tr class="memitem:aa710bf51467ba64046aff9e50fc93453"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa710bf51467ba64046aff9e50fc93453"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_gen</b>(M, P)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func</a>((M), (P), __FILE__, __LINE__)</td></tr>
<tr class="memitem:a1db8af761e911c0508e00fad89cd5798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1db8af761e911c0508e00fad89cd5798"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_nowait</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait</a>((M), __FILE__, __LINE__)</td></tr>
<tr class="memitem:a27f1a39a45b6f1cd4ece8260f43f19a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f1a39a45b6f1cd4ece8260f43f19a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_lock_func_nowait_inline</b>(M, F, L)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait</a>((M), (F), (L))</td></tr>
<tr class="memitem:a017ca55049f283ad3767df5a86d6143a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a017ca55049f283ad3767df5a86d6143a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_unlock_gen</b>(L, P)&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a461109512901bbb42f1317ba16c0dabc">rw_lock_x_unlock_func</a>(P, L)</td></tr>
<tr class="memitem:ad08b06eb9f788c2f45e848d46556e1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad08b06eb9f788c2f45e848d46556e1e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_free</b>(M)&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#af66e0a54048b7143a68813277bc70f5b">rw_lock_free_func</a>(M)</td></tr>
<tr class="memitem:a41172c45229ea4cbe60f4669b3b68994"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41172c45229ea4cbe60f4669b3b68994"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_s_unlock</b>(L)&#160;&#160;&#160;rw_lock_s_unlock_gen(L, 0)</td></tr>
<tr class="memitem:ae10266de83fba11c12e595ca4ab1f17c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae10266de83fba11c12e595ca4ab1f17c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_x_unlock</b>(L)&#160;&#160;&#160;rw_lock_x_unlock_gen(L, 0)</td></tr>
<tr class="memitem:a419a1c99cee9972196262d27296d5cf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a419a1c99cee9972196262d27296d5cf1">RW_LOCK_MAGIC_N</a>&#160;&#160;&#160;22643</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9d11ee37edcb52389b8ec317a3318eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d11ee37edcb52389b8ec317a3318eac"></a>
typedef <a class="el" href="structut__list__base.html">ut_list_base</a>&lt; <a class="el" href="structrw__lock__t.html">rw_lock_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_list_t</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9c2f169de074960e3c2619e04974be1a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a9c2f169de074960e3c2619e04974be1a">rw_lock_create_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint level, const char *cmutex_name, const char *cfile_name, ulint cline)</td></tr>
<tr class="memitem:af66e0a54048b7143a68813277bc70f5b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af66e0a54048b7143a68813277bc70f5b">rw_lock_free_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a6f4bf13cf7ae35c44129a8c4eeb47e0d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a6f4bf13cf7ae35c44129a8c4eeb47e0d">rw_lock_validate</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a359cd00fb32985538e22e25bf623a6d1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a359cd00fb32985538e22e25bf623a6d1">rw_lock_s_lock_low</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass)</td></tr>
<tr class="memitem:a1dfb8bac26c0ede1f1cbb1c94d415370"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a9ec3c37952ede1fb7178c8ee66c35b14"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a841d018693f38edcea0e3316f47761c2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a841d018693f38edcea0e3316f47761c2">rw_lock_s_unlock_func</a> (ulint pass, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:af847cc23edeba216e1d5381f1facdf3f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af847cc23edeba216e1d5381f1facdf3f">rw_lock_x_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a461109512901bbb42f1317ba16c0dabc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a461109512901bbb42f1317ba16c0dabc">rw_lock_x_unlock_func</a> (ulint pass, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:ad4ab05eba9ad152bc256180ef5430465"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ad4ab05eba9ad152bc256180ef5430465">rw_lock_x_lock_move_ownership</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:add5b9c0969702ede99cdabbbc40fce33"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#add5b9c0969702ede99cdabbbc40fce33">rw_lock_get_x_lock_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:accc192baf074e7cba3590651df4b4194"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#accc192baf074e7cba3590651df4b4194">rw_lock_get_waiters</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:acd5acf23523e06ae0ce287173349c2ff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#acd5acf23523e06ae0ce287173349c2ff">rw_lock_get_writer</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:ae24ac5c3f41388704830966b07d50936"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ae24ac5c3f41388704830966b07d50936">rw_lock_get_reader_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a7cbd8f9cce63535b6d1196e067deecff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a7cbd8f9cce63535b6d1196e067deecff">rw_lock_lock_word_decr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="memitem:ae2190009fb2d146f6b082fda6a339452"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ae2190009fb2d146f6b082fda6a339452">rw_lock_lock_word_incr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="memitem:a1d25e4a616558afa15d4c302d42c1f3c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a1d25e4a616558afa15d4c302d42c1f3c">rw_lock_set_writer_id_and_recursion_flag</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> recursive)</td></tr>
<tr class="memitem:aee0428509dd1bcc1d9120bda297806ec"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#aee0428509dd1bcc1d9120bda297806ec">rw_lock_own</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint lock_type))</td></tr>
<tr class="memitem:af10a4e60b4bb7754862abd9e5c2aed0c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#af10a4e60b4bb7754862abd9e5c2aed0c">rw_lock_is_locked</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint lock_type)</td></tr>
<tr class="memitem:a0a489ad4f35fdf9b9c91bdc71208f2f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a0a489ad4f35fdf9b9c91bdc71208f2f1">rw_lock_print</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a00a86b2fa566d2b8fd82f767b664986d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a00a86b2fa566d2b8fd82f767b664986d">rw_lock_list_print_info</a> (FILE *file)</td></tr>
<tr class="memitem:a4ea0e2017b0cb325d2cae068c1a3035a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a4ea0e2017b0cb325d2cae068c1a3035a">rw_lock_n_locked</a> (void)</td></tr>
<tr class="memitem:afa1c2c66eebf2bb0dcbecaf6c91b4da3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#afa1c2c66eebf2bb0dcbecaf6c91b4da3">rw_lock_debug_mutex_enter</a> (void)</td></tr>
<tr class="memitem:ad0644b72065c203cdb3321db2ddeefcd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ad0644b72065c203cdb3321db2ddeefcd">rw_lock_debug_mutex_exit</a> (void)</td></tr>
<tr class="memitem:a5a5d429d093f631ab28f929d1d9ab62d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a5a5d429d093f631ab28f929d1d9ab62d">rw_lock_debug_print</a> (FILE *f, <a class="el" href="structrw__lock__debug__t.html">rw_lock_debug_t</a> *info)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a865b35e6bcb6041e1d21fe594be4b51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a865b35e6bcb6041e1d21fe594be4b51a"></a>
<a class="el" href="structut__list__base.html">rw_lock_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_list</b></td></tr>
<tr class="memitem:ab2f2c7ca7d81c3ccd69421a9ce8a5a65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2f2c7ca7d81c3ccd69421a9ce8a5a65"></a>
<a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_list_mutex</b></td></tr>
<tr class="memitem:ab82767d074186bbf7a2c98c848d84c4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab82767d074186bbf7a2c98c848d84c4a"></a>
<a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_debug_mutex</b></td></tr>
<tr class="memitem:ae91ad2539c61a359acbef92e37dd0f4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ae91ad2539c61a359acbef92e37dd0f4b">rw_lock_debug_event</a></td></tr>
<tr class="memitem:ac4f9adbfc68e36f01e8eea75690b574e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#ac4f9adbfc68e36f01e8eea75690b574e">rw_lock_debug_waiters</a></td></tr>
<tr class="memitem:a170e3023b96429fc1d32d3f18e616128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a170e3023b96429fc1d32d3f18e616128">rw_lock_stats</a></td></tr>
<tr class="memitem:a536d52293912f9ecfa49addcaa4877c3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a></td></tr>
<tr class="memitem:a9c7f0c6f9625ecd575d0dc773df2ee08"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The read-write lock (for threads, not for database transactions)</p>
<p>Created 9/11/1995 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="aa8c004f4cee18ed2d0f57d12a4395386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rw_lock_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">K, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">L, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="sync0rw_8h.html#a9c2f169de074960e3c2619e04974be1a">rw_lock_create_func</a>((L), (level), #L, __FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates, or rather, initializes an rw-lock object in a specified memory location (which must be appropriately aligned). The rw-lock is initialized to the non-locked state. Explicit freeing of the rw-lock with rw_lock_free is necessary only if the memory block containing it is freed. if MySQL performance schema is enabled and "UNIV_PFS_RWLOCK" is defined, the rwlock are instrumented with performance schema probes. </p>

</div>
</div>
<a class="anchor" id="a419a1c99cee9972196262d27296d5cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RW_LOCK_MAGIC_N&#160;&#160;&#160;22643</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of <a class="el" href="structrw__lock__t.html#a869c22d3e4661ba8f28e46ec3774f45c">rw_lock_t::magic_n</a> </p>

</div>
</div>
<a class="anchor" id="a75ab160551c85fc478837cda173ef4d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rw_lock_s_lock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0rw_8ic.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a>((M), 0, __FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! The following macros should be used in rw locking and unlocking, not the corresponding function. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a9c2f169de074960e3c2619e04974be1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_create_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmutex_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cfile_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates, or rather, initializes an rw-lock object in a specified memory location (which must be appropriately aligned). The rw-lock is initialized to the non-locked state. Explicit freeing of the rw-lock with rw_lock_free is necessary only if the memory block containing it is freed. in: file line where created </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to memory </td></tr>
    <tr><td class="paramname">level</td><td>in: level </td></tr>
    <tr><td class="paramname">cmutex_name</td><td>in: mutex name </td></tr>
    <tr><td class="paramname">cfile_name</td><td>in: file name where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa1c2c66eebf2bb0dcbecaf6c91b4da3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_debug_mutex_enter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the debug mutex. We cannot use the mutex defined in sync0sync, because the debug mutex is also acquired in sync0arr while holding the OS mutex protecting the sync array, and the ordinary mutex_enter might recursively call routines in sync0arr, leading to a deadlock on the OS mutex. </p>

</div>
</div>
<a class="anchor" id="ad0644b72065c203cdb3321db2ddeefcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_debug_mutex_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the debug mutex. </p>

</div>
</div>
<a class="anchor" id="a5a5d429d093f631ab28f929d1d9ab62d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_debug_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__debug__t.html">rw_lock_debug_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a debug struct. in: debug struct </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>in: output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af66e0a54048b7143a68813277bc70f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_free_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this function is obligatory only if the memory buffer containing the rw-lock is freed. Removes an rw-lock object from the global list. The rw-lock is checked to be in the non-locked state. in: rw-lock </p>

</div>
</div>
<a class="anchor" id="ae24ac5c3f41388704830966b07d50936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_reader_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of readers. </p>
<dl class="section return"><dt>Returns</dt><dd>number of readers in: rw-lock</dd></dl>
<p>Returns the number of readers. </p>
<dl class="section return"><dt>Returns</dt><dd>number of readers </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accc192baf074e7cba3590651df4b4194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_waiters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are threads waiting for the rw-lock. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if waiters, 0 otherwise in: rw-lock</dd></dl>
<p>Check if there are threads waiting for the rw-lock. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if waiters, 0 otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd5acf23523e06ae0ce287173349c2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_writer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the write-status of the lock - this function made more sense with the old rw_lock implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>RW_LOCK_NOT_LOCKED, RW_LOCK_EX, RW_LOCK_WAIT_EX in: rw-lock</dd></dl>
<p>Returns the write-status of the lock - this function made more sense with the old rw_lock implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>RW_LOCK_NOT_LOCKED, RW_LOCK_EX, RW_LOCK_WAIT_EX </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add5b9c0969702ede99cdabbbc40fce33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_x_lock_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of writer_count for the lock. Does not reserve the lock mutex, so the caller must be sure it is not changed during the call. </p>
<dl class="section return"><dt>Returns</dt><dd>value of writer_count in: rw-lock</dd></dl>
<p>Returns the value of writer_count for the lock. Does not reserve the lock mutex, so the caller must be sure it is not changed during the call. </p>
<dl class="section return"><dt>Returns</dt><dd>value of writer_count </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af10a4e60b4bb7754862abd9e5c2aed0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_is_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if somebody has locked the rw-lock in the specified mode. in: lock type: RW_LOCK_SHARED, RW_LOCK_EX </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00a86b2fa566d2b8fd82f767b664986d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_list_print_info </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints debug info of currently locked rw-locks. in: file where to print </p>

</div>
</div>
<a class="anchor" id="a7cbd8f9cce63535b6d1196e067deecff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_lock_word_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements lock_word the specified amount if it is greater than 0. This is used by both s_lock and x_lock operations. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if decr occurs in: amount to decrement</dd></dl>
<p>Two different implementations for decrementing the lock_word of a rw_lock: one for systems supporting atomic operations, one for others. This does does not support recusive x-locks: they should be handled by the caller and need not be atomic since they are performed by the current lock holder. Returns true if the decrement was made, false if not. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if decr occurs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
    <tr><td class="paramname">amount</td><td>in: amount to decrement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2190009fb2d146f6b082fda6a339452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lint rw_lock_lock_word_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments lock_word the specified amount and returns new value. </p>
<dl class="section return"><dt>Returns</dt><dd>lock-&gt;lock_word after increment in: amount to increment</dd></dl>
<p>Increments lock_word the specified amount and returns new value. </p>
<dl class="section return"><dt>Returns</dt><dd>lock-&gt;lock_word after increment </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
    <tr><td class="paramname">amount</td><td>in: amount of increment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ea0e2017b0cb325d2cae068c1a3035a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint rw_lock_n_locked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of currently locked rw-locks. Works only in the debug version. </p>
<dl class="section return"><dt>Returns</dt><dd>number of locked rw-locks </dd></dl>

</div>
</div>
<a class="anchor" id="aee0428509dd1bcc1d9120bda297806ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_own </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the thread has locked the rw-lock in the specified mode, with the pass value == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type: RW_LOCK_SHARED, RW_LOCK_EX </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a489ad4f35fdf9b9c91bdc71208f2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints debug info of an rw-lock. in: rw-lock </p>

</div>
</div>
<a class="anchor" id="a1dfb8bac26c0ede1f1cbb1c94d415370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function, except if you supply the file name and line number. Lock an rw-lock in shared mode for the current thread. If the rw-lock is locked in exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. in: line where requested</p>
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in shared mode for the current thread. If the rw-lock is locked in exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a359cd00fb32985538e22e25bf623a6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_s_lock_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low-level function which tries to lock an rw-lock in s-mode. Performs no spinning. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a841d018693f38edcea0e3316f47761c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_unlock_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a shared mode lock. in/out: rw-lock</p>
<p>Releases a shared mode lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock may have been passed to another thread to unlock </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d25e4a616558afa15d4c302d42c1f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_set_writer_id_and_recursion_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the lock-&gt;writer_thread and lock-&gt;recursive fields. For platforms where we are using atomic builtins instead of lock-&gt;mutex it sets the lock-&gt;writer_thread field using atomics to ensure memory ordering. Note that it is assumed that the caller of this function effectively owns the lock i.e.: nobody else is allowed to modify lock-&gt;writer_thread at this point in time. The protocol is that lock-&gt;writer_thread MUST be updated BEFORE the lock-&gt;recursive flag is set. in: TRUE if recursion allowed</p>
<p>This function sets the lock-&gt;writer_thread and lock-&gt;recursive fields. For platforms where we are using atomic builtins instead of lock-&gt;mutex it sets the lock-&gt;writer_thread field using atomics to ensure memory ordering. Note that it is assumed that the caller of this function effectively owns the lock i.e.: nobody else is allowed to modify lock-&gt;writer_thread at this point in time. The protocol is that lock-&gt;writer_thread MUST be updated BEFORE the lock-&gt;recursive flag is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: lock to work on </td></tr>
    <tr><td class="paramname">recursive</td><td>in: TRUE if recursion allowed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4bf13cf7ae35c44129a8c4eeb47e0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the rw-lock has been initialized and that there are no simultaneous shared and exclusive locks. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE in: rw-lock </dd></dl>

</div>
</div>
<a class="anchor" id="af847cc23edeba216e1d5381f1facdf3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_x_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread. If the rw-lock is locked in shared or exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. If the same thread has an x-lock on the rw-lock, locking succeed, with the following exception: if pass != 0, only a single x-lock may be taken on the lock. NOTE: If the same thread has an s-lock, locking does not succeed! in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec3c37952ede1fb7178c8ee66c35b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_x_lock_func_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread if the lock can be obtained immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success in: line where requested</dd></dl>
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread if the lock can be obtained immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4ab05eba9ad152bc256180ef5430465"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_x_lock_move_ownership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used in the insert buffer to move the ownership of an x-latch on a buffer frame to the current thread. The x-latch was set by the buffer read operation and it protected the buffer frame while the read was done. The ownership is moved because we want that the current thread is able to acquire a second x-latch which is stored in an mtr. This, in turn, is needed to pass the debug checks of index page operations. in: lock which was x-locked in the buffer read </p>

</div>
</div>
<a class="anchor" id="a461109512901bbb42f1317ba16c0dabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_x_unlock_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases an exclusive mode lock. in/out: rw-lock</p>
<p>Releases an exclusive mode lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock may have been passed to another thread to unlock </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="a536d52293912f9ecfa49addcaa4877c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char* file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: pass value; != 0, if the lock will be passed to another thread to unlock in: file name where lock requested </p>

</div>
</div>
<a class="anchor" id="a9c7f0c6f9625ecd575d0dc773df2ee08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char ulint line</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: line where requested </p>

</div>
</div>
<a class="anchor" id="ae91ad2539c61a359acbef92e37dd0f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> rw_lock_debug_event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If deadlock detection does not get immediately the mutex it may wait for this event </p>

</div>
</div>
<a class="anchor" id="ac4f9adbfc68e36f01e8eea75690b574e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_debug_waiters</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is set to TRUE, if there may be waiters for the event </p>

</div>
</div>
<a class="anchor" id="a170e3023b96429fc1d32d3f18e616128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__stats__t.html">rw_lock_stats_t</a> rw_lock_stats</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counters for RW locks. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:21 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
