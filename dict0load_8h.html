<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/dict0load.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dict0load.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem0mem_8h_source.html">mem0mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0load_8ic.html">dict0load.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for dict0load.h:</div>
<div class="dyncontent">
<div class="center"><img src="dict0load_8h__incl.png" border="0" usemap="#include_2dict0load_8h" alt=""/></div>
<map name="include_2dict0load_8h" id="include_2dict0load_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="dict0load_8h__dep__incl.png" border="0" usemap="#include_2dict0load_8hdep" alt=""/></div>
<map name="include_2dict0load_8hdep" id="include_2dict0load_8hdep">
</map>
</div>
</div>
<p><a href="dict0load_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7eec73bf89d9692ec12708a88ad862aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a7eec73bf89d9692ec12708a88ad862aa">dict_system_id_t</a> { <br/>
&#160;&#160;<b>SYS_TABLES</b> =  0, 
<b>SYS_INDEXES</b>, 
<b>SYS_COLUMNS</b>, 
<b>SYS_FIELDS</b>, 
<br/>
&#160;&#160;<b>SYS_FOREIGN</b>, 
<b>SYS_FOREIGN_COLS</b>, 
<b>SYS_TABLESPACES</b>, 
<b>SYS_DATAFILES</b>, 
<br/>
&#160;&#160;<b>SYS_NUM_SYSTEM_TABLES</b>
<br/>
 }</td></tr>
<tr class="memitem:a3f9fec93ae4fed092920b2813abf7286"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286">dict_table_info_t</a> { <a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286a274880f997de17830b8db34b0f780f01">DICT_TABLE_LOAD_FROM_RECORD</a> =  0, 
<a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286ad784ff2e87a930163c9594c72fa805c0">DICT_TABLE_LOAD_FROM_CACHE</a> =  1
 }</td></tr>
<tr class="memitem:af61a50a2413f51c1d1818911ec5dac53"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53">dict_check_t</a> { <a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53adaf4b1c04d87ddfee136752660449655">DICT_CHECK_NONE_LOADED</a> =  0, 
<a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53a7b613eeb43818835c41f33b87a2d9fc4">DICT_CHECK_SOME_LOADED</a>, 
<a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53a41936340d61898fa0def59dcf9a82f61">DICT_CHECK_ALL_LOADED</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac0e77ed1341eb5a220c7ce9d1e0d149c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#ac0e77ed1341eb5a220c7ce9d1e0d149c">dict_check_tablespaces_and_store_max_id</a> (<a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53">dict_check_t</a> dict_check)</td></tr>
<tr class="memitem:a0d7e532a8e51c0b3479eea8a1e416434"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a0d7e532a8e51c0b3479eea8a1e416434">dict_get_first_table_name_in_db</a> (const char *name)</td></tr>
<tr class="memitem:a2a4a8cce4027746548d848bf9e895e79"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a2a4a8cce4027746548d848bf9e895e79">dict_load_table_low</a> (const char *name, const rec_t *rec, <a class="el" href="structdict__table__t.html">dict_table_t</a> **table)</td></tr>
<tr class="memitem:a5561881e7092c1675f5010b053656275"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a5561881e7092c1675f5010b053656275">dict_load_column_low</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, <a class="el" href="structdict__col__t.html">dict_col_t</a> *column, table_id_t *table_id, const char **col_name, const rec_t *rec)</td></tr>
<tr class="memitem:a9dcc2299781ed75a86fc87ea9ca0fdbe"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a9dcc2299781ed75a86fc87ea9ca0fdbe">dict_load_index_low</a> (byte *table_id, const char *table_name, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> allocate, <a class="el" href="structdict__index__t.html">dict_index_t</a> **index)</td></tr>
<tr class="memitem:a96d3aa2b127614ea3cc954c6dcb2af4c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a96d3aa2b127614ea3cc954c6dcb2af4c">dict_load_field_low</a> (byte *index_id, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structdict__field__t.html">dict_field_t</a> *sys_field, ulint *pos, byte *last_index_id, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec)</td></tr>
<tr class="memitem:ad42d27d10e2963510a8df47a4f8a3ce5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#ad42d27d10e2963510a8df47a4f8a3ce5">dict_save_data_dir_path</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, char *filepath)</td></tr>
<tr class="memitem:aeda355029d59beea6b88e6aa4f4a8582"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#aeda355029d59beea6b88e6aa4f4a8582">dict_get_and_save_data_dir_path</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, bool dict_mutex_own)</td></tr>
<tr class="memitem:a0f8e9fc25745735bc436a0df203e7c9a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a0f8e9fc25745735bc436a0df203e7c9a">dict_load_table</a> (const char *name, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> cached, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> ignore_err)</td></tr>
<tr class="memitem:a06b1dea1206d8e687f2ac45a0de66524"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a06b1dea1206d8e687f2ac45a0de66524">dict_load_table_on_id</a> (table_id_t table_id, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> ignore_err)</td></tr>
<tr class="memitem:a2a6f31780fba5af49be6276fe546a762"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a2a6f31780fba5af49be6276fe546a762">dict_load_sys_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memitem:ade9e80e8a6180896010eab6b33449dd1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#ade9e80e8a6180896010eab6b33449dd1">dict_load_foreigns</a> (const char *table_name, const char **col_names, bool check_recursive, bool check_charsets, <a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a> ignore_err)</td></tr>
<tr class="memitem:a9694b487a97ec3a971cf9939018e3b9b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a9694b487a97ec3a971cf9939018e3b9b">dict_print</a> (void)</td></tr>
<tr class="memitem:a18916653b9876a066bb8d232cff56650"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a18916653b9876a066bb8d232cff56650">dict_startscan_system</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="dict0load_8h.html#a7eec73bf89d9692ec12708a88ad862aa">dict_system_id_t</a> system_id)</td></tr>
<tr class="memitem:a5c19a5cf96b7585bbab387e6a1a2c557"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a5c19a5cf96b7585bbab387e6a1a2c557">dict_getnext_system</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:ae4d51fddd3a5dd4fb2ca7d06c6e38f41"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#ae4d51fddd3a5dd4fb2ca7d06c6e38f41">dict_process_sys_tables_rec_and_mtr_commit</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="structdict__table__t.html">dict_table_t</a> **table, <a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286">dict_table_info_t</a> status, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a127597a2e4047bd8eaadb93a2a428c55"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a127597a2e4047bd8eaadb93a2a428c55">dict_process_sys_indexes_rec</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, table_id_t *table_id)</td></tr>
<tr class="memitem:aec5de2844a181f3b334d155193b47609"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#aec5de2844a181f3b334d155193b47609">dict_process_sys_columns_rec</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="structdict__col__t.html">dict_col_t</a> *column, table_id_t *table_id, const char **col_name)</td></tr>
<tr class="memitem:a71861a1a6d6fddfcdcaab0ed1ec87a3f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a71861a1a6d6fddfcdcaab0ed1ec87a3f">dict_process_sys_fields_rec</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="structdict__field__t.html">dict_field_t</a> *sys_field, ulint *pos, index_id_t *index_id, index_id_t last_id)</td></tr>
<tr class="memitem:a698eef4e4849922e231c8f786054c4a1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a698eef4e4849922e231c8f786054c4a1">dict_process_sys_foreign_rec</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *foreign)</td></tr>
<tr class="memitem:a247677cfee13f36c4f854390a3e066c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a247677cfee13f36c4f854390a3e066c0">dict_process_sys_foreign_col_rec</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, const char **name, const char **for_col_name, const char **ref_col_name, ulint *pos)</td></tr>
<tr class="memitem:abc2dcecb4fcb42a8009614fcef379b7f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#abc2dcecb4fcb42a8009614fcef379b7f">dict_process_sys_tablespaces</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, ulint *space, const char **name, ulint *flags)</td></tr>
<tr class="memitem:a7a6cde22af7ed6f9f9000467337d6700"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a7a6cde22af7ed6f9f9000467337d6700">dict_process_sys_datafiles</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const rec_t *rec, ulint *space, const char **path)</td></tr>
<tr class="memitem:a99b5a060c595e8f38cd6f084abc7ccd5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a99b5a060c595e8f38cd6f084abc7ccd5">dict_get_first_path</a> (ulint space, const char *name)</td></tr>
<tr class="memitem:ac3d0cdca3d4769e23f6cf028b6e4cf88"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#ac3d0cdca3d4769e23f6cf028b6e4cf88">dict_update_filepath</a> (ulint space_id, const char *filepath)</td></tr>
<tr class="memitem:a2dc8f060723ed80ae2c5e4b8144b2635"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dict0load_8h.html#a2dc8f060723ed80ae2c5e4b8144b2635">dict_insert_tablespace_and_filepath</a> (ulint space, const char *name, const char *filepath, ulint fsp_flags)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9de1fa5a5c99bbc84b5678762a623cf3"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Loads to the memory cache database object definitions from dictionary tables</p>
<p>Created 4/24/1996 Heikki Tuuri </p>
</div><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="af61a50a2413f51c1d1818911ec5dac53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53">dict_check_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check type for <a class="el" href="dict0load_8h.html#ac0e77ed1341eb5a220c7ce9d1e0d149c">dict_check_tablespaces_and_store_max_id()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af61a50a2413f51c1d1818911ec5dac53adaf4b1c04d87ddfee136752660449655"></a>DICT_CHECK_NONE_LOADED</em>&nbsp;</td><td>
<p>No user tablespaces have been opened (no crash recovery, no transactions recovered). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af61a50a2413f51c1d1818911ec5dac53a7b613eeb43818835c41f33b87a2d9fc4"></a>DICT_CHECK_SOME_LOADED</em>&nbsp;</td><td>
<p>Some user tablespaces may have been opened (no crash recovery; recovered table locks for transactions). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af61a50a2413f51c1d1818911ec5dac53a41936340d61898fa0def59dcf9a82f61"></a>DICT_CHECK_ALL_LOADED</em>&nbsp;</td><td>
<p>All user tablespaces have been opened (crash recovery). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a7eec73bf89d9692ec12708a88ad862aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dict0load_8h.html#a7eec73bf89d9692ec12708a88ad862aa">dict_system_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum that defines all system table IDs. </p>
<dl class="section see"><dt>See Also</dt><dd>SYSTEM_TABLE_NAME[] </dd></dl>

</div>
</div>
<a class="anchor" id="a3f9fec93ae4fed092920b2813abf7286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286">dict_table_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status bit for <a class="el" href="dict0load_8h.html#ae4d51fddd3a5dd4fb2ca7d06c6e38f41">dict_process_sys_tables_rec_and_mtr_commit()</a> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3f9fec93ae4fed092920b2813abf7286a274880f997de17830b8db34b0f780f01"></a>DICT_TABLE_LOAD_FROM_RECORD</em>&nbsp;</td><td>
<p>Directly populate a <a class="el" href="structdict__table__t.html">dict_table_t</a> structure with information from a SYS_TABLES record </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3f9fec93ae4fed092920b2813abf7286ad784ff2e87a930163c9594c72fa805c0"></a>DICT_TABLE_LOAD_FROM_CACHE</em>&nbsp;</td><td>
<p>Check first whether <a class="el" href="structdict__table__t.html">dict_table_t</a> is in the cache, if so, return it </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ac0e77ed1341eb5a220c7ce9d1e0d149c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_check_tablespaces_and_store_max_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dict0load_8h.html#af61a50a2413f51c1d1818911ec5dac53">dict_check_t</a>&#160;</td>
          <td class="paramname"><em>dict_check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In a crash recovery we already have all the tablespace objects created. This function compares the space id information in the InnoDB data dictionary to what we already read with <a class="el" href="fil0fil_8h.html#a0288e7c7e88e282b6247cf2826920f0e">fil_load_single_table_tablespaces()</a>.</p>
<p>In a normal startup, we create the tablespace objects for every table in InnoDB's data dictionary, if the corresponding .ibd file exists. We also scan the biggest space id, and store it to fil_system. in: how to check </p>

</div>
</div>
<a class="anchor" id="aeda355029d59beea6b88e6aa4f4a8582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_get_and_save_data_dir_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dict_mutex_own</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure the data_file_name is saved in <a class="el" href="structdict__table__t.html">dict_table_t</a> if needed. Try to read it from the file dictionary first, then from SYS_DATAFILES. in: true if dict_sys-&gt;mutex is owned already </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99b5a060c595e8f38cd6f084abc7ccd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* dict_get_first_path </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the filepath for a spaceid from SYS_DATAFILES. This function provides a temporary heap which is used for the table lookup, but not for the path. The caller must free the memory for the path returned. This function can return NULL if the space ID is not found in SYS_DATAFILES, then the caller will assume that the ibd file is in the normal datadir. </p>
<dl class="section return"><dt>Returns</dt><dd>own: A copy of the first datafile found in SYS_DATAFILES.PATH for the given space ID. NULL if space ID is zero or not found. in: tablespace name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d7e532a8e51c0b3479eea8a1e416434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* dict_get_first_table_name_in_db </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first table name in the given database. </p>
<dl class="section return"><dt>Returns</dt><dd>own: table name, NULL if does not exist; the caller must free the memory in the string! in: database name which ends to '/' </dd></dl>

</div>
</div>
<a class="anchor" id="a5c19a5cf96b7585bbab387e6a1a2c557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const rec_t* dict_getnext_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function get the next system table record as we scan the table. </p>
<dl class="section return"><dt>Returns</dt><dd>the record if found, NULL if end of scan. in: the mini-transaction </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in/out: persistent cursor to the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dc8f060723ed80ae2c5e4b8144b2635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_insert_tablespace_and_filepath </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fsp_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert records into SYS_TABLESPACES and SYS_DATAFILES. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if OK, dberr_t if the insert failed in: tablespace flags </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">name</td><td>in: talespace name </td></tr>
    <tr><td class="paramname">filepath</td><td>in: filepath </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5561881e7092c1675f5010b053656275"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_load_column_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t *&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a table column definition from a SYS_COLUMNS record to <a class="el" href="structdict__table__t.html">dict_table_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success in: SYS_COLUMNS record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table, could be NULL if we just populate a dict_column_t struct with information from a SYS_COLUMNS record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: memory heap for temporary storage </td></tr>
    <tr><td class="paramname">column</td><td>out: dict_column_t to fill, or NULL if table != NULL </td></tr>
    <tr><td class="paramname">table_id</td><td>out: table id </td></tr>
    <tr><td class="paramname">col_name</td><td>out: column name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96d3aa2b127614ea3cc954c6dcb2af4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_load_field_low </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__field__t.html">dict_field_t</a> *&#160;</td>
          <td class="paramname"><em>sys_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>last_index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads an index field definition from a SYS_FIELDS record to <a class="el" href="structdict__index__t.html">dict_index_t</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success in: SYS_FIELDS record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_id</td><td>in/out: index id (8 bytes) an "in" value if index != NULL and "out" if index == NULL </td></tr>
    <tr><td class="paramname">index</td><td>in/out: index, could be NULL if we just populate a <a class="el" href="structdict__field__t.html">dict_field_t</a> struct with information from a SYS_FIELDS record </td></tr>
    <tr><td class="paramname">sys_field</td><td>out: <a class="el" href="structdict__field__t.html">dict_field_t</a> to be filled </td></tr>
    <tr><td class="paramname">pos</td><td>out: Field position </td></tr>
    <tr><td class="paramname">last_index_id</td><td>in: last index id </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: memory heap for temporary storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade9e80e8a6180896010eab6b33449dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_load_foreigns </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_charsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads foreign key constraints where the table is either the foreign key holder or where the table is referenced by a foreign key. Adds these constraints to the data dictionary. Note that we know that the dictionary cache already contains all constraints where the other relevant table is already in the dictionary cache. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_name</td><td>in: table name </td></tr>
    <tr><td class="paramname">col_names</td><td>in: column names, or NULL to use table-&gt;col_names </td></tr>
    <tr><td class="paramname">check_recursive</td><td>in: Whether to check recursive load of tables chained by FK </td></tr>
    <tr><td class="paramname">check_charsets</td><td>in: whether to check charset compatibility </td></tr>
    <tr><td class="paramname">ignore_err</td><td>in: error to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dcc2299781ed75a86fc87ea9ca0fdbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_load_index_low </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>allocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> **&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads an index definition from a SYS_INDEXES record to <a class="el" href="structdict__index__t.html">dict_index_t</a>. If allocate=TRUE, we will create a <a class="el" href="structdict__index__t.html">dict_index_t</a> structure and fill it accordingly. If allocated=FALSE, the <a class="el" href="structdict__index__t.html">dict_index_t</a> will be supplied by the caller and filled with information read from the record. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out,own: index, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_id</td><td>in/out: table id (8 bytes), an "in" value if allocate=TRUE and "out" when allocate=FALSE </td></tr>
    <tr><td class="paramname">table_name</td><td>in: table name </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: temporary memory heap </td></tr>
    <tr><td class="paramname">rec</td><td>in: SYS_INDEXES record </td></tr>
    <tr><td class="paramname">allocate</td><td>in: TRUE=allocate *index, FALSE=fill in a pre-allocated *index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a6f31780fba5af49be6276fe546a762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_load_sys_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is called when the database is booted. Loads system table index definitions except for the clustered index which is added to the dictionary cache at booting before calling this function. in: system table </p>

</div>
</div>
<a class="anchor" id="a0f8e9fc25745735bc436a0df203e7c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_load_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>cached</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a table definition and also all its index definitions, and also the cluster definition if the table is a member in a cluster. Also loads all foreign key constraints where the foreign key is in the table or where a foreign key references columns in this table. </p>
<dl class="section return"><dt>Returns</dt><dd>table, NULL if does not exist; if the table is stored in an .ibd file, but the file does not exist, then we set the ibd_file_missing flag TRUE in the table object we return in: error to be ignored when loading table and its indexes' definition </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name in the databasename/tablename format </td></tr>
    <tr><td class="paramname">cached</td><td>in: TRUE=add to cache, FALSE=do not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a4a8cce4027746548d848bf9e895e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_load_table_low </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> **&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a table definition from a SYS_TABLES record to <a class="el" href="structdict__table__t.html">dict_table_t</a>. Does not load any columns or indexes. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out,own: table, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>in: table name </td></tr>
    <tr><td class="paramname">rec</td><td>in: SYS_TABLES record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06b1dea1206d8e687f2ac45a0de66524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* dict_load_table_on_id </td>
          <td>(</td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0types_8h.html#a83692d2bec02fe094d1df8f4346e35fa">dict_err_ignore_t</a>&#160;</td>
          <td class="paramname"><em>ignore_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a table object based on the table id. </p>
<dl class="section return"><dt>Returns</dt><dd>table; NULL if table does not exist in: errors to ignore when loading the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_id</td><td>in: table id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9694b487a97ec3a971cf9939018e3b9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints to the standard output information on all tables found in the data dictionary system table. </p>

</div>
</div>
<a class="anchor" id="aec5de2844a181f3b334d155193b47609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_columns_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t *&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_COLUMNS record and populate a dict_column_t structure with the information from the record. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: column name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_COLUMNS rec </td></tr>
    <tr><td class="paramname">column</td><td>out: <a class="el" href="structdict__col__t.html">dict_col_t</a> to be filled </td></tr>
    <tr><td class="paramname">table_id</td><td>out: table id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a6cde22af7ed6f9f9000467337d6700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_datafiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_DATAFILES record, extracts necessary information from the record and returns to caller. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: datafile path </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_DATAFILES rec </td></tr>
    <tr><td class="paramname">space</td><td>out: pace id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71861a1a6d6fddfcdcaab0ed1ec87a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_fields_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__field__t.html">dict_field_t</a> *&#160;</td>
          <td class="paramname"><em>sys_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_id_t *&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>last_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_FIELDS record and populate a <a class="el" href="structdict__field__t.html">dict_field_t</a> structure with the information from the record. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success in: previous index id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_FIELDS rec </td></tr>
    <tr><td class="paramname">sys_field</td><td>out: <a class="el" href="structdict__field__t.html">dict_field_t</a> to be filled </td></tr>
    <tr><td class="paramname">pos</td><td>out: Field position </td></tr>
    <tr><td class="paramname">index_id</td><td>out: current index id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a247677cfee13f36c4f854390a3e066c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_foreign_col_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>for_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ref_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_FOREIGN_COLS record and extract necessary information from the record and return to caller. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: column position </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_FOREIGN_COLS rec </td></tr>
    <tr><td class="paramname">name</td><td>out: foreign key constraint name </td></tr>
    <tr><td class="paramname">for_col_name</td><td>out: referencing column name </td></tr>
    <tr><td class="paramname">ref_col_name</td><td>out: referenced column name in referenced table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a698eef4e4849922e231c8f786054c4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_foreign_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> *&#160;</td>
          <td class="paramname"><em>foreign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_FOREIGN record and populate a <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> structure with the information from the record. For detail information about SYS_FOREIGN fields, please refer to dict_load_foreign() function </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: <a class="el" href="structdict__foreign__t.html">dict_foreign_t</a> to be filled </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_FOREIGN rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a127597a2e4047bd8eaadb93a2a428c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_indexes_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_id_t *&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_INDEXES record and populate a <a class="el" href="structdict__index__t.html">dict_index_t</a> structure with the information from the record. For detail information about SYS_INDEXES fields, please refer to <a class="el" href="dict0boot_8h.html#ab178df175f38d441bf8a7c738a01210a">dict_boot()</a> function. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: table id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_INDEXES rec </td></tr>
    <tr><td class="paramname">index</td><td>out: <a class="el" href="structdict__index__t.html">dict_index_t</a> to be filled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4d51fddd3a5dd4fb2ca7d06c6e38f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_tables_rec_and_mtr_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> **&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0load_8h.html#a3f9fec93ae4fed092920b2813abf7286">dict_table_info_t</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function processes one SYS_TABLES record and populate the <a class="el" href="structdict__table__t.html">dict_table_t</a> struct for the table. Extracted out of <a class="el" href="dict0load_8h.html#a9694b487a97ec3a971cf9939018e3b9b">dict_print()</a> to be used by both monitor table output and information schema innodb_sys_tables output. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success in/out: mini-transaction, will be committed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: temporary memory heap </td></tr>
    <tr><td class="paramname">rec</td><td>in: SYS_TABLES record </td></tr>
    <tr><td class="paramname">table</td><td>out: <a class="el" href="structdict__table__t.html">dict_table_t</a> to fill </td></tr>
    <tr><td class="paramname">status</td><td>in: status bit controls options such as whether we shall look for <a class="el" href="structdict__table__t.html">dict_table_t</a> from cache first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc2dcecb4fcb42a8009614fcef379b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* dict_process_sys_tablespaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses a SYS_TABLESPACES record, extracts necessary information from the record and returns to caller. </p>
<dl class="section return"><dt>Returns</dt><dd>error message, or NULL on success out: tablespace flags </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in/out: heap memory </td></tr>
    <tr><td class="paramname">rec</td><td>in: current SYS_TABLESPACES rec </td></tr>
    <tr><td class="paramname">space</td><td>out: pace id </td></tr>
    <tr><td class="paramname">name</td><td>out: tablespace name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad42d27d10e2963510a8df47a4f8a3ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void dict_save_data_dir_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Using the table-&gt;heap, copy the null-terminated filepath into table-&gt;data_dir_path and put a null byte before the extension. This allows SHOW CREATE TABLE to return the correct DATA DIRECTORY path. Make this data directory path only if it has not yet been saved. in: filepath of tablespace </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18916653b9876a066bb8d232cff56650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const rec_t* dict_startscan_system </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dict0load_8h.html#a7eec73bf89d9692ec12708a88ad862aa">dict_system_id_t</a>&#160;</td>
          <td class="paramname"><em>system_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function opens a system table, and return the first record. </p>
<dl class="section return"><dt>Returns</dt><dd>first record of the system table in: which system table to open </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>out: persistent cursor to the record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: the mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3d0cdca3d4769e23f6cf028b6e4cf88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> dict_update_filepath </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the record for space_id in SYS_TABLESPACES to this filepath. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if OK, dberr_t if the insert failed in: filepath </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:19 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
