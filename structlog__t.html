<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: log_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">log_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="log0log_8h_source.html">log0log.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for log_t:</div>
<div class="dyncontent">
<div class="center"><img src="structlog__t__coll__graph.png" border="0" usemap="#log__t_coll__map" alt="Collaboration graph"/></div>
<map name="log__t_coll__map" id="log__t_coll__map">
<area shape="rect" id="node2" href="structos__event.html" title="os_event" alt="" coords="260,158,340,186"/><area shape="rect" id="node4" href="structut__list__node.html" title="ut_list_node\&lt; os_event_t \&gt;" alt="" coords="487,225,684,253"/><area shape="rect" id="node13" href="structib__mutex__t.html" title="ib_mutex_t" alt="" coords="539,150,632,178"/><area shape="rect" id="node20" href="structrw__lock__t.html" title="rw_lock_t" alt="" coords="920,313,1000,341"/><area shape="rect" id="node7" href="structos__fast__mutex__t.html" title="os_fast_mutex_t" alt="" coords="5,87,133,115"/><area shape="rect" id="node9" href="structut__list__base.html" title="ut_list_base\&lt; log_group_t \&gt;" alt="" coords="859,23,1061,51"/><area shape="rect" id="node11" href="structlog__group__t.html" title="log_group_t" alt="" coords="537,22,633,50"/><area shape="rect" id="node16" href="structut__list__node.html" title="ut_list_node\&lt; ib_mutex_t \&gt;" alt="" coords="860,227,1060,255"/><area shape="rect" id="node25" href="structut__list__node.html" title="ut_list_node\&lt; rw_lock_t \&gt;" alt="" coords="1216,303,1403,331"/><area shape="rect" id="node23" href="structut__list__base.html" title="ut_list_base\&lt; rw_lock\l_debug_t \&gt;" alt="" coords="507,381,664,425"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aa01622615dd1a9c8ef0f9bb9d0fa7bd8"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa01622615dd1a9c8ef0f9bb9d0fa7bd8">pad</a> [64]</td></tr>
<tr class="memitem:a878f2ad743088a4b759c97d3db612d38"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a878f2ad743088a4b759c97d3db612d38">lsn</a></td></tr>
<tr class="memitem:a1b5ef098383d0c1854de4eefa470127c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a1b5ef098383d0c1854de4eefa470127c">buf_free</a></td></tr>
<tr class="memitem:accb2fc6606608316915223b64779bf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#accb2fc6606608316915223b64779bf18">mutex</a></td></tr>
<tr class="memitem:a8b2d28240a546328a4d3c3be5d7f1512"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a8b2d28240a546328a4d3c3be5d7f1512">log_flush_order_mutex</a></td></tr>
<tr class="memitem:a3e92032a84096bf5b789858386bb5f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e92032a84096bf5b789858386bb5f9f"></a>
byte *&#160;</td><td class="memItemRight" valign="bottom"><b>buf_ptr</b></td></tr>
<tr class="memitem:a3aee81f21b230c2d0277c963c88adef8"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3aee81f21b230c2d0277c963c88adef8">buf</a></td></tr>
<tr class="memitem:a743aba9a5d1fd124cf6c6006f5f7ae25"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a743aba9a5d1fd124cf6c6006f5f7ae25">buf_size</a></td></tr>
<tr class="memitem:a696bcbfc9282911e95fec280e7ed1714"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a696bcbfc9282911e95fec280e7ed1714">max_buf_free</a></td></tr>
<tr class="memitem:a979c3ec17ad6cd8ee4f0dd1e7c713dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a979c3ec17ad6cd8ee4f0dd1e7c713dff">check_flush_or_checkpoint</a></td></tr>
<tr class="memitem:a44041ca9767a3834f3fb2e8e504d9f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; <a class="el" href="structlog__group__t.html">log_group_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a44041ca9767a3834f3fb2e8e504d9f07">log_groups</a></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7cc0cab9aa563bb161bc3dc4150b8256"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a7cc0cab9aa563bb161bc3dc4150b8256">buf_next_to_write</a></td></tr>
<tr class="memitem:ab11ace4235f3619c2ae6a018d35b71a4"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab11ace4235f3619c2ae6a018d35b71a4">is_extending</a></td></tr>
<tr class="memitem:aceb4b3a73157b8cadb92c88b2a202172"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aceb4b3a73157b8cadb92c88b2a202172">written_to_some_lsn</a></td></tr>
<tr class="memitem:a2cd72265cc0de24ce771ccd8040d1396"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a2cd72265cc0de24ce771ccd8040d1396">written_to_all_lsn</a></td></tr>
<tr class="memitem:aa3345a60d5001e2738c3d1dc323d3f8b"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa3345a60d5001e2738c3d1dc323d3f8b">write_lsn</a></td></tr>
<tr class="memitem:a66e7ba4341b991caf8c618af2977781d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a66e7ba4341b991caf8c618af2977781d">write_end_offset</a></td></tr>
<tr class="memitem:ab466e56430101cac2131514eeb845c7b"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ab466e56430101cac2131514eeb845c7b">current_flush_lsn</a></td></tr>
<tr class="memitem:a7076d4111cb85120bb76e9ddf44b4a7b"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a7076d4111cb85120bb76e9ddf44b4a7b">flushed_to_disk_lsn</a></td></tr>
<tr class="memitem:a3927d27d8d3b40871319cf1f011b7bcb"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3927d27d8d3b40871319cf1f011b7bcb">n_pending_writes</a></td></tr>
<tr class="memitem:a52349a74e8c5a62bfbed447680fca78d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a52349a74e8c5a62bfbed447680fca78d">no_flush_event</a></td></tr>
<tr class="memitem:a88b1893a4f83f01178c35fb212197d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a88b1893a4f83f01178c35fb212197d10">one_flushed</a></td></tr>
<tr class="memitem:a97f1e0ebcb1cdb7971ae81a3dc568fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a97f1e0ebcb1cdb7971ae81a3dc568fbf">one_flushed_event</a></td></tr>
<tr class="memitem:a6d13a6c448407fb45d5b5b9be5f47eca"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a6d13a6c448407fb45d5b5b9be5f47eca">n_log_ios</a></td></tr>
<tr class="memitem:a493b24cbcfa1418319a3b697ed209f0b"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a493b24cbcfa1418319a3b697ed209f0b">n_log_ios_old</a></td></tr>
<tr class="memitem:ae7470f7b80408ac90097ff0c204a7c90"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae7470f7b80408ac90097ff0c204a7c90">last_printout_time</a></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a64a979414837f295053e980b0cffae20"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a64a979414837f295053e980b0cffae20">log_group_capacity</a></td></tr>
<tr class="memitem:a508fcd6f26bca33415f08e5868b2c4ee"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a508fcd6f26bca33415f08e5868b2c4ee">max_modified_age_async</a></td></tr>
<tr class="memitem:aa34eabc85eb4e135f48864703a45f61e"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#aa34eabc85eb4e135f48864703a45f61e">max_modified_age_sync</a></td></tr>
<tr class="memitem:a3d3cb67692ef173533a0da3103f330fd"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a3d3cb67692ef173533a0da3103f330fd">max_checkpoint_age_async</a></td></tr>
<tr class="memitem:a53fe24e9cea9d08bfbe9e03399ae93b5"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a53fe24e9cea9d08bfbe9e03399ae93b5">max_checkpoint_age</a></td></tr>
<tr class="memitem:a96d6236ea91f642ef238f897c4c51cb2"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a96d6236ea91f642ef238f897c4c51cb2">next_checkpoint_no</a></td></tr>
<tr class="memitem:a45f3f2c8383e473f1d3d63e51636c6e4"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a45f3f2c8383e473f1d3d63e51636c6e4">last_checkpoint_lsn</a></td></tr>
<tr class="memitem:a0f8daba223fbc6069c41a431c51fadc4"><td class="memItemLeft" align="right" valign="top">lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a0f8daba223fbc6069c41a431c51fadc4">next_checkpoint_lsn</a></td></tr>
<tr class="memitem:a19ad1dad9509943e1a7d0320d4081b01"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a19ad1dad9509943e1a7d0320d4081b01">n_pending_checkpoint_writes</a></td></tr>
<tr class="memitem:ae59e38ee5ae1b62859bff705575f9aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#ae59e38ee5ae1b62859bff705575f9aa3">checkpoint_lock</a></td></tr>
<tr class="memitem:a401b2714e1058b5681b9694b8069eb47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a401b2714e1058b5681b9694b8069eb47"></a>
byte *&#160;</td><td class="memItemRight" valign="bottom"><b>checkpoint_buf_ptr</b></td></tr>
<tr class="memitem:a24b81f5da26ad67c019f66b2f5aa092f"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlog__t.html#a24b81f5da26ad67c019f66b2f5aa092f">checkpoint_buf</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Redo log buffer </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="a3aee81f21b230c2d0277c963c88adef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* log_t::buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log buffer </p>

</div>
</div>
<a class="anchor" id="a1b5ef098383d0c1854de4eefa470127c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::buf_free</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>first free offset within the log buffer </p>

</div>
</div>
<a class="anchor" id="a7cc0cab9aa563bb161bc3dc4150b8256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::buf_next_to_write</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The fields involved in the log buffer flush first offset in the log buffer where the byte content may not exist written to file, e.g., the start offset of a log record catenated later; this is advanced when a flush operation is completed to all the log groups </p>

</div>
</div>
<a class="anchor" id="a743aba9a5d1fd124cf6c6006f5f7ae25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::buf_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log buffer size in bytes </p>

</div>
</div>
<a class="anchor" id="a979c3ec17ad6cd8ee4f0dd1e7c713dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> log_t::check_flush_or_checkpoint</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is set to TRUE when there may be need to flush the log buffer, or preflush buffer pool pages, or make a checkpoint; this MUST be TRUE when lsn - last_checkpoint_lsn &gt; max_checkpoint_age; this flag is peeked at by <a class="el" href="log0log_8h.html#a38e07fd75176730e045801d04d2d8f36">log_free_check()</a>, which does not reserve the log mutex </p>

</div>
</div>
<a class="anchor" id="a24b81f5da26ad67c019f66b2f5aa092f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* log_t::checkpoint_buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>checkpoint header is read to this buffer </p>

</div>
</div>
<a class="anchor" id="ae59e38ee5ae1b62859bff705575f9aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> log_t::checkpoint_lock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this latch is x-locked when a checkpoint write is running; a thread should wait for this without owning the log mutex </p>

</div>
</div>
<a class="anchor" id="ab466e56430101cac2131514eeb845c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::current_flush_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>end lsn for the current running write + flush operation </p>

</div>
</div>
<a class="anchor" id="a7076d4111cb85120bb76e9ddf44b4a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::flushed_to_disk_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>how far we have written the log AND flushed to disk </p>

</div>
</div>
<a class="anchor" id="ab11ace4235f3619c2ae6a018d35b71a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool log_t::is_extending</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is set to true during extend the log buffer size </p>

</div>
</div>
<a class="anchor" id="a45f3f2c8383e473f1d3d63e51636c6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::last_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>latest checkpoint lsn </p>

</div>
</div>
<a class="anchor" id="ae7470f7b80408ac90097ff0c204a7c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t log_t::last_printout_time</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when log_print was last time called </p>

</div>
</div>
<a class="anchor" id="a8b2d28240a546328a4d3c3be5d7f1512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a> log_t::log_flush_order_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mutex to serialize access to the flush list when we are putting dirty blocks in the list. The idea behind this mutex is to be able to release log_sys-&gt;mutex during mtr_commit and still ensure that insertions in the flush_list happen in the LSN order. </p>

</div>
</div>
<a class="anchor" id="a64a979414837f295053e980b0cffae20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::log_group_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fields involved in checkpoints capacity of the log group; if the checkpoint age exceeds this, it is a serious error because it is possible we will then overwrite log and spoil crash recovery </p>

</div>
</div>
<a class="anchor" id="a44041ca9767a3834f3fb2e8e504d9f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; <a class="el" href="structlog__group__t.html">log_group_t</a> &gt; log_t::log_groups</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log groups </p>

</div>
</div>
<a class="anchor" id="a878f2ad743088a4b759c97d3db612d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>log sequence number </p>

</div>
</div>
<a class="anchor" id="a696bcbfc9282911e95fec280e7ed1714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::max_buf_free</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recommended maximum value of buf_free, after which the buffer is flushed </p>

</div>
</div>
<a class="anchor" id="a53fe24e9cea9d08bfbe9e03399ae93b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::max_checkpoint_age</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is the maximum allowed value for lsn - last_checkpoint_lsn when a new query step is started </p>

</div>
</div>
<a class="anchor" id="a3d3cb67692ef173533a0da3103f330fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::max_checkpoint_age_async</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when this checkpoint age is exceeded we start an asynchronous writing of a new checkpoint </p>

</div>
</div>
<a class="anchor" id="a508fcd6f26bca33415f08e5868b2c4ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::max_modified_age_async</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when this recommended value for lsn - <a class="el" href="buf0buf_8h.html#a7f96406b87de005b0234f06c369d8ad4">buf_pool_get_oldest_modification()</a> is exceeded, we start an asynchronous preflush of pool pages </p>

</div>
</div>
<a class="anchor" id="aa34eabc85eb4e135f48864703a45f61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::max_modified_age_sync</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when this recommended value for lsn - <a class="el" href="buf0buf_8h.html#a7f96406b87de005b0234f06c369d8ad4">buf_pool_get_oldest_modification()</a> is exceeded, we start a synchronous preflush of pool pages </p>

</div>
</div>
<a class="anchor" id="accb2fc6606608316915223b64779bf18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a> log_t::mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mutex protecting the log </p>

</div>
</div>
<a class="anchor" id="a6d13a6c448407fb45d5b5b9be5f47eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::n_log_ios</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of log i/os initiated thus far </p>

</div>
</div>
<a class="anchor" id="a493b24cbcfa1418319a3b697ed209f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::n_log_ios_old</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of log i/o's at the previous printout </p>

</div>
</div>
<a class="anchor" id="a19ad1dad9509943e1a7d0320d4081b01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::n_pending_checkpoint_writes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of currently pending checkpoint writes </p>

</div>
</div>
<a class="anchor" id="a3927d27d8d3b40871319cf1f011b7bcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::n_pending_writes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of currently pending flushes or writes </p>

</div>
</div>
<a class="anchor" id="a0f8daba223fbc6069c41a431c51fadc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::next_checkpoint_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>next checkpoint lsn </p>

</div>
</div>
<a class="anchor" id="a96d6236ea91f642ef238f897c4c51cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t log_t::next_checkpoint_no</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>next checkpoint number </p>

</div>
</div>
<a class="anchor" id="a52349a74e8c5a62bfbed447680fca78d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::no_flush_event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this event is in the reset state when a flush or a write is running; a thread should wait for this without owning the log mutex, but NOTE that to set or reset this event, the thread MUST own the log mutex! </p>

</div>
</div>
<a class="anchor" id="a88b1893a4f83f01178c35fb212197d10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> log_t::one_flushed</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>during a flush, this is first FALSE and becomes TRUE when one log group has been written or flushed </p>

</div>
</div>
<a class="anchor" id="a97f1e0ebcb1cdb7971ae81a3dc568fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0sync_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> log_t::one_flushed_event</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this event is reset when the flush or write has not yet completed for any log group; e.g., this means that a transaction has been committed when this is set; a thread should wait for this without owning the log mutex, but NOTE that to set or reset this event, the thread MUST own the log mutex! </p>

</div>
</div>
<a class="anchor" id="aa01622615dd1a9c8ef0f9bb9d0fa7bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte log_t::pad[64]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>padding to prevent other memory update hotspots from residing on the same memory cache line </p>

</div>
</div>
<a class="anchor" id="a66e7ba4341b991caf8c618af2977781d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint log_t::write_end_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the data in buffer has been written up to this offset when the current write ends: this field will then be copied to buf_next_to_write </p>

</div>
</div>
<a class="anchor" id="aa3345a60d5001e2738c3d1dc323d3f8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::write_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>end lsn for the current running write </p>

</div>
</div>
<a class="anchor" id="a2cd72265cc0de24ce771ccd8040d1396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::written_to_all_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>first log sequence number not yet written to some log group; for this to be advanced, it is enough that the write i/o has been completed for all log groups. Note that since InnoDB currently has only one log group therefore this value is redundant. Also it is possible that this value falls behind the flushed_to_disk_lsn transiently. It is appropriate to use either flushed_to_disk_lsn or write_lsn which are always up-to-date and accurate. </p>

</div>
</div>
<a class="anchor" id="aceb4b3a73157b8cadb92c88b2a202172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lsn_t log_t::written_to_some_lsn</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>first log sequence number not yet written to any log group; for this to be advanced, it is enough that the write i/o has been completed for any one log group </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="log0log_8h_source.html">log0log.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:27 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
