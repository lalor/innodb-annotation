<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: dict_table_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">dict_table_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for dict_table_t:</div>
<div class="dyncontent">
<div class="center"><img src="structdict__table__t__coll__graph.png" border="0" usemap="#dict__table__t_coll__map" alt="Collaboration graph"/></div>
<map name="dict__table__t_coll__map" id="dict__table__t_coll__map">
<area shape="rect" id="node6" href="structdict__index__t.html" title="dict_index_t" alt="" coords="1345,291,1444,319"/><area shape="rect" id="node37" href="structut__list__node.html" title="ut_list_node\&lt; dict\l_table_t \&gt;" alt="" coords="1327,439,1463,483"/><area shape="rect" id="node2" href="structut__list__base.html" title="ut_list_base\&lt; ib_lock_t \&gt;" alt="" coords="729,573,911,601"/><area shape="rect" id="node4" href="structut__list__base.html" title="ut_list_base\&lt; dict\l_index_t \&gt;" alt="" coords="1597,473,1733,517"/><area shape="rect" id="node31" href="structtrx__t.html" title="trx_t" alt="" coords="1640,291,1691,319"/><area shape="rect" id="node44" href="structlock__t.html" title="lock_t" alt="" coords="1803,291,1861,319"/><area shape="rect" id="node9" href="structmem__block__info__t.html" title="mem_block_info_t" alt="" coords="192,175,331,203"/><area shape="rect" id="node15" href="structfts__t.html" title="fts_t" alt="" coords="795,355,845,383"/><area shape="rect" id="node24" href="structfts__cache__t.html" title="fts_cache_t" alt="" coords="508,405,601,433"/><area shape="rect" id="node11" href="structrw__lock__t.html" title="rw_lock_t" alt="" coords="221,481,301,509"/><area shape="rect" id="node13" href="structib__mutex__t.html" title="ib_mutex_t" alt="" coords="5,377,99,405"/><area shape="rect" id="node19" href="structib__wqueue__t.html" title="ib_wqueue_t" alt="" coords="367,301,468,329"/><area shape="rect" id="node17" href="structib__vector__t.html" title="ib_vector_t" alt="" coords="216,622,307,650"/><area shape="rect" id="node41" href="structdict__col__t.html" title="dict_col_t" alt="" coords="779,470,861,498"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a5fd834c4e02a708c2c0516b5243ad481"><td class="memItemLeft" align="right" valign="top">table_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5fd834c4e02a708c2c0516b5243ad481">id</a></td></tr>
<tr class="memitem:abd49eb87685c3c33dd7ac2251848fb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abd49eb87685c3c33dd7ac2251848fb2e">heap</a></td></tr>
<tr class="memitem:ab075f273bdfd4c19af4622c4c635e386"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab075f273bdfd4c19af4622c4c635e386">name</a></td></tr>
<tr class="memitem:aa573c56a274864e0c404faacc3e030c9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aa573c56a274864e0c404faacc3e030c9">dir_path_of_temp_table</a></td></tr>
<tr class="memitem:ad316c99317dc28b413182a6d12a88479"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad316c99317dc28b413182a6d12a88479">data_dir_path</a></td></tr>
<tr class="memitem:a57d007a7f1b85f926cc44eafa04a2837"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a57d007a7f1b85f926cc44eafa04a2837">space</a>:32</td></tr>
<tr class="memitem:a51e3d4308f670a6b42c3e2039eeed3d8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a51e3d4308f670a6b42c3e2039eeed3d8">flags</a>:<a class="el" href="dict0mem_8h.html#a7dfce6a229c11744deab0809f06fe142">DICT_TF_BITS</a></td></tr>
<tr class="memitem:a4598e387bf8d852ef6a7170b15bccc66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4598e387bf8d852ef6a7170b15bccc66">flags2</a>:<a class="el" href="dict0mem_8h.html#ab3c09638ef2265f7b22a6d3ca30a3b35">DICT_TF2_BITS</a></td></tr>
<tr class="memitem:a2eb8d0391a3a1ce361b564556b82d9b5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a2eb8d0391a3a1ce361b564556b82d9b5">ibd_file_missing</a>:1</td></tr>
<tr class="memitem:a67c76cfb5862fab3192148ae97c00cc1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a67c76cfb5862fab3192148ae97c00cc1">cached</a>:1</td></tr>
<tr class="memitem:a28e878692b99a4ea16060ec25144ffa9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a28e878692b99a4ea16060ec25144ffa9">to_be_dropped</a>:1</td></tr>
<tr class="memitem:a92082952a3b52c39fd37d2315f1a5cff"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a92082952a3b52c39fd37d2315f1a5cff">n_def</a>:10</td></tr>
<tr class="memitem:a0f0c150acb6968737452a440e41ec0c9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0f0c150acb6968737452a440e41ec0c9">n_cols</a>:10</td></tr>
<tr class="memitem:ac6996f2920d98097205131aad80bb0e1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac6996f2920d98097205131aad80bb0e1">can_be_evicted</a>:1</td></tr>
<tr class="memitem:a5ad28f2a1139c1d16b4b5e128a32c5fc"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a5ad28f2a1139c1d16b4b5e128a32c5fc">corrupted</a>:1</td></tr>
<tr class="memitem:a1d1f35ed4e92acbe220d5e64480e4233"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a1d1f35ed4e92acbe220d5e64480e4233">drop_aborted</a>:1</td></tr>
<tr class="memitem:afee2ac9c1d316d0169d04ca10a2683aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__col__t.html">dict_col_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#afee2ac9c1d316d0169d04ca10a2683aa">cols</a></td></tr>
<tr class="memitem:acebefe253630ad16e0e099122cfc1bd0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#acebefe253630ad16e0e099122cfc1bd0">col_names</a></td></tr>
<tr class="memitem:a3202106cc628383de654064f001c0f38"><td class="memItemLeft" align="right" valign="top">hash_node_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3202106cc628383de654064f001c0f38">name_hash</a></td></tr>
<tr class="memitem:ae0a7a02c5ba461ff2bfd39e4aeeeddb1"><td class="memItemLeft" align="right" valign="top">hash_node_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae0a7a02c5ba461ff2bfd39e4aeeeddb1">id_hash</a></td></tr>
<tr class="memitem:a6120c2bfb676e2e3abb294423e9ab61c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; <a class="el" href="structdict__index__t.html">dict_index_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6120c2bfb676e2e3abb294423e9ab61c">indexes</a></td></tr>
<tr class="memitem:a21585f145969b36ff7f2830ebe94b2b5"><td class="memItemLeft" align="right" valign="top">dict_foreign_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a21585f145969b36ff7f2830ebe94b2b5">foreign_set</a></td></tr>
<tr class="memitem:a911bf67a965468e083cb116fd877d0ac"><td class="memItemLeft" align="right" valign="top">dict_foreign_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a911bf67a965468e083cb116fd877d0ac">referenced_set</a></td></tr>
<tr class="memitem:aa9db7d6d3d68204126c794cadb398364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__list__node.html">ut_list_node</a>&lt; <a class="el" href="structdict__table__t.html">dict_table_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#aa9db7d6d3d68204126c794cadb398364">table_LRU</a></td></tr>
<tr class="memitem:a98e532a77039adb3889bb5b091311076"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a98e532a77039adb3889bb5b091311076">fk_max_recusive_level</a>:8</td></tr>
<tr class="memitem:a7bd457a2582a286c6c7a561ded93dff5"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a7bd457a2582a286c6c7a561ded93dff5">n_foreign_key_checks_running</a></td></tr>
<tr class="memitem:a6ef3c3974ae8ba1ab208ad3cefea8533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a6ef3c3974ae8ba1ab208ad3cefea8533">def_trx_id</a></td></tr>
<tr class="memitem:af73a73555e6a859373e0bea307c2e3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#af73a73555e6a859373e0bea307c2e3fb">query_cache_inv_trx_id</a></td></tr>
<tr class="memitem:a38380681b2a7f78b16c20a5ca7e3bb86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a38380681b2a7f78b16c20a5ca7e3bb86">does_not_fit_in_memory</a></td></tr>
<tr class="memitem:ae0a6ab68d71761df5e7f39b88ed0e359"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae0a6ab68d71761df5e7f39b88ed0e359">big_rows</a>:1</td></tr>
<tr class="memitem:a4794d93beeafa0e2128c226aacf83e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac8fca69819417dbd51226e79c3b890d6">ib_quiesce_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4794d93beeafa0e2128c226aacf83e80">quiesce</a></td></tr>
<tr class="memitem:afd13467542a8cbf80b07ec806633b2d1"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#afd13467542a8cbf80b07ec806633b2d1">n_rec_locks</a></td></tr>
<tr class="memitem:a4060203e1802268ad6d2f162be7d9d28"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a4060203e1802268ad6d2f162be7d9d28">n_ref_count</a></td></tr>
<tr class="memitem:ab042e2a192b0ec183cae2db5b14609ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; ib_lock_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab042e2a192b0ec183cae2db5b14609ac">locks</a></td></tr>
<tr class="memitem:a20c502fc8dc35dd0390a0db72b7cb0ef"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a20c502fc8dc35dd0390a0db72b7cb0ef">magic_n</a></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1faacbf3c7842c55b651facf2f53b713"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a1faacbf3c7842c55b651facf2f53b713">stats_latch_created</a></td></tr>
<tr class="memitem:a0f177330ff4f45c3ec6d088472c5bbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0f177330ff4f45c3ec6d088472c5bbe4">stats_latch</a></td></tr>
<tr class="memitem:abe8110ba21eb149e06437aaeb9e9c6e8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#abe8110ba21eb149e06437aaeb9e9c6e8">stat_initialized</a>:1</td></tr>
<tr class="memitem:a3aa2adc2bcdf5db7904f52aeadff9991"><td class="memItemLeft" align="right" valign="top">lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3aa2adc2bcdf5db7904f52aeadff9991">memcached_sync_count</a></td></tr>
<tr class="memitem:afec0d92904c0c7309e0294fd04df4112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ut0ut_8h.html#aefa75a301c357c9780b2b68cce397653">ib_time_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#afec0d92904c0c7309e0294fd04df4112">stats_last_recalc</a></td></tr>
<tr class="memitem:ab70d5e79cd1985a0284bdd4eae19ef7d"><td class="memItemLeft" align="right" valign="top">ib_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab70d5e79cd1985a0284bdd4eae19ef7d">stat_persistent</a></td></tr>
<tr class="memitem:ab966a60dfd3c2074ec7798a61bc099aa"><td class="memItemLeft" align="right" valign="top">ib_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab966a60dfd3c2074ec7798a61bc099aa">stats_auto_recalc</a></td></tr>
<tr class="memitem:a3a2a489fd543ade2d791a10a1c5da519"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a3a2a489fd543ade2d791a10a1c5da519">stats_sample_pages</a></td></tr>
<tr class="memitem:a345a3524ef7ec47e9756bf8b0eceb8e9"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a345a3524ef7ec47e9756bf8b0eceb8e9">stat_n_rows</a></td></tr>
<tr class="memitem:a13e379354a0d53b2db7534d713b4af85"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a13e379354a0d53b2db7534d713b4af85">stat_clustered_index_size</a></td></tr>
<tr class="memitem:a80bf5dd1d0b7a8c7cf3c6763a4ab3145"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a80bf5dd1d0b7a8c7cf3c6763a4ab3145">stat_sum_of_other_index_sizes</a></td></tr>
<tr class="memitem:a992be3582ca0a42d73288245101b9679"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a992be3582ca0a42d73288245101b9679">stat_modified_counter</a></td></tr>
<tr class="memitem:ac0b54dbe0d80817647fd6bed40d6f420"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ac0b54dbe0d80817647fd6bed40d6f420">stats_bg_flag</a></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad4bc107da72f1c794c349d12cfea62c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ad4bc107da72f1c794c349d12cfea62c4">autoinc_lock</a></td></tr>
<tr class="memitem:ab493efbfa4d01db7b72621ddaf7f3a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ab493efbfa4d01db7b72621ddaf7f3a5f">autoinc_mutex</a></td></tr>
<tr class="memitem:a9bc9eca688908d401b842857fcf98247"><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a9bc9eca688908d401b842857fcf98247">autoinc_mutex_created</a></td></tr>
<tr class="memitem:ae6519de514e3ea5fe14635d647f7caaa"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#ae6519de514e3ea5fe14635d647f7caaa">autoinc</a></td></tr>
<tr class="memitem:a0d9c10dbf758beff2c49240474ca9fe3"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a0d9c10dbf758beff2c49240474ca9fe3">n_waiting_or_granted_auto_inc_locks</a></td></tr>
<tr class="memitem:a505d26c510fb491a13df75ac5c6eb156"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdict__table__t.html#a505d26c510fb491a13df75ac5c6eb156">autoinc_trx</a></td></tr>
<tr class="memitem:aaf3098bfa56cedf99fd2f6f0e7105cd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3098bfa56cedf99fd2f6f0e7105cd7"></a>
<a class="el" href="structfts__t.html">fts_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>fts</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><pre class="fragment">Data structure for a database table.  Most fields will be
</pre><p> initialized to 0, NULL or FALSE in <a class="el" href="dict0mem_8h.html#a6695177f9526cd5ba0fcd7bbaf1882b5">dict_mem_table_create()</a>. </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="ae6519de514e3ea5fe14635d647f7caaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::autoinc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>autoinc counter value to give to the next inserted row </p>

</div>
</div>
<a class="anchor" id="ad4bc107da72f1c794c349d12cfea62c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__t.html">lock_t</a>* dict_table_t::autoinc_lock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>!&lt; The following fields are used by the AUTOINC code. The actual collection of tables locked during AUTOINC read/write is kept in <a class="el" href="structtrx__t.html">trx_t</a>. In order to quickly determine whether a transaction has locked the AUTOINC lock we keep a pointer to the transaction here in the autoinc_trx variable. This is to avoid acquiring the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a> and scanning the vector in <a class="el" href="structtrx__t.html">trx_t</a>.</p>
<p>When an AUTOINC lock has to wait, the corresponding lock instance is created on the trx lock heap rather than use the pre-allocated instance in autoinc_lock below. a buffer for an AUTOINC lock for this table: we allocate the memory here so that individual transactions can get it and release it without a need to allocate space from the lock heap of the trx: otherwise the lock heap would grow rapidly if we do a large insert from a select </p>

</div>
</div>
<a class="anchor" id="ab493efbfa4d01db7b72621ddaf7f3a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__mutex__t.html">ib_mutex_t</a>* dict_table_t::autoinc_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mutex protecting the autoincrement counter </p>

</div>
</div>
<a class="anchor" id="a9bc9eca688908d401b842857fcf98247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a> dict_table_t::autoinc_mutex_created</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creation state of autoinc_mutex member </p>

</div>
</div>
<a class="anchor" id="a505d26c510fb491a13df75ac5c6eb156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtrx__t.html">trx_t</a>* dict_table_t::autoinc_trx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The transaction that currently holds the the AUTOINC lock on this table. Protected by lock_sys-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="ae0a6ab68d71761df5e7f39b88ed0e359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::big_rows</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag: TRUE if the maximum length of a single row exceeds BIG_ROW_SIZE; initialized in <a class="el" href="dict0dict_8h.html#a46fe5735e84793626e0ee3e21390608f">dict_table_add_to_cache()</a> </p>

</div>
</div>
<a class="anchor" id="a67c76cfb5862fab3192148ae97c00cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::cached</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the table object has been added to the dictionary cache </p>

</div>
</div>
<a class="anchor" id="ac6996f2920d98097205131aad80bb0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::can_be_evicted</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if it's not an InnoDB system table or a table that has no FK relationships </p>

</div>
</div>
<a class="anchor" id="acebefe253630ad16e0e099122cfc1bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_t::col_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Column names packed in a character string "name1\0name2\0...nameN\0". Until the string contains n_cols, it will be allocated from a temporary heap. The final string will be allocated from table-&gt;heap. </p>

</div>
</div>
<a class="anchor" id="afee2ac9c1d316d0169d04ca10a2683aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__col__t.html">dict_col_t</a>* dict_table_t::cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>array of column descriptions </p>

</div>
</div>
<a class="anchor" id="a5ad28f2a1139c1d16b4b5e128a32c5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::corrupted</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if table is corrupted </p>

</div>
</div>
<a class="anchor" id="ad316c99317dc28b413182a6d12a88479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* dict_table_t::data_dir_path</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NULL or the directory path specified by DATA DIRECTORY </p>

</div>
</div>
<a class="anchor" id="a6ef3c3974ae8ba1ab208ad3cefea8533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> dict_table_t::def_trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>transaction id that last touched the table definition, either when loading the definition or CREATE TABLE, or ALTER TABLE (prepare, commit, and rollback phases) </p>

</div>
</div>
<a class="anchor" id="aa573c56a274864e0c404faacc3e030c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dict_table_t::dir_path_of_temp_table</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NULL or the directory path where a TEMPORARY table that was explicitly created by a user should be placed if innodb_file_per_table is defined in my.cnf; in Unix this is usually /tmp/..., in Windows temp... </p>

</div>
</div>
<a class="anchor" id="a38380681b2a7f78b16c20a5ca7e3bb86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> dict_table_t::does_not_fit_in_memory</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this field is used to specify in simulations tables which are so big that disk should be accessed: disk access is simulated by putting the thread to sleep for a while; NOTE that this flag is not stored to the data dictionary on disk, and the database will forget about value TRUE if it has to reload the table definition from disk </p>

</div>
</div>
<a class="anchor" id="a1d1f35ed4e92acbe220d5e64480e4233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::drop_aborted</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if some indexes should be dropped after ONLINE_INDEX_ABORTED or ONLINE_INDEX_ABORTED_DROPPED </p>

</div>
</div>
<a class="anchor" id="a98e532a77039adb3889bb5b091311076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::fk_max_recusive_level</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum recursive level we support when loading tables chained together with FK constraints. If exceeds this level, we will stop loading child table into memory along with its parent table </p>

</div>
</div>
<a class="anchor" id="a51e3d4308f670a6b42c3e2039eeed3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::flags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DICT_TF_... </p>

</div>
</div>
<a class="anchor" id="a4598e387bf8d852ef6a7170b15bccc66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::flags2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DICT_TF2_... </p>

</div>
</div>
<a class="anchor" id="a21585f145969b36ff7f2830ebe94b2b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_foreign_set dict_table_t::foreign_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set of foreign key constraints in the table; these refer to columns in other tables </p>

</div>
</div>
<a class="anchor" id="abd49eb87685c3c33dd7ac2251848fb2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* dict_table_t::heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap </p>

</div>
</div>
<a class="anchor" id="a2eb8d0391a3a1ce361b564556b82d9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::ibd_file_missing</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if this is in a single-table tablespace and the .ibd file is missing; then we must return in ha_innodb.cc an error if the user tries to query such an orphaned table </p>

</div>
</div>
<a class="anchor" id="a5fd834c4e02a708c2c0516b5243ad481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">table_id_t dict_table_t::id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>id of the table </p>

</div>
</div>
<a class="anchor" id="ae0a7a02c5ba461ff2bfd39e4aeeeddb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_node_t dict_table_t::id_hash</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hash chain node </p>

</div>
</div>
<a class="anchor" id="a6120c2bfb676e2e3abb294423e9ab61c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; <a class="el" href="structdict__index__t.html">dict_index_t</a> &gt; dict_table_t::indexes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>list of indexes of the table </p>

</div>
</div>
<a class="anchor" id="ab042e2a192b0ec183cae2db5b14609ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; ib_lock_t &gt; dict_table_t::locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>list of locks on the table; protected by lock_sys-&gt;mutex </p>

</div>
</div>
<a class="anchor" id="a20c502fc8dc35dd0390a0db72b7cb0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::magic_n</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>magic number </p>

</div>
</div>
<a class="anchor" id="a3aa2adc2bcdf5db7904f52aeadff9991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lint dict_table_t::memcached_sync_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count of how many handles are opened to this table from memcached; DDL on the table is NOT allowed until this count goes to zero. If it's -1, means there's DDL on the table, DML from memcached will be blocked. </p>

</div>
</div>
<a class="anchor" id="a0f0c150acb6968737452a440e41ec0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of columns </p>

</div>
</div>
<a class="anchor" id="a92082952a3b52c39fd37d2315f1a5cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::n_def</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of columns defined so far </p>

</div>
</div>
<a class="anchor" id="a7bd457a2582a286c6c7a561ded93dff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::n_foreign_key_checks_running</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count of how many foreign key check operations are currently being performed on the table: we cannot drop the table while there are foreign key checks running on it! </p>

</div>
</div>
<a class="anchor" id="afd13467542a8cbf80b07ec806633b2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::n_rec_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count of the number of record locks on this table. We use this to determine whether we can evict the table from the dictionary cache. It is protected by lock_sys-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="a4060203e1802268ad6d2f162be7d9d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::n_ref_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>count of how many handles are opened to this table; dropping of the table is NOT allowed until this count gets to zero; MySQL does NOT itself check the number of open handles at drop </p>

</div>
</div>
<a class="anchor" id="a0d9c10dbf758beff2c49240474ca9fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulong dict_table_t::n_waiting_or_granted_auto_inc_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This counter is used to track the number of granted and pending autoinc locks on this table. This value is set after acquiring the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a> but we peek the contents to determine whether other transactions have acquired the AUTOINC lock or not. Of course only one transaction can be granted the lock but there can be multiple waiters. </p>

</div>
</div>
<a class="anchor" id="ab075f273bdfd4c19af4622c4c635e386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* dict_table_t::name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>table name </p>

</div>
</div>
<a class="anchor" id="a3202106cc628383de654064f001c0f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash_node_t dict_table_t::name_hash</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>hash chain node </p>

</div>
</div>
<a class="anchor" id="af73a73555e6a859373e0bea307c2e3fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> dict_table_t::query_cache_inv_trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>transactions whose trx id is smaller than this number are not allowed to store to the MySQL query cache or retrieve from it; when a trx with undo logs commits, it sets this to the value of the trx id counter for the tables it had an IX lock on </p>

</div>
</div>
<a class="anchor" id="a4794d93beeafa0e2128c226aacf83e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac8fca69819417dbd51226e79c3b890d6">ib_quiesce_t</a> dict_table_t::quiesce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quiescing states, protected by the <a class="el" href="structdict__index__t.html#a1165532697fe1335055c0e9b0f7a28e0">dict_index_t::lock</a>. ie. we can only change the state if we acquire all the latches (<a class="el" href="structdict__index__t.html#a1165532697fe1335055c0e9b0f7a28e0">dict_index_t::lock</a>) in X mode of this table's indexes. </p>

</div>
</div>
<a class="anchor" id="a911bf67a965468e083cb116fd877d0ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dict_foreign_set dict_table_t::referenced_set</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>list of foreign key constraints which refer to this table </p>

</div>
</div>
<a class="anchor" id="a57d007a7f1b85f926cc44eafa04a2837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::space</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>space where the clustered index of the table is placed </p>

</div>
</div>
<a class="anchor" id="a13e379354a0d53b2db7534d713b4af85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stat_clustered_index_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>approximate clustered index size in database pages </p>

</div>
</div>
<a class="anchor" id="abe8110ba21eb149e06437aaeb9e9c6e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::stat_initialized</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if statistics have been calculated the first time after database startup or table creation </p>

</div>
</div>
<a class="anchor" id="a992be3582ca0a42d73288245101b9679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::stat_modified_counter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when a row is inserted, updated, or deleted, we add 1 to this number; we calculate new estimates for the stat_... values for the table and the indexes when about 1 / 16 of table has been modified; also when the estimate operation is called for MySQL SHOW TABLE STATUS; the counter is reset to zero at statistics calculation; this counter is not protected by any latch, because this is only used for heuristics </p>

</div>
</div>
<a class="anchor" id="a345a3524ef7ec47e9756bf8b0eceb8e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t dict_table_t::stat_n_rows</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>approximate number of rows in the table; we periodically calculate new estimates </p>

</div>
</div>
<a class="anchor" id="ab70d5e79cd1985a0284bdd4eae19ef7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint32_t dict_table_t::stat_persistent</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The two bits below are set in the ::stat_persistent member and have the following meaning:</p>
<ol type="1">
<li>_ON=0, _OFF=0, no explicit persistent stats setting for this table, the value of the global srv_stats_persistent is used to determine whether the table has persistent stats enabled or not</li>
<li>_ON=0, _OFF=1, persistent stats are explicitly disabled for this table, regardless of the value of the global srv_stats_persistent</li>
<li>_ON=1, _OFF=0, persistent stats are explicitly enabled for this table, regardless of the value of the global srv_stats_persistent</li>
<li>_ON=1, _OFF=1, not allowed, we assert if this ever happens. </li>
</ol>

</div>
</div>
<a class="anchor" id="a80bf5dd1d0b7a8c7cf3c6763a4ab3145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stat_sum_of_other_index_sizes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>other indexes in database pages </p>

</div>
</div>
<a class="anchor" id="ab966a60dfd3c2074ec7798a61bc099aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint32_t dict_table_t::stats_auto_recalc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The two bits below are set in the ::stats_auto_recalc member and have the following meaning:</p>
<ol type="1">
<li>_ON=0, _OFF=0, no explicit auto recalc setting for this table, the value of the global srv_stats_persistent_auto_recalc is used to determine whether the table has auto recalc enabled or not</li>
<li>_ON=0, _OFF=1, auto recalc is explicitly disabled for this table, regardless of the value of the global srv_stats_persistent_auto_recalc</li>
<li>_ON=1, _OFF=0, auto recalc is explicitly enabled for this table, regardless of the value of the global srv_stats_persistent_auto_recalc</li>
<li>_ON=1, _OFF=1, not allowed, we assert if this ever happens. </li>
</ol>

</div>
</div>
<a class="anchor" id="ac0b54dbe0d80817647fd6bed40d6f420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte dict_table_t::stats_bg_flag</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>see BG_STAT_* above. Writes are covered by dict_sys-&gt;mutex. Dirty reads are possible. </p>

</div>
</div>
<a class="anchor" id="afec0d92904c0c7309e0294fd04df4112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ut0ut_8h.html#aefa75a301c357c9780b2b68cce397653">ib_time_t</a> dict_table_t::stats_last_recalc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timestamp of last recalc of the stats </p>

</div>
</div>
<a class="anchor" id="a0f177330ff4f45c3ec6d088472c5bbe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrw__lock__t.html">rw_lock_t</a>* dict_table_t::stats_latch</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this latch protects: <a class="el" href="structdict__table__t.html#abe8110ba21eb149e06437aaeb9e9c6e8">dict_table_t::stat_initialized</a> <a class="el" href="structdict__table__t.html#a345a3524ef7ec47e9756bf8b0eceb8e9">dict_table_t::stat_n_rows</a> (*) <a class="el" href="structdict__table__t.html#a13e379354a0d53b2db7534d713b4af85">dict_table_t::stat_clustered_index_size</a> <a class="el" href="structdict__table__t.html#a80bf5dd1d0b7a8c7cf3c6763a4ab3145">dict_table_t::stat_sum_of_other_index_sizes</a> <a class="el" href="structdict__table__t.html#a992be3582ca0a42d73288245101b9679">dict_table_t::stat_modified_counter</a> (*) <a class="el" href="structdict__table__t.html#a6120c2bfb676e2e3abb294423e9ab61c">dict_table_t::indexes</a>*::stat_n_diff_key_vals[] <a class="el" href="structdict__table__t.html#a6120c2bfb676e2e3abb294423e9ab61c">dict_table_t::indexes</a>*::stat_index_size <a class="el" href="structdict__table__t.html#a6120c2bfb676e2e3abb294423e9ab61c">dict_table_t::indexes</a>*::stat_n_leaf_pages (*) those are not always protected for performance reasons </p>

</div>
</div>
<a class="anchor" id="a1faacbf3c7842c55b651facf2f53b713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="classos__once.html#a76b1ff71a045a72c666cc0654bec1fcb">os_once::state_t</a> dict_table_t::stats_latch_created</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Statistics for query optimization Creation state of 'stats_latch'. </p>

</div>
</div>
<a class="anchor" id="a3a2a489fd543ade2d791a10a1c5da519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint dict_table_t::stats_sample_pages</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the number of pages to sample for this table during persistent stats estimation; if this is 0, then the value of the global srv_stats_persistent_sample_pages will be used instead. </p>

</div>
</div>
<a class="anchor" id="aa9db7d6d3d68204126c794cadb398364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__list__node.html">ut_list_node</a>&lt; <a class="el" href="structdict__table__t.html">dict_table_t</a> &gt; dict_table_t::table_LRU</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>node of the LRU list of tables </p>

</div>
</div>
<a class="anchor" id="a28e878692b99a4ea16060ec25144ffa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned dict_table_t::to_be_dropped</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the table is to be dropped, but not yet actually dropped (could in the bk drop list); It is turned on at the beginning of <a class="el" href="row0mysql_8h.html#afb42043f47bdcda294bc4b01e90229fa">row_drop_table_for_mysql()</a> and turned off just before we start to update system tables for the drop. It is protected by dict_operation_lock </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:27 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
