<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/buf0flu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0flu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0flu_8ic.html">buf0flu.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buf0flu.h:</div>
<div class="dyncontent">
<div class="center"><img src="buf0flu_8h__incl.png" border="0" usemap="#include_2buf0flu_8h" alt=""/></div>
<map name="include_2buf0flu_8h" id="include_2buf0flu_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buf0flu_8h__dep__incl.png" border="0" usemap="#include_2buf0flu_8hdep" alt=""/></div>
<map name="include_2buf0flu_8hdep" id="include_2buf0flu_8hdep">
</map>
</div>
</div>
<p><a href="buf0flu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c10073f8f2608c74511614b3fb6c63d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a2c10073f8f2608c74511614b3fb6c63d">buf_flush_remove</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:ab103ef786b28c99629d79d8f89e768e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab103ef786b28c99629d79d8f89e768e8">buf_flush_relocate_on_flush_list</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="memitem:aeb4d812b4926a7d43eaf8dfc386e904d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aeb4d812b4926a7d43eaf8dfc386e904d">buf_flush_write_complete</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a4460ad4f28ba2c245bda6cc4bfbfbe2c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a4460ad4f28ba2c245bda6cc4bfbfbe2c">buf_flush_init_for_writing</a> (byte *page, void *page_zip_, lsn_t newest_lsn)</td></tr>
<tr class="memitem:ac4aca463389889914cfa6d8d599431e9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ac4aca463389889914cfa6d8d599431e9">buf_flush_page_try</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:abe9c99474dd78fbb55e8ed2e1dd5cea9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#abe9c99474dd78fbb55e8ed2e1dd5cea9">buf_flush_list</a> (ulint min_n, lsn_t lsn_limit, ulint *n_processed)</td></tr>
<tr class="memitem:a9cdcc4f760f8ebd33c02f0cd042490b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a9cdcc4f760f8ebd33c02f0cd042490b4">buf_flush_single_page_from_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:ae775b5ae847bc1c02cb581bf69ce1931"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ae775b5ae847bc1c02cb581bf69ce1931">buf_flush_wait_batch_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> type)</td></tr>
<tr class="memitem:af6980abb9a2999e94fa8774fd501828d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#af6980abb9a2999e94fa8774fd501828d">buf_flush_wait_batch_end_wait_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> type)</td></tr>
<tr class="memitem:a48b6a156aad91f522c6d48e19d707d2c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a48b6a156aad91f522c6d48e19d707d2c">buf_flush_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a109aff89cdb96f674786a8b913be0043"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a109aff89cdb96f674786a8b913be0043">buf_flush_recv_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, lsn_t start_lsn, lsn_t end_lsn)</td></tr>
<tr class="memitem:a03ddaefb5098a15d7b40822fc0108dc0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a03ddaefb5098a15d7b40822fc0108dc0">buf_flush_ready_for_replace</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a514fb1b0bfe633eb72bbfe7f4b6bb491"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <br class="typebreak"/>
<a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a514fb1b0bfe633eb72bbfe7f4b6bb491">buf_flush_page_cleaner_thread</a> (void *arg)</td></tr>
<tr class="memitem:a18c9b352f7400e101a335d34f36f6021"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a18c9b352f7400e101a335d34f36f6021">buf_flush_LRU_tail</a> (void)</td></tr>
<tr class="memitem:a516ba4c6df1e52b8f19586ee715ebda7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a516ba4c6df1e52b8f19586ee715ebda7">buf_flush_wait_LRU_batch_end</a> (void)</td></tr>
<tr class="memitem:a72e89cfa1ea280e4fb9658ffcbd0a053"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a72e89cfa1ea280e4fb9658ffcbd0a053">buf_flush_validate</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:aeb49fa7dbba8849c77339ecf1a363ac3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aeb49fa7dbba8849c77339ecf1a363ac3">buf_flush_init_flush_rbt</a> (void)</td></tr>
<tr class="memitem:a3e647da62f866e246ae0c827700a1959"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a3e647da62f866e246ae0c827700a1959">buf_flush_free_flush_rbt</a> (void)</td></tr>
<tr class="memitem:ab5914fbbf06f6b008435e61ba0e3dadc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab5914fbbf06f6b008435e61ba0e3dadc">buf_flush_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type, bool sync)</td></tr>
<tr class="memitem:a7f6760d9bb35b313542253092f35803d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a7f6760d9bb35b313542253092f35803d">buf_flush_ready_for_flush</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type))</td></tr>
<tr class="memitem:a9075e571114635a0a2ed2e7158a491c9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a9075e571114635a0a2ed2e7158a491c9">buf_pool_get_dirty_pages_count</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint id)</td></tr>
<tr class="memitem:a1bb8c7555408df6bed6592d58609bb85"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a1bb8c7555408df6bed6592d58609bb85">buf_flush_get_dirty_pages_count</a> (ulint id)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa3430b20c0430c4730079e4d2242568a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aa3430b20c0430c4730079e4d2242568a">buf_page_cleaner_is_active</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The database buffer pool flush algorithm</p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="a3e647da62f866e246ae0c827700a1959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_free_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees up the red-black tree. </p>

</div>
</div>
<a class="anchor" id="a1bb8c7555408df6bed6592d58609bb85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_flush_get_dirty_pages_count </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are any dirty pages that belong to a space id in the flush list. </p>
<dl class="section return"><dt>Returns</dt><dd>count of dirty pages present in all the buffer pools in: space id to check </dd></dl>

</div>
</div>
<a class="anchor" id="aeb49fa7dbba8849c77339ecf1a363ac3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the red-black tree to speed up insertions into the flush_list during recovery process. Should be called at the start of recovery process before any page has been read/written. </p>

</div>
</div>
<a class="anchor" id="a4460ad4f28ba2c245bda6cc4bfbfbe2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_init_for_writing </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>page_zip_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>newest_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a page for writing to the tablespace. in: newest modification lsn to the page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: page </td></tr>
    <tr><td class="paramname">page_zip_</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe9c99474dd78fbb55e8ed2e1dd5cea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_list </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. NOTE: The calling thread is not allowed to own any latches on pages! </p>
<dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance out: the number of pages which were processed is passed back to caller. Ignored if NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_n</td><td>in: wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18c9b352f7400e101a335d34f36f6021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_flush_LRU_tail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears up tail of the LRU lists: Put replaceable pages at the tail of LRU to the free list Flush dirty pages at the tail of LRU to the disk The depth to which we scan each buffer pool is controlled by dynamic config parameter innodb_LRU_scan_depth. </p>
<dl class="section return"><dt>Returns</dt><dd>total pages flushed </dd></dl>

</div>
</div>
<a class="anchor" id="a48b6a156aad91f522c6d48e19d707d2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called at a mini-transaction commit, if a page was modified in it. Puts the block to the list of modified blocks, if it not already in it. in: mtr</p>
<p>This function should be called at a mini-transaction commit, if a page was modified in it. Puts the block to the list of modified blocks, if it is not already in it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block which is modified </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5914fbbf06f6b008435e61ba0e3dadc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a flushable page asynchronously from the buffer pool to a file. NOTE: in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! NOTE: buf_pool-&gt;mutex and buf_page_get_mutex(bpage) must be held upon entering this function, and they will be released by this function if it returns true. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the page was flushed in: true if sync IO request </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: buffer control block </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a514fb1b0bfe633eb72bbfe7f4b6bb491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() buf_flush_page_cleaner_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>page_cleaner thread tasked with flushing dirty pages from the buffer pools. As of now we'll have only one instance of this thread. </p>
<dl class="section return"><dt>Returns</dt><dd>a dummy parameter in: a dummy parameter required by os_thread_create </dd></dl>

</div>
</div>
<a class="anchor" id="ac4aca463389889914cfa6d8d599431e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_flush_page_try </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a flushable page asynchronously from the buffer pool to a file. NOTE: buf_pool-&gt;mutex and block-&gt;mutex must be held upon entering this function, and they will be released by this function after flushing. This is loosely based on buf_flush_batch() and <a class="el" href="buf0flu_8h.html#ab5914fbbf06f6b008435e61ba0e3dadc">buf_flush_page()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the page was flushed and the mutexes released </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f6760d9bb35b313542253092f35803d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_flush_ready_for_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the block is modified and ready for flushing. </p>
<dl class="section return"><dt>Returns</dt><dd>true if can flush immediately </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer control block, must be buf_page_in_file(bpage) </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: type of flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03ddaefb5098a15d7b40822fc0108dc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_flush_ready_for_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., transition FILE_PAGE =&gt; NOT_USED allowed. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if can replace immediately in: buffer control block, must be buf_page_in_file(bpage) and in the LRU list </dd></dl>

</div>
</div>
<a class="anchor" id="a109aff89cdb96f674786a8b913be0043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_recv_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called when recovery has modified a buffer page. in: end lsn of the last mtr in the set of mtr's</p>
<p>This function should be called when recovery has modified a buffer page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block which is modified </td></tr>
    <tr><td class="paramname">start_lsn</td><td>in: start lsn of the first mtr in a set of mtr's </td></tr>
    <tr><td class="paramname">end_lsn</td><td>in: end lsn of the last mtr in the set of mtr's </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab103ef786b28c99629d79d8f89e768e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_relocate_on_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relocates a buffer control block on the flush_list. Note that it is assumed that the contents of bpage has already been copied to dpage. in/out: destination block </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c10073f8f2608c74511614b3fb6c63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a block from the flush list of modified blocks. in: pointer to the block in question </p>

</div>
</div>
<a class="anchor" id="a9cdcc4f760f8ebd33c02f0cd042490b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_flush_single_page_from_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function picks up a single dirty page from the tail of the LRU list, flushes it, removes it from page_hash and LRU list and puts it on the free list. It is called from user threads when they are unable to find a replacable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success. in/out: buffer pool instance </dd></dl>

</div>
</div>
<a class="anchor" id="a72e89cfa1ea280e4fb9658ffcbd0a053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_flush_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the flush list. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>

</div>
</div>
<a class="anchor" id="ae775b5ae847bc1c02cb581bf69ce1931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_batch_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until a flush batch of the given type ends in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6980abb9a2999e94fa8774fd501828d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_batch_end_wait_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until a flush batch of the given type ends. This is called by a thread that only wants to wait for a flush to end but doesn't do any flushing itself. in: BUF_FLUSH_LRU or BUF_FLUSH_LIST </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a516ba4c6df1e52b8f19586ee715ebda7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_wait_LRU_batch_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for any possible LRU flushes that are in progress to end. </p>

</div>
</div>
<a class="anchor" id="aeb4d812b4926a7d43eaf8dfc386e904d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_write_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the flush system data structures when a write is completed. in: pointer to the block in question </p>

</div>
</div>
<a class="anchor" id="a9075e571114635a0a2ed2e7158a491c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_pool_get_dirty_pages_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are any dirty pages that belong to a space id in the flush list in a particular buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of dirty pages present in a single buffer pool in: space id to check </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="aa3430b20c0430c4730079e4d2242568a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_cleaner_is_active</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicating if the page_cleaner is in active state. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:19 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
