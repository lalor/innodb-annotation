<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/buf0lru.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0lru.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0lru_8ic.html">buf0lru.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buf0lru.h:</div>
<div class="dyncontent">
<div class="center"><img src="buf0lru_8h__incl.png" border="0" usemap="#include_2buf0lru_8h" alt=""/></div>
<map name="include_2buf0lru_8h" id="include_2buf0lru_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="655,161,708,189"/><area shape="rect" id="node28" href="ut0byte_8h.html" title="ut0byte.h" alt="" coords="719,83,801,111"/><area shape="rect" id="node33" href="buf0types_8h.html" title="buf0types.h" alt="" coords="825,83,921,111"/><area shape="rect" id="node35" href="buf0lru_8ic.html" title="buf0lru.ic" alt="" coords="945,83,1025,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="787,238,864,266"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="888,238,955,266"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="919,315,993,343"/><area shape="rect" id="node31" href="ut0byte_8ic.html" title="ut0byte.ic" alt="" coords="732,161,817,189"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buf0lru_8h__dep__incl.png" border="0" usemap="#include_2buf0lru_8hdep" alt=""/></div>
<map name="include_2buf0lru_8hdep" id="include_2buf0lru_8hdep">
<area shape="rect" id="node3" href="buf0buf_8ic.html" title="include/buf0buf.ic" alt="" coords="5,83,136,111"/><area shape="rect" id="node7" href="ibuf0ibuf_8ic.html" title="include/ibuf0ibuf.ic" alt="" coords="160,83,299,111"/><area shape="rect" id="node5" href="buf0buf_8h.html" title="include/buf0buf.h" alt="" coords="5,161,136,189"/></map>
</div>
</div>
<p><a href="buf0lru_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics for selecting the LRU list for eviction.  <a href="structbuf__LRU__stat__t.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8d6ec57c76991ad6ffd4d87309a49c38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a8d6ec57c76991ad6ffd4d87309a49c38">BUF_LRU_OLD_MIN_LEN</a>&#160;&#160;&#160;512	/* 8 megabytes of 16k pages */</td></tr>
<tr class="memitem:ad33fa022c81d8729f8cedbbac34651ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ad33fa022c81d8729f8cedbbac34651ab">buf_LRU_stat_inc_io</a>()&#160;&#160;&#160;buf_LRU_stat_cur.io++</td></tr>
<tr class="memitem:af0cd4b974ea6729a6b36693b401c7716"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#af0cd4b974ea6729a6b36693b401c7716">buf_LRU_stat_inc_unzip</a>()&#160;&#160;&#160;buf_LRU_stat_cur.unzip++</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4611e5052e6224a62739ece490eb2911"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a4611e5052e6224a62739ece490eb2911">buf_LRU_buf_pool_running_out</a> (void)</td></tr>
<tr class="memitem:ab99dac00850f8ebe4e1484374933ed4c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ab99dac00850f8ebe4e1484374933ed4c">buf_LRU_flush_or_remove_pages</a> (ulint id, <a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a> buf_remove, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memitem:a11b60d14957a5570efd35b243d298845"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a11b60d14957a5570efd35b243d298845">buf_LRU_insert_zip_clean</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:aeddeeb43ec9b564c9f4d8b5246ca158d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aeddeeb43ec9b564c9f4d8b5246ca158d">buf_LRU_free_page</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, bool zip))</td></tr>
<tr class="memitem:acb188d8b3908148e06478c2e41087e94"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#acb188d8b3908148e06478c2e41087e94">buf_LRU_scan_and_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> scan_all))</td></tr>
<tr class="memitem:a620c6d6b21e026770ae8e1e0e2243d77"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a620c6d6b21e026770ae8e1e0e2243d77">buf_LRU_get_free_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:aaf70f40d311e23704b3e493c02ca0325"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aaf70f40d311e23704b3e493c02ca0325">buf_LRU_get_free_block</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool))</td></tr>
<tr class="memitem:a9bd03c170ed086b99c0e0649d050dc88"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a9bd03c170ed086b99c0e0649d050dc88">buf_LRU_evict_from_unzip_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:a204e54967aca38df0a7665b921322cd7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a204e54967aca38df0a7665b921322cd7">buf_LRU_block_free_non_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:acbc884b89bf4620827364d712b3986af"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#acbc884b89bf4620827364d712b3986af">buf_LRU_add_block</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> old)</td></tr>
<tr class="memitem:abe99c70be542655a19648a464fda4c23"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#abe99c70be542655a19648a464fda4c23">buf_unzip_LRU_add_block</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> old)</td></tr>
<tr class="memitem:a49614ef80c43a8541c9af0bdda6e906c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a49614ef80c43a8541c9af0bdda6e906c">buf_LRU_make_block_young</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a4a2e31d5ae18b651ce3b6b8ec703931c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a4a2e31d5ae18b651ce3b6b8ec703931c">buf_LRU_make_block_old</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a6bbc7ab48b7f48b3efe8f8ced0c95eb6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a6bbc7ab48b7f48b3efe8f8ced0c95eb6">buf_LRU_old_ratio_update</a> (uint old_pct, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> adjust)</td></tr>
<tr class="memitem:a510e3c258d1dca172ec012d449af58a0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a510e3c258d1dca172ec012d449af58a0">buf_LRU_stat_update</a> (void)</td></tr>
<tr class="memitem:a882d638781fd27fde52496b1fe81793d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a882d638781fd27fde52496b1fe81793d">buf_LRU_free_one_page</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a719485af1204ec07bae003a8cf4c6d70"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a719485af1204ec07bae003a8cf4c6d70">buf_LRU_validate</a> (void)</td></tr>
<tr class="memitem:ad90a8fc10b7cd49a5f1b7098b514a47a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#ad90a8fc10b7cd49a5f1b7098b514a47a">buf_LRU_print</a> (void)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa535da980a8fb505f33884c4d838e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aa535da980a8fb505f33884c4d838e65b">buf_LRU_stat_cur</a></td></tr>
<tr class="memitem:a875cfab89124f0c3eee966035fd211e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a875cfab89124f0c3eee966035fd211e8">buf_LRU_stat_sum</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
Heuristics for detecting index scan @{</h2></td></tr>
<tr class="memitem:aae4d83c458daabfcd368131289b46af9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:a7b18661ce0d86a7dd2f2aee37820cc7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a7b18661ce0d86a7dd2f2aee37820cc7a">BUF_LRU_OLD_RATIO_MAX</a>&#160;&#160;&#160;<a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a></td></tr>
<tr class="memitem:a7df9eccdeaed1e37b90a32c76cda1520"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a7df9eccdeaed1e37b90a32c76cda1520">BUF_LRU_OLD_RATIO_MIN</a>&#160;&#160;&#160;51</td></tr>
<tr class="memitem:a22fb54c3fd2164554f62ef7b3c100607"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0lru_8h.html#a22fb54c3fd2164554f62ef7b3c100607">buf_LRU_old_threshold_ms</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The database buffer pool LRU replacement algorithm</p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a8d6ec57c76991ad6ffd4d87309a49c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_MIN_LEN&#160;&#160;&#160;512	/* 8 megabytes of 16k pages */</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum LRU list length for which the LRU_old pointer is defined </p>

</div>
</div>
<a class="anchor" id="aae4d83c458daabfcd368131289b46af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_DIV&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The denominator of buf_pool-&gt;LRU_old_ratio. </p>

</div>
</div>
<a class="anchor" id="a7b18661ce0d86a7dd2f2aee37820cc7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_MAX&#160;&#160;&#160;<a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Maximum value of buf_pool-&gt;LRU_old_ratio.
</pre> <dl class="section see"><dt>See Also</dt><dd>buf_LRU_old_adjust_len </dd>
<dd>
buf_pool-&gt;LRU_old_ratio_update </dd></dl>

</div>
</div>
<a class="anchor" id="a7df9eccdeaed1e37b90a32c76cda1520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_LRU_OLD_RATIO_MIN&#160;&#160;&#160;51</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Minimum value of buf_pool-&gt;LRU_old_ratio.
</pre> <dl class="section see"><dt>See Also</dt><dd>buf_LRU_old_adjust_len </dd>
<dd>
buf_pool-&gt;LRU_old_ratio_update The minimum must exceed (BUF_LRU_OLD_TOLERANCE + 5) * <a class="el" href="buf0lru_8h.html#aae4d83c458daabfcd368131289b46af9">BUF_LRU_OLD_RATIO_DIV</a> / <a class="el" href="buf0lru_8h.html#a8d6ec57c76991ad6ffd4d87309a49c38">BUF_LRU_OLD_MIN_LEN</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad33fa022c81d8729f8cedbbac34651ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_LRU_stat_inc_io</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;buf_LRU_stat_cur.io++</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the I/O counter in buf_LRU_stat_cur. </p>

</div>
</div>
<a class="anchor" id="af0cd4b974ea6729a6b36693b401c7716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_LRU_stat_inc_unzip</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;buf_LRU_stat_cur.unzip++</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the <a class="el" href="page0zip_8h.html#a00c766dc78fbe58e060bb8092fe24e15">page_zip_decompress()</a> counter in buf_LRU_stat_cur. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="acbc884b89bf4620827364d712b3986af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a block to the LRU list. Please make sure that the zip_size is already set into the page zip when invoking the function, so that we can get correct zip_size from the buffer page when adding a block into LRU in: TRUE if should be put to the old blocks in the LRU list, else put to the start; if the LRU list is very short, added to the start regardless of this parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a204e54967aca38df0a7665b921322cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_block_free_non_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts a block back to the free list. in: block, must not contain a file page </p>

</div>
</div>
<a class="anchor" id="a4611e5052e6224a62739ece490eb2911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_LRU_buf_pool_running_out </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if less than 25 % of the buffer pool is available. This can be used in heuristics to prevent huge transactions eating up the whole buffer pool for their locks. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if less than 25 % of buffer pool left </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd03c170ed086b99c0e0649d050dc88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_LRU_evict_from_unzip_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if the unzip_LRU list should be used for evicting a victim instead of the general LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if should use unzip_LRU </dd></dl>

</div>
</div>
<a class="anchor" id="ab99dac00850f8ebe4e1484374933ed4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_flush_or_remove_pages </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a64b07ecd8aec364fe56a54bcd279b3b3">buf_remove_t</a>&#160;</td>
          <td class="paramname"><em>buf_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes all dirty pages or removes all pages belonging to a given tablespace. A PROBLEM: if readahead is being started, what guarantees that it will not try to read in pages after this operation has completed? to check if the operation must be interrupted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>in: space id </td></tr>
    <tr><td class="paramname">buf_remove</td><td>in: remove or flush strategy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a882d638781fd27fde52496b1fe81793d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_free_one_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove one page from LRU list and put it to free list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: block, must contain a file page and be in a state where it can be freed; there may or may not be a hash index to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeddeeb43ec9b564c9f4d8b5246ca158d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_LRU_free_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to free a block. If bpage is a descriptor of a compressed-only page, the descriptor object will be freed as well.</p>
<p>NOTE: If this function returns true, it will temporarily release buf_pool-&gt;mutex. Furthermore, the page frame will no longer be accessible via bpage.</p>
<p>The caller must hold buf_pool-&gt;mutex and must not hold any <a class="el" href="buf0buf_8h.html#a9aeabb407e37058610eda62ebf0c1f67">buf_page_get_mutex()</a> when calling this function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if freed, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block to be freed </td></tr>
    <tr><td class="paramname">zip</td><td>in: true if should remove also the compressed page of an uncompressed page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf70f40d311e23704b3e493c02ca0325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a free block from the buf_pool. The block is taken off the free list. If it is empty, blocks are moved from the end of the LRU list to the free list. This function is called from a user thread when it needs a clean block to read in a page. Note that we only ever get a block from the free list. Even when we flush a page or find a page in LRU scan we put it to free list to be used. iteration 0: get a block from free list, success:done if there is an LRU flush batch in progress: wait for batch to end: retry free list if buf_pool-&gt;try_LRU_scan is set scan LRU up to srv_LRU_scan_depth to find a clean block the above will put the block on free list success:retry the free list flush one dirty page from tail of LRU to disk the above will put the block on free list success: retry the free list iteration 1: same as iteration 0 except: scan whole LRU list scan LRU list even if buf_pool-&gt;try_LRU_scan is not set iteration &gt; 1: same as iteration 1 but sleep 100ms </p>
<dl class="section return"><dt>Returns</dt><dd>the free control block, in state BUF_BLOCK_READY_FOR_USE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in/out: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a620c6d6b21e026770ae8e1e0e2243d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_LRU_get_free_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a free block from the buf_pool. The block is taken off the free list. If it is empty, returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>a free control block, or NULL if the buf_block-&gt;free list is empty buffer pool instance </dd></dl>

</div>
</div>
<a class="anchor" id="a11b60d14957a5570efd35b243d298845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_insert_zip_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a compressed block into buf_pool-&gt;zip_clean in the LRU order. in: pointer to the block in question </p>

</div>
</div>
<a class="anchor" id="a4a2e31d5ae18b651ce3b6b8ec703931c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_make_block_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a block to the end of the LRU list. in: control block </p>

</div>
</div>
<a class="anchor" id="a49614ef80c43a8541c9af0bdda6e906c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_make_block_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a block to the start of the LRU list. in: control block </p>

</div>
</div>
<a class="anchor" id="a6bbc7ab48b7f48b3efe8f8ced0c95eb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_LRU_old_ratio_update </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>old_pct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>adjust</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates buf_pool-&gt;LRU_old_ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>updated old_pct in: TRUE=adjust the LRU list; FALSE=just assign buf_pool-&gt;LRU_old_ratio during the initialization of InnoDB </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_pct</td><td>in: Reserve this percentage of the buffer pool for "old" blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad90a8fc10b7cd49a5f1b7098b514a47a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the LRU list. </p>

</div>
</div>
<a class="anchor" id="acb188d8b3908148e06478c2e41087e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_LRU_scan_and_free_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>scan_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to free a replaceable block. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if found and freed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">scan_all</td><td>in: scan whole LRU list if TRUE, otherwise scan only 'old' blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a510e3c258d1dca172ec012d449af58a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_LRU_stat_update </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the historical stats that we are collecting for LRU eviction policy at the end of each interval. </p>

</div>
</div>
<a class="anchor" id="a719485af1204ec07bae003a8cf4c6d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_LRU_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE </dd></dl>

</div>
</div>
<a class="anchor" id="abe99c70be542655a19648a464fda4c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_unzip_LRU_add_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a block to the LRU list of decompressed zip pages. in: TRUE if should be put to the end of the list, else put to the start </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="a22fb54c3fd2164554f62ef7b3c100607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint buf_LRU_old_threshold_ms</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Move blocks to "new" LRU list only if the first access was at
</pre><p> least this many milliseconds ago. Not protected by any mutex or latch. </p>

</div>
</div>
<a class="anchor" id="aa535da980a8fb505f33884c4d838e65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_cur</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Current operation counters.  Not protected by any mutex.
</pre><p> Cleared by <a class="el" href="buf0lru_8h.html#a510e3c258d1dca172ec012d449af58a0">buf_LRU_stat_update()</a>. </p>

</div>
</div>
<a class="anchor" id="a875cfab89124f0c3eee966035fd211e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__LRU__stat__t.html">buf_LRU_stat_t</a> buf_LRU_stat_sum</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Running sum of past values of buf_LRU_stat_cur.
</pre><p> Updated by <a class="el" href="buf0lru_8h.html#a510e3c258d1dca172ec012d449af58a0">buf_LRU_stat_update()</a>. Protected by buf_pool-&gt;mutex. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:25 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
