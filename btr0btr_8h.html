<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/btr0btr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0btr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0btr_8ic.html">btr0btr.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for btr0btr.h:</div>
<div class="dyncontent">
<div class="center"><img src="btr0btr_8h__incl.png" border="0" usemap="#include_2btr0btr_8h" alt=""/></div>
<map name="include_2btr0btr_8h" id="include_2btr0btr_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="btr0btr_8h__dep__incl.png" border="0" usemap="#include_2btr0btr_8hdep" alt=""/></div>
<map name="include_2btr0btr_8hdep" id="include_2btr0btr_8hdep">
</map>
</div>
</div>
<p><a href="btr0btr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a478a4bd54ccaf1b7bcff648f788e16fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a478a4bd54ccaf1b7bcff648f788e16fd">BTR_PAGE_MAX_REC_SIZE</a>&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> / 2 - 200)</td></tr>
<tr class="memitem:a673d044d0cec2c50072b3c14df981105"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a673d044d0cec2c50072b3c14df981105">BTR_MAX_LEVELS</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a673d044d0cec2c50072b3c14df981105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum depth of a B-tree in InnoDB.  <a href="#a673d044d0cec2c50072b3c14df981105"></a><br/></td></tr>
<tr class="memitem:a40347c97c1fb5f99ddcddf9e668582ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a40347c97c1fb5f99ddcddf9e668582ed">BTR_INSERT</a>&#160;&#160;&#160;512</td></tr>
<tr class="memitem:a35f3d4c758c0e30f9bd431bd2fbb6bde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a35f3d4c758c0e30f9bd431bd2fbb6bde">BTR_ESTIMATE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:a4d60c590bdff77da23ac065d8ccf8d80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a4d60c590bdff77da23ac065d8ccf8d80">BTR_IGNORE_SEC_UNIQUE</a>&#160;&#160;&#160;2048</td></tr>
<tr class="memitem:a450f46fe2b1bc6a9f8dc48aec50c79f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a450f46fe2b1bc6a9f8dc48aec50c79f8">BTR_DELETE_MARK</a>&#160;&#160;&#160;4096</td></tr>
<tr class="memitem:a572eaf29657a028929c5a9581de20e70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a572eaf29657a028929c5a9581de20e70">BTR_DELETE</a>&#160;&#160;&#160;8192</td></tr>
<tr class="memitem:aece5c042925d9f0034aa994a56e2cbfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aece5c042925d9f0034aa994a56e2cbfb">BTR_ALREADY_S_LATCHED</a>&#160;&#160;&#160;16384</td></tr>
<tr class="memitem:aa60b568a3b8345949e70acea4130d767"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_LATCH_MODE_WITHOUT_FLAGS</b>(latch_mode)</td></tr>
<tr class="memitem:a2e7b9b7db7f01f12accffb27b543d03d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a2e7b9b7db7f01f12accffb27b543d03d">btr_assert_not_corrupted</a>(<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, index)</td></tr>
<tr class="memitem:a48dfa061b5a1639c00c7dcb823da834b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48dfa061b5a1639c00c7dcb823da834b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_blob_dbg_add_blob</b>(rec, field_no, page, index, ctx)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="memitem:a00511ef890482f8bcdd60d8ade5506b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00511ef890482f8bcdd60d8ade5506b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_blob_dbg_set_deleted_flag</b>(rec, index, offsets, del)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="memitem:ac97f6205e1eca75994e1f6e69b499879"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac97f6205e1eca75994e1f6e69b499879"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_blob_dbg_owner</b>(rec, index, offsets, i, val)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="memitem:a81bd5885a53ec0e5458390907f4669ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81bd5885a53ec0e5458390907f4669ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_blob_dbg_assert_empty</b>(index, page_no)&#160;&#160;&#160;((void) 0)</td></tr>
<tr class="memitem:a6569d289073c2673e15384cc1d6a88fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6569d289073c2673e15384cc1d6a88fc">btr_block_get</a>(space, zip_size, page_no, mode, index, mtr)</td></tr>
<tr class="memitem:a5378895a36c860165f55bbbe8f22c32a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a5378895a36c860165f55bbbe8f22c32a">btr_page_get</a>(space, zip_size, page_no, mode, idx, mtr)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a>(<a class="el" href="btr0btr_8h.html#a6569d289073c2673e15384cc1d6a88fc">btr_block_get</a>(space,zip_size,page_no,mode,idx,mtr))</td></tr>
<tr class="memitem:ad8f69a3a51aa6d003885a7b14562cd4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f69a3a51aa6d003885a7b14562cd4f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_page_get_level</b>(page, mtr)&#160;&#160;&#160;<a class="el" href="btr0btr_8ic.html#a573f7dd66509be89eaeeaad8201f729b">btr_page_get_level_low</a>(page)</td></tr>
<tr class="memitem:a558ab04c61d04bd8e4904157405624b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a558ab04c61d04bd8e4904157405624b4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_insert_on_non_leaf_level</b>(f, i, l, t, m)&#160;&#160;&#160;<a class="el" href="btr0btr_8h.html#a3a124d637dd1a9d7ba341cde9e7e9af0">btr_insert_on_non_leaf_level_func</a>(f,i,l,t,__FILE__,__LINE__,m)</td></tr>
<tr class="memitem:ae693faeca995271eb27f60e74fda3395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae693faeca995271eb27f60e74fda3395"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_N_LEAF_PAGES</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:aeaa5fd7bb5a6aaa5720e74b8933d6914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaa5fd7bb5a6aaa5720e74b8933d6914"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_TOTAL_SIZE</b>&#160;&#160;&#160;2</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8942ffb96a9806bad36ef97d7e4f7002"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002">btr_latch_mode</a> { <br/>
&#160;&#160;<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a851af4ea6177309bedbe8f143726ccd8">BTR_SEARCH_LEAF</a> =  RW_S_LATCH, 
<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a47d0ffb5f1bd7b913c3f98df60b9d793">BTR_MODIFY_LEAF</a> =  RW_X_LATCH, 
<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a79778e0de38ce6f6fd5f52fa8f17e108">BTR_NO_LATCHES</a> =  RW_NO_LATCH, 
<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a16200f39165164daf6003bd8c081e61f">BTR_MODIFY_TREE</a> =  33, 
<br/>
&#160;&#160;<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a0c6b78ce4b3f3ff9e86bbe769841aa6b">BTR_CONT_MODIFY_TREE</a> =  34, 
<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002a62dd636a279e6e83c7c1361e0fc3faf4">BTR_SEARCH_PREV</a> =  35, 
<a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002aae7c44e6a014139ef9fb614f17f2d967">BTR_MODIFY_PREV</a> =  36
<br/>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a28ab3a3bea755ed58d9606d79bf73f4a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a28ab3a3bea755ed58d9606d79bf73f4a">btr_corruption_report</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index) UNIV_COLD)</td></tr>
<tr class="memitem:ad1aab6c538c58e220020475b8799dd54"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad1aab6c538c58e220020475b8799dd54">btr_root_get</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a71ef01503db84773408bc2a06168ce91"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a71ef01503db84773408bc2a06168ce91">btr_root_adjust_on_import</a> (const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index))</td></tr>
<tr class="memitem:a05646041b61fb7f7549a7e3f7484df80"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a05646041b61fb7f7549a7e3f7484df80">btr_height_get</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ad40d19bbb882267c80f3017a4daaa3b9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad40d19bbb882267c80f3017a4daaa3b9">btr_block_get_func</a> (ulint space, ulint zip_size, ulint page_no, ulint mode, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a639cadf79734e9d23fac841cf67e3166"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE index_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a639cadf79734e9d23fac841cf67e3166">btr_page_get_index_id</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page))</td></tr>
<tr class="memitem:a47b9ed6904b1aa18fe01fb6fc49a5196"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a47b9ed6904b1aa18fe01fb6fc49a5196">btr_page_get_level_low</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page))</td></tr>
<tr class="memitem:a92bdeb0ca8b44447384d5fcffd7bf0c7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a92bdeb0ca8b44447384d5fcffd7bf0c7">btr_page_get_next</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a381599379edbdc907be8babc932f6d04"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a381599379edbdc907be8babc932f6d04">btr_page_get_prev</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ab1f992f8e471f5f092f9b502c390ac89"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ab1f992f8e471f5f092f9b502c390ac89">btr_get_prev_user_rec</a> (rec_t *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:aae1eb3ac6987d6c4bd935e84d9bd3899"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aae1eb3ac6987d6c4bd935e84d9bd3899">btr_get_next_user_rec</a> (rec_t *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:add959c5fe30c173be65bcf4592257084"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#add959c5fe30c173be65bcf4592257084">btr_leaf_page_release</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint latch_mode, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a5f5a21111550965de690b7f1e456fb6b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a5f5a21111550965de690b7f1e456fb6b">btr_node_ptr_get_child_page_no</a> (const rec_t *rec, const ulint *offsets))</td></tr>
<tr class="memitem:abbf98c4c81cd54f7bea297c6d758f163"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#abbf98c4c81cd54f7bea297c6d758f163">btr_create</a> (ulint type, ulint space, ulint zip_size, index_id_t index_id, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a4e4c8428fac9c89af405a42eb209df6c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a4e4c8428fac9c89af405a42eb209df6c">btr_free_but_not_root</a> (ulint space, ulint zip_size, ulint root_page_no)</td></tr>
<tr class="memitem:a20be1f3aa6ab46229f08bc57d7186990"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a20be1f3aa6ab46229f08bc57d7186990">btr_free_root</a> (ulint space, ulint zip_size, ulint root_page_no, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:aa604e3817e2227ac4ea2d797ffdb9a8a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#aa604e3817e2227ac4ea2d797ffdb9a8a">btr_root_raise_and_insert</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint n_ext, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a6989aa2f669614ead47faa78ee140748"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6989aa2f669614ead47faa78ee140748">btr_page_reorganize_low</a> (bool recovery, ulint z_level, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ae2aabfdd362f5741219ec9951c5c7eb4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ae2aabfdd362f5741219ec9951c5c7eb4">btr_page_reorganize</a> (<a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:af9cc2d106b4910d8a2b9672691e3a9d3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af9cc2d106b4910d8a2b9672691e3a9d3">btr_page_get_split_rec_to_left</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, rec_t **split_rec))</td></tr>
<tr class="memitem:a886685b21c429e68b361160a2b0c23ee"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a886685b21c429e68b361160a2b0c23ee">btr_page_get_split_rec_to_right</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, rec_t **split_rec))</td></tr>
<tr class="memitem:af83b6531b650de20d4a178a6f6075827"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#af83b6531b650de20d4a178a6f6075827">btr_page_split_and_insert</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **heap, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint n_ext, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a3a124d637dd1a9d7ba341cde9e7e9af0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a3a124d637dd1a9d7ba341cde9e7e9af0">btr_insert_on_non_leaf_level_func</a> (ulint flags, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint level, <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a438d3c39451b41968b57f7270b828743"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a438d3c39451b41968b57f7270b828743">btr_set_min_rec_mark</a> (rec_t *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a1e60a22abdf11fff882d2d119dc42ab6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a1e60a22abdf11fff882d2d119dc42ab6">btr_node_ptr_delete</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:abe2c14406b91d3d1161d6f739beaa62c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#abe2c14406b91d3d1161d6f739beaa62c">btr_check_node_ptr</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a77e5cf56e09494faecf72e9f51e4d65c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a77e5cf56e09494faecf72e9f51e4d65c">btr_compress</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a99035d18fbf094a442a78749b1e3bdeb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a99035d18fbf094a442a78749b1e3bdeb">btr_discard_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a831a556c36344bd516020b96604c447c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a831a556c36344bd516020b96604c447c">btr_parse_set_min_rec_mark</a> (byte *ptr, byte *end_ptr, ulint comp, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a3408aa71c70e485d6f88362c72cfa71c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a3408aa71c70e485d6f88362c72cfa71c">btr_parse_page_reorganize</a> (byte *ptr, byte *end_ptr, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, bool compressed, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:ad06c34ac21e21676cc1b7ce06f86cc2d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ad06c34ac21e21676cc1b7ce06f86cc2d">btr_get_size</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint flag, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a17ca1a052d4c24a84a52a7e03092809d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a17ca1a052d4c24a84a52a7e03092809d">btr_page_alloc</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint hint_page_no, byte file_direction, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structmtr__t.html">mtr_t</a> *init_mtr))</td></tr>
<tr class="memitem:a6896d59562139ef47c1f3e6a043e4149"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6896d59562139ef47c1f3e6a043e4149">btr_page_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ab7d67677f5e88a031f69d0cbb79b35ce"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ab7d67677f5e88a031f69d0cbb79b35ce">btr_page_free_low</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint level, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ab7423ffb0caedb83170553890aa3b148"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#ab7423ffb0caedb83170553890aa3b148">btr_index_rec_validate</a> (const rec_t *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> dump_on_error))</td></tr>
<tr class="memitem:a6b2f5758b8fa81304438a8e86e1a75cc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0btr_8h.html#a6b2f5758b8fa81304438a8e86e1a75cc">btr_validate_index</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8a31286e6ebf5b6779daa64b811d284d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a31286e6ebf5b6779daa64b811d284d"></a>
UNIV_INTERN byte&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The B-tree</p>
<p>Created 6/2/1994 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="aece5c042925d9f0034aa994a56e2cbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_ALREADY_S_LATCHED&#160;&#160;&#160;16384</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">In the case of BTR_SEARCH_LEAF or BTR_MODIFY_LEAF, the caller is
</pre><p> already holding an S latch on the index tree </p>

</div>
</div>
<a class="anchor" id="a2e7b9b7db7f01f12accffb27b543d03d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_assert_not_corrupted</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((<a class="code" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>) !!<a class="code" href="page0page_8h.html#a84498b8178988dbaccd7a9020ba1f590">page_is_comp</a>(<a class="code" href="buf0buf_8h.html#a7d369eb98363c43512a7f74c024a6381">buf_block_get_frame</a>(<a class="code" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))  \</div>
<div class="line">            != <a class="code" href="dict0dict_8h.html#a77a90df5650e66697ee3762a9287092f">dict_table_is_comp</a>((index)-&gt;table)) {            \</div>
<div class="line">                btr_corruption_report(<a class="code" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, index);            \</div>
<div class="line">                ut_error;                                       \</div>
<div class="line">        }</div>
</div><!-- fragment --><pre class="fragment">Assert that a B-tree page is not corrupted.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>buffer block containing a B-tree page </td></tr>
    <tr><td class="paramname">index</td><td>the B-tree index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6569d289073c2673e15384cc1d6a88fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_block_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">zip_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="btr0btr_8h.html#ad40d19bbb882267c80f3017a4daaa3b9">btr_block_get_func</a>(space,zip_size,page_no,mode,         \</div>
<div class="line">                           __FILE__,__LINE__,index,mtr)</div>
</div><!-- fragment --><pre class="fragment">Gets a buffer page and declares its latching order level.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>tablespace identifier </td></tr>
    <tr><td class="paramname">zip_size</td><td>compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>page number </td></tr>
    <tr><td class="paramname">mode</td><td>latch mode </td></tr>
    <tr><td class="paramname">index</td><td>index tree, may be NULL if not the insert buffer tree </td></tr>
    <tr><td class="paramname">mtr</td><td>mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the block descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="a572eaf29657a028929c5a9581de20e70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_DELETE&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to purge the record at the searched position using the insert/delete
</pre><p> buffer when the record is not in the buffer pool. </p>

</div>
</div>
<a class="anchor" id="a450f46fe2b1bc6a9f8dc48aec50c79f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_DELETE_MARK&#160;&#160;&#160;4096</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to delete mark the record at the searched position using the
</pre><p> insert/delete buffer when the record is not in the buffer pool. </p>

</div>
</div>
<a class="anchor" id="a35f3d4c758c0e30f9bd431bd2fbb6bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_ESTIMATE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This flag ORed to btr_latch_mode says that we do the search in query
</pre><p> optimization </p>

</div>
</div>
<a class="anchor" id="a4d60c590bdff77da23ac065d8ccf8d80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_IGNORE_SEC_UNIQUE&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This flag ORed to BTR_INSERT says that we can ignore possible
</pre><p> UNIQUE definition on secondary indexes when we decide if we can use the insert buffer to speed up inserts </p>

</div>
</div>
<a class="anchor" id="a40347c97c1fb5f99ddcddf9e668582ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_INSERT&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If this is ORed to btr_latch_mode, it means that the search tuple
</pre><p> will be inserted to the index, at the searched position. When the record is not in the buffer pool, try to use the insert buffer. </p>

</div>
</div>
<a class="anchor" id="aa60b568a3b8345949e70acea4130d767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_LATCH_MODE_WITHOUT_FLAGS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">latch_mode</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((latch_mode) &amp; ~(<a class="code" href="btr0btr_8h.html#a40347c97c1fb5f99ddcddf9e668582ed">BTR_INSERT</a>                    \</div>
<div class="line">                          | <a class="code" href="btr0btr_8h.html#a450f46fe2b1bc6a9f8dc48aec50c79f8">BTR_DELETE_MARK</a>             \</div>
<div class="line">                          | <a class="code" href="btr0btr_8h.html#a572eaf29657a028929c5a9581de20e70">BTR_DELETE</a>                  \</div>
<div class="line">                          | <a class="code" href="btr0btr_8h.html#a35f3d4c758c0e30f9bd431bd2fbb6bde">BTR_ESTIMATE</a>                \</div>
<div class="line">                          | <a class="code" href="btr0btr_8h.html#a4d60c590bdff77da23ac065d8ccf8d80">BTR_IGNORE_SEC_UNIQUE</a>       \</div>
<div class="line">                          | <a class="code" href="btr0btr_8h.html#aece5c042925d9f0034aa994a56e2cbfb">BTR_ALREADY_S_LATCHED</a>))</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a673d044d0cec2c50072b3c14df981105"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_MAX_LEVELS&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum depth of a B-tree in InnoDB. </p>
<p>Note that this isn't a maximum as such; none of the tree operations avoid producing trees bigger than this. It is instead a "max depth
that other code must work with", useful for e.g. fixed-size arrays that must store some information about each level in a tree. In other words: if a B-tree with bigger depth than this is encountered, it is not acceptable for it to lead to mysterious memory corruption, but it is acceptable for the program to die with a clear assert failure. </p>

</div>
</div>
<a class="anchor" id="a5378895a36c860165f55bbbe8f22c32a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_page_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">zip_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mode, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#a95db363e6bf7655c69a903397199b780">buf_block_get_frame</a>(<a class="el" href="btr0btr_8h.html#a6569d289073c2673e15384cc1d6a88fc">btr_block_get</a>(space,zip_size,page_no,mode,idx,mtr))</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets a buffer page and declares its latching order level.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>tablespace identifier </td></tr>
    <tr><td class="paramname">zip_size</td><td>compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>page number </td></tr>
    <tr><td class="paramname">mode</td><td>latch mode </td></tr>
    <tr><td class="paramname">idx</td><td>index tree, may be NULL if not the insert buffer tree </td></tr>
    <tr><td class="paramname">mtr</td><td>mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uncompressed page frame </dd></dl>

</div>
</div>
<a class="anchor" id="a478a4bd54ccaf1b7bcff648f788e16fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_PAGE_MAX_REC_SIZE&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> / 2 - 200)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Maximum record size which can be stored on a page, without using the
</pre><p> special big record storage structure </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0btr_8h.html#a8942ffb96a9806bad36ef97d7e4f7002">btr_latch_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Latching modes for <a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a851af4ea6177309bedbe8f143726ccd8"></a>BTR_SEARCH_LEAF</em>&nbsp;</td><td>
<p>Search a record on a leaf page and S-latch it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a47d0ffb5f1bd7b913c3f98df60b9d793"></a>BTR_MODIFY_LEAF</em>&nbsp;</td><td>
<p>(Prepare to) modify a record on a leaf page and X-latch it. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a79778e0de38ce6f6fd5f52fa8f17e108"></a>BTR_NO_LATCHES</em>&nbsp;</td><td>
<p>Obtain no latches. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a16200f39165164daf6003bd8c081e61f"></a>BTR_MODIFY_TREE</em>&nbsp;</td><td>
<p>Start modifying the entire B-tree. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a0c6b78ce4b3f3ff9e86bbe769841aa6b"></a>BTR_CONT_MODIFY_TREE</em>&nbsp;</td><td>
<p>Continue modifying the entire B-tree. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002a62dd636a279e6e83c7c1361e0fc3faf4"></a>BTR_SEARCH_PREV</em>&nbsp;</td><td>
<p>Search the previous record. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8942ffb96a9806bad36ef97d7e4f7002aae7c44e6a014139ef9fb614f17f2d967"></a>BTR_MODIFY_PREV</em>&nbsp;</td><td>
<p>Modify the previous record. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ad40d19bbb882267c80f3017a4daaa3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_block_get_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a buffer page and declares its latching order level. in/out: mini-transaction</p>
<p>Gets a buffer page and declares its latching order level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">mode</td><td>in: latch mode </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree, may be NULL if it is not an insert buffer tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe2c14406b91d3d1161d6f739beaa62c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_check_node_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the node pointer to a page is appropriate. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77e5cf56e09494faecf72e9f51e4d65c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to merge the page first to the left immediate brother if such a brother exists, and the node pointers to the current page and to the brother reside on the same page. If the left brother does not satisfy these conditions, looks at the right brother. If the page is the only one on that level lifts the records of the page to the father page, thus reducing the tree height. It is assumed that mtr holds an x-latch on the tree and on the page. If cursor is on the leaf level, mtr must also hold x-latches to the brothers, if they exist. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to merge or lift; the page must not be empty: when deleting records, use <a class="el" href="btr0btr_8h.html#a99035d18fbf094a442a78749b1e3bdeb">btr_discard_page()</a> if the page would become empty </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28ab3a3bea755ed58d9606d79bf73f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_corruption_report </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report that an index page is corrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: corrupted block </td></tr>
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbf98c4c81cd54f7bea297c6d758f163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">index_id_t&#160;</td>
          <td class="paramname"><em>index_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the root node for a new index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>page number of the created root, FIL_NULL if did not succeed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: type of the index </td></tr>
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">index_id</td><td>in: index id </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99035d18fbf094a442a78749b1e3bdeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_discard_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Discards a page from a B-tree. This is used to remove the last record from a B-tree page: the whole page must be removed at the same time. This cannot be used for the root page, which is allowed to be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the page to discard: not on the root page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e4c8428fac9c89af405a42eb209df6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_but_not_root </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a B-tree except the root page, which MUST be freed after this by calling btr_free_root. in: root page number </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20be1f3aa6ab46229f08bc57d7186990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_root </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>root_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the B-tree root page. Other tree MUST already have been freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space where created </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">root_page_no</td><td>in: root page number </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae1eb3ac6987d6c4bd935e84d9bd3899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_get_next_user_rec </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets pointer to the next user record in the tree. It is assumed that the caller has appropriate latches on the page and its neighbor. </p>
<dl class="section return"><dt>Returns</dt><dd>next user record, NULL if there is none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record on leaf level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding a latch on the page, and if needed, also to the next page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1f992f8e471f5f092f9b502c390ac89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_get_prev_user_rec </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets pointer to the previous user record in the tree. It is assumed that the caller has appropriate latches on the page and its neighbor. </p>
<dl class="section return"><dt>Returns</dt><dd>previous user record, NULL if there is none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record on leaf level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr holding a latch on the page, and if needed, also to the previous page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad06c34ac21e21676cc1b7ce06f86cc2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of pages in a B-tree. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pages, or ULINT_UNDEFINED if the index is unavailable </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">flag</td><td>in: BTR_N_LEAF_PAGES or BTR_TOTAL_SIZE </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction where index is s-latched </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05646041b61fb7f7549a7e3f7484df80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_height_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the height of the B-tree (the level of the root, when the leaf level is assumed to be 0). The caller must hold an S or X latch on the index. </p>
<dl class="section return"><dt>Returns</dt><dd>tree height (level of the root) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7423ffb0caedb83170553890aa3b148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_index_rec_validate </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>dump_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the size and number of fields in a record based on the definition of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">dump_on_error</td><td>in: TRUE if the function should print hex dump of record and page on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a124d637dd1a9d7ba341cde9e7e9af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_insert_on_non_leaf_level_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a data tuple to a tree on a non-leaf level. It is assumed that mtr holds an x-latch on the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: level, must be &gt; 0 </td></tr>
    <tr><td class="paramname">tuple</td><td>in: the record to be inserted </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add959c5fe30c173be65bcf4592257084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_leaf_page_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the latch on a leaf page and bufferunfixes it.</p>
<p>Releases the latches on a leaf page and bufferunfixes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF or BTR_MODIFY_LEAF </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e60a22abdf11fff882d2d119dc42ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_node_ptr_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes on the upper level the node pointer to a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: page whose node pointer is deleted </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f5a21111550965de690b7f1e456fb6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint btr_node_ptr_get_child_page_no </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the child node file address in a node pointer. NOTE: the offsets array must contain all offsets for the record since we read the last field according to offsets and assume that it contains the child page number. In other words offsets must have been retrieved with rec_get_offsets(n_fields=ULINT_UNDEFINED). </p>
<dl class="section return"><dt>Returns</dt><dd>child node address </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: node pointer record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17ca1a052d4c24a84a52a7e03092809d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_page_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hint_page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>file_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>init_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new file page to be used in an index tree. NOTE: we assume that the caller has made the reservation for free extents! </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if no page could be allocated </td></tr>
    <tr><td class="paramname">block,rw_lock_x_lock_count(&amp;block-&gt;lock)</td><td>== 1 if allocation succeeded (init_mtr == mtr, or the page was not previously freed in mtr) </td></tr>
    <tr><td class="paramname">block</td><td>(not allocated or initialized) otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">hint_page_no</td><td>in: hint of a good page </td></tr>
    <tr><td class="paramname">file_direction</td><td>in: direction where a possible page split is made </td></tr>
    <tr><td class="paramname">level</td><td>in: level where the page is placed in the tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction for the allocation </td></tr>
    <tr><td class="paramname">init_mtr</td><td>in/out: mini-transaction for x-latching and initializing the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6896d59562139ef47c1f3e6a043e4149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_page_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a file page used in an index tree. NOTE: cannot free field external storage pages because the page must contain info on its level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7d67677f5e88a031f69d0cbb79b35ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_page_free_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a file page used in an index tree. Can be used also to BLOB external storage pages, because the page level 0 can be given as an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">block</td><td>in: block to be freed, x-latched </td></tr>
    <tr><td class="paramname">level</td><td>in: page level </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a639cadf79734e9d23fac841cf67e3166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE index_id_t btr_page_get_index_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the index id field of a page. </p>
<dl class="section return"><dt>Returns</dt><dd>index id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47b9ed6904b1aa18fe01fb6fc49a5196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint btr_page_get_level_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the node level field in an index page. </p>
<dl class="section return"><dt>Returns</dt><dd>level, leaf level == 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92bdeb0ca8b44447384d5fcffd7bf0c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint btr_page_get_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the next index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>next page number</dd></dl>
<p>Gets the next index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>next page number</dd></dl>
<p>&lt; in: mini-transaction handle </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a381599379edbdc907be8babc932f6d04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint btr_page_get_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the previous index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>prev page number</dd></dl>
<p>Gets the previous index page number. </p>
<dl class="section return"><dt>Returns</dt><dd>prev page number</dd></dl>
<p>&lt; in: mini-transaction handle </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9cc2d106b4910d8a2b9672691e3a9d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_page_get_split_rec_to_left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decides if the page should be split at the convergence point of inserts converging to left. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a886685b21c429e68b361160a2b0c23ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_page_get_split_rec_to_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>split_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decides if the page should be split at the convergence point of inserts converging to right. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if split recommended </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert </td></tr>
    <tr><td class="paramname">split_rec</td><td>out: if split recommended, the first record on upper half page, or NULL if tuple should be first </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2aabfdd362f5741219ec9951c5c7eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_page_reorganize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganizes an index page.</p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8h.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a9f56cd3b57c764238eed7c15881b80d9">mtr_commit()</a>. On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6989aa2f669614ead47faa78ee140748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_page_reorganize_low </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>z_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reorganizes an index page.</p>
<p>IMPORTANT: On success, the caller will have to update IBUF_BITMAP_FREE if this is a compressed leaf page in a secondary index. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8h.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before <a class="el" href="mtr0mtr_8h.html#a9f56cd3b57c764238eed7c15881b80d9">mtr_commit()</a>. On uncompressed pages, IBUF_BITMAP_FREE is unaffected by reorganization.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation was successful </td></tr>
    <tr><td class="paramname">false</td><td>if it is a compressed page, and recompression failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recovery</td><td>in: true if called in recovery: locks should not be updated, i.e., there cannot exist locks on the page, and a hash index should not be dropped: it cannot exist </td></tr>
    <tr><td class="paramname">z_level</td><td>in: compression level to be used if dealing with compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index tree of the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af83b6531b650de20d4a178a6f6075827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_page_split_and_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits an index page to halves and inserts the tuple. It is assumed that mtr holds an x-latch to the index tree. NOTE: the tree x-latch is released within this function! NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space (2 pages) must be guaranteed to be available before this function is called.</p>
<dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3408aa71c70e485d6f88362c72cfa71c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_parse_page_reorganize </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of reorganizing a page. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">compressed</td><td>in: true if compressed page </td></tr>
    <tr><td class="paramname">block</td><td>in: page to be reorganized, or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a831a556c36344bd516020b96604c447c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_parse_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for setting an index record as the predefined minimum record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">comp</td><td>in: nonzero=compact page format </td></tr>
    <tr><td class="paramname">page</td><td>in: page or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71ef01503db84773408bc2a06168ce91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_root_adjust_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks and adjusts the root node of a tree during IMPORT TABLESPACE. </p>
<dl class="section return"><dt>Returns</dt><dd>error code, or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1aab6c538c58e220020475b8799dd54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_root_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the root node of a tree and x-latches it. </p>
<dl class="section return"><dt>Returns</dt><dd>root page, x-latched </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index tree </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa604e3817e2227ac4ea2d797ffdb9a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN rec_t* btr_root_raise_and_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes tree one level higher by splitting the root, and inserts the tuple. It is assumed that mtr contains an x-latch on the tree. NOTE that the operation of this function must always succeed, we cannot reverse it: therefore enough free disk space must be guaranteed to be available before this function is called. </p>
<dl class="section return"><dt>Returns</dt><dd>inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor at which to insert: must be on the root page; when the function returns, the cursor is positioned on the predecessor of the inserted record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on inserted record </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">tuple</td><td>in: tuple to insert </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a438d3c39451b41968b57f7270b828743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_set_min_rec_mark </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a record as the predefined minimum record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b2f5758b8fa81304438a8e86e1a75cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_validate_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the consistency of an index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction or 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:19 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
