<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/ibuf0ibuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ibuf0ibuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mtr0mtr_8h_source.html">mtr0mtr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ibuf0types_8h_source.html">ibuf0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ibuf0ibuf_8ic.html">ibuf0ibuf.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ibuf0ibuf.h:</div>
<div class="dyncontent">
<div class="center"><img src="ibuf0ibuf_8h__incl.png" border="0" usemap="#include_2ibuf0ibuf_8h" alt=""/></div>
<map name="include_2ibuf0ibuf_8h" id="include_2ibuf0ibuf_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="1902,779,1955,807"/><area shape="rect" id="node28" href="mtr0mtr_8h.html" title="mtr0mtr.h" alt="" coords="2340,393,2426,421"/><area shape="rect" id="node76" href="dict0mem_8h.html" title="dict0mem.h" alt="" coords="754,315,852,343"/><area shape="rect" id="node137" href="fsp0fsp_8h.html" title="fsp0fsp.h" alt="" coords="2507,238,2587,266"/><area shape="rect" id="node152" href="ibuf0types_8h.html" title="ibuf0types.h" alt="" coords="2584,83,2683,111"/><area shape="rect" id="node154" href="ibuf0ibuf_8ic.html" title="ibuf0ibuf.ic" alt="" coords="2472,83,2560,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="1890,857,1967,885"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="1380,857,1447,885"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="1671,934,1746,962"/><area shape="rect" id="node31" href="mem0mem_8h.html" title="mem0mem.h" alt="" coords="1383,547,1492,575"/><area shape="rect" id="node37" href="ut0byte_8h.html" title="ut0byte.h" alt="" coords="1786,702,1868,730"/><area shape="rect" id="node47" href="dyn0dyn_8h.html" title="dyn0dyn.h" alt="" coords="2016,470,2104,498"/><area shape="rect" id="node52" href="buf0types_8h.html" title="buf0types.h" alt="" coords="2731,470,2827,498"/><area shape="rect" id="node54" href="sync0rw_8h.html" title="sync0rw.h" alt="" coords="2067,547,2150,575"/><area shape="rect" id="node59" href="mtr0types_8h.html" title="mtr0types.h" alt="" coords="2456,547,2555,575"/><area shape="rect" id="node61" href="page0types_8h.html" title="page0types.h" alt="" coords="2547,470,2656,498"/><area shape="rect" id="node67" href="log0log_8h.html" title="log0log.h" alt="" coords="2342,470,2422,498"/><area shape="rect" id="node73" href="mtr0mtr_8ic.html" title="mtr0mtr.ic" alt="" coords="2230,470,2318,498"/><area shape="rect" id="node34" href="ut0mem_8h.html" title="ut0mem.h" alt="" coords="976,625,1064,653"/><area shape="rect" id="node40" href="ut0rnd_8h.html" title="ut0rnd.h" alt="" coords="1326,625,1400,653"/><area shape="rect" id="node44" href="ut0lst_8h.html" title="ut0lst.h" alt="" coords="1970,625,2039,653"/><area shape="rect" id="node64" href="dict0types_8h.html" title="dict0types.h" alt="" coords="966,547,1064,575"/><area shape="rect" id="node80" href="data0type_8h.html" title="data0type.h" alt="" coords="311,470,410,498"/><area shape="rect" id="node84" href="row0types_8h.html" title="row0types.h" alt="" coords="763,470,862,498"/><area shape="rect" id="node86" href="rem0types_8h.html" title="rem0types.h" alt="" coords="1318,470,1419,498"/><area shape="rect" id="node88" href="btr0types_8h.html" title="btr0types.h" alt="" coords="1746,393,1839,421"/><area shape="rect" id="node94" href="lock0types_8h.html" title="lock0types.h" alt="" coords="44,393,146,421"/><area shape="rect" id="node96" href="que0types_8h.html" title="que0types.h" alt="" coords="638,470,739,498"/><area shape="rect" id="node104" href="hash0hash_8h.html" title="hash0hash.h" alt="" coords="1139,470,1243,498"/><area shape="rect" id="node109" href="trx0types_8h.html" title="trx0types.h" alt="" coords="1494,470,1587,498"/><area shape="rect" id="node112" href="fts0fts_8h.html" title="fts0fts.h" alt="" coords="896,393,971,421"/><area shape="rect" id="node123" href="os0once_8h.html" title="os0once.h" alt="" coords="323,702,411,730"/><area shape="rect" id="node133" href="dict0mem_8ic.html" title="dict0mem.ic" alt="" coords="170,393,271,421"/><area shape="rect" id="node141" href="fut0lst_8h.html" title="fut0lst.h" alt="" coords="2272,315,2347,343"/><area shape="rect" id="node147" href="fsp0types_8h_source.html" title="fsp0types.h" alt="" coords="2988,702,3084,730"/><area shape="rect" id="node150" href="fsp0fsp_8ic.html" title="fsp0fsp.ic" alt="" coords="2427,315,2510,343"/><area shape="rect" id="node156" href="page0page_8h.html" title="page0page.h" alt="" coords="2699,161,2806,189"/><area shape="rect" id="node162" href="page0zip_8h.html" title="page0zip.h" alt="" coords="2107,393,2198,421"/><area shape="rect" id="node170" href="buf0lru_8h.html" title="buf0lru.h" alt="" coords="2818,393,2895,421"/></map>
</div>
</div>
<p><a href="ibuf0ibuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a091d43d6f84f6018b0f1b47ca0455e6b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a091d43d6f84f6018b0f1b47ca0455e6b">CHANGE_BUFFER_DEFAULT_SIZE</a>&#160;&#160;&#160;(25)</td></tr>
<tr class="memitem:a4c5a3c533e35abdae6ab73f3661bf2c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4c5a3c533e35abdae6ab73f3661bf2c9">ibuf_page</a>(space, zip_size, page_no, mtr)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8h.html#ac89b57c4c9fc6dc4a45f3942f971f153">ibuf_page_low</a>(space, zip_size, page_no, TRUE, __FILE__, __LINE__, mtr)</td></tr>
<tr class="memitem:a483a1eff3eb521dc9033560960200d98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a483a1eff3eb521dc9033560960200d98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_HEADER_PAGE_NO</b>&#160;&#160;&#160;FSP_IBUF_HEADER_PAGE_NO</td></tr>
<tr class="memitem:aa8f5285b3806532f70b99ead8bc59b80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f5285b3806532f70b99ead8bc59b80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_TREE_ROOT_PAGE_NO</b>&#160;&#160;&#160;FSP_IBUF_TREE_ROOT_PAGE_NO</td></tr>
<tr class="memitem:a89dd04e35feeda223aae6b90d30aac6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89dd04e35feeda223aae6b90d30aac6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_HEADER</b>&#160;&#160;&#160;PAGE_DATA</td></tr>
<tr class="memitem:a3f5bce87ad79cc64bf9c669854fd3f8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f5bce87ad79cc64bf9c669854fd3f8d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_TREE_SEG_HEADER</b>&#160;&#160;&#160;0	/* fseg header for <a class="el" href="ibuf0ibuf_8h.html#acc138f660c81dccfb4179744e640a50d">ibuf</a> tree */</td></tr>
<tr class="memitem:ab5aaeb6f2184c3557450c6a11474c3b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5aaeb6f2184c3557450c6a11474c3b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IBUF_SPACE_ID</b>&#160;&#160;&#160;0</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8116a402f0f6229af7671129bfab686"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>ibuf_op_t</b> { <b>IBUF_OP_INSERT</b> =  0, 
<b>IBUF_OP_DELETE_MARK</b> =  1, 
<b>IBUF_OP_DELETE</b> =  2, 
<b>IBUF_OP_COUNT</b> =  3
 }</td></tr>
<tr class="memitem:aaee299ba777e430d36fe90fd2ecb54e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a> { <br/>
&#160;&#160;<b>IBUF_USE_NONE</b> =  0, 
<b>IBUF_USE_INSERT</b>, 
<b>IBUF_USE_DELETE_MARK</b>, 
<b>IBUF_USE_INSERT_DELETE_MARK</b>, 
<br/>
&#160;&#160;<b>IBUF_USE_DELETE</b>, 
<b>IBUF_USE_ALL</b>, 
<b>IBUF_USE_COUNT</b>
<br/>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f026a0cad6ac211baac812ed0ad6924"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a0f026a0cad6ac211baac812ed0ad6924">ibuf_init_at_db_start</a> (void)</td></tr>
<tr class="memitem:aebf12932ee35e8653752790ee3ae5141"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aebf12932ee35e8653752790ee3ae5141">ibuf_max_size_update</a> (ulint new_val)</td></tr>
<tr class="memitem:aef509cb3f972ec513b2e072cebc36cd0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aef509cb3f972ec513b2e072cebc36cd0">ibuf_update_max_tablespace_id</a> (void)</td></tr>
<tr class="memitem:aa8566c6678cd762fd57c2282eaa079d5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#aa8566c6678cd762fd57c2282eaa079d5">ibuf_mtr_start</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a4d65b77e12be6c0d48e4b78a02fbfe42"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4d65b77e12be6c0d48e4b78a02fbfe42">ibuf_mtr_commit</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ad47a4b2eeba24112529f97c8454c5a7c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ad47a4b2eeba24112529f97c8454c5a7c">ibuf_bitmap_page_init</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:ac0fa1ac9abb6d51ec99ac39e3b9378d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a7c9b8d6c6a893191b914c6193faadcc0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a7c9b8d6c6a893191b914c6193faadcc0">ibuf_update_free_bits_if_full</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint max_ins_size, ulint increase)</td></tr>
<tr class="memitem:a2e6b74d1c85f5de973847a75a11192a8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a2e6b74d1c85f5de973847a75a11192a8">ibuf_update_free_bits_low</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint max_ins_size, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a1a420088ad2008b7d667fa430c044273"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1a420088ad2008b7d667fa430c044273">ibuf_update_free_bits_zip</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a04bdbfd04d4c22d602d67d153b4424f3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a04bdbfd04d4c22d602d67d153b4424f3">ibuf_update_free_bits_for_two_pages_low</a> (ulint zip_size, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block1, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block2, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a0369066ee09b5aff6c0f2670ce753ef5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a0369066ee09b5aff6c0f2670ce753ef5">ibuf_should_try</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint ignore_sec_unique)</td></tr>
<tr class="memitem:a32a114a0c7852593314d9736c9807036"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a32a114a0c7852593314d9736c9807036">ibuf_inside</a> (const <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a264f49b69a06c6b96a704bbbf79f4bac"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a264f49b69a06c6b96a704bbbf79f4bac">ibuf_bitmap_page</a> (ulint zip_size, ulint page_no)</td></tr>
<tr class="memitem:ac89b57c4c9fc6dc4a45f3942f971f153"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ac89b57c4c9fc6dc4a45f3942f971f153">ibuf_page_low</a> (ulint space, ulint zip_size, ulint page_no, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> x_latch, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:af7477357b4685fcf1cf4ba5c45cdc33f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#af7477357b4685fcf1cf4ba5c45cdc33f">ibuf_free_excess_pages</a> (void)</td></tr>
<tr class="memitem:adab374ff907a9fca3935d9b8af22fc29"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#adab374ff907a9fca3935d9b8af22fc29">ibuf_insert</a> (ibuf_op_t op, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint space, ulint zip_size, ulint page_no, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:a1d3820e76d62e8fc272bac12e8e79bf0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d3820e76d62e8fc272bac12e8e79bf0">ibuf_merge_or_delete_for_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint space, ulint page_no, ulint zip_size, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> update_ibuf_bitmap)</td></tr>
<tr class="memitem:a1d0e59772dcccb8060cd281dd2b86f7e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d0e59772dcccb8060cd281dd2b86f7e">ibuf_delete_for_discarded_space</a> (ulint space)</td></tr>
<tr class="memitem:a1d5e4864f4d26ccde2f5fbdec64ae74f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a1d5e4864f4d26ccde2f5fbdec64ae74f">ibuf_contract_in_background</a> (table_id_t table_id, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> full)</td></tr>
<tr class="memitem:ab32ce92b83e50309a7d0733f392043a4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ab32ce92b83e50309a7d0733f392043a4">ibuf_parse_bitmap_init</a> (byte *ptr, byte *end_ptr, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a9105388eb09aaf0930146eeb58cd392d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a9105388eb09aaf0930146eeb58cd392d">ibuf_is_empty</a> (void)</td></tr>
<tr class="memitem:a4f1fe433b34b5033dd5aed08e83f3b9f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4f1fe433b34b5033dd5aed08e83f3b9f">ibuf_print</a> (FILE *file)</td></tr>
<tr class="memitem:a4c4ab4c3e4f65b6776d5f0db44dcb6f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a4c4ab4c3e4f65b6776d5f0db44dcb6f9">ibuf_rec_get_counter</a> (const rec_t *rec)</td></tr>
<tr class="memitem:ac51c353e54046cab4436fefa4922b08e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#ac51c353e54046cab4436fefa4922b08e">ibuf_close</a> (void)</td></tr>
<tr class="memitem:a297e7bbf74df6325a02f4973f3f90d35"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#a297e7bbf74df6325a02f4973f3f90d35">ibuf_check_bitmap_on_import</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint space_id))</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adbb87198861959d990f4ff15f902fda9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#adbb87198861959d990f4ff15f902fda9">ibuf_use</a></td></tr>
<tr class="memitem:acc138f660c81dccfb4179744e640a50d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structibuf__t.html">ibuf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8h.html#acc138f660c81dccfb4179744e640a50d">ibuf</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Insert buffer</p>
<p>Created 7/19/1997 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a091d43d6f84f6018b0f1b47ca0455e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHANGE_BUFFER_DEFAULT_SIZE&#160;&#160;&#160;(25)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Default value for maximum on-disk size of change buffer in terms
</pre><p> of percentage of the buffer pool. </p>

</div>
</div>
<a class="anchor" id="a4c5a3c533e35abdae6ab73f3661bf2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_page</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">zip_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8h.html#ac89b57c4c9fc6dc4a45f3942f971f153">ibuf_page_low</a>(space, zip_size, page_no, TRUE, __FILE__, __LINE__, mtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Checks if a page is a level 2 or 3 page in the ibuf hierarchy of
</pre><p> pages. Must not be called when recv_no_ibuf_operations==TRUE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>tablespace identifier </td></tr>
    <tr><td class="paramname">zip_size</td><td>compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>page number </td></tr>
    <tr><td class="paramname">mtr</td><td>mini-transaction or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if level 2 or level 3 page </dd></dl>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aaee299ba777e430d36fe90fd2ecb54e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combinations of operations that can be buffered.  Because the enum
</pre><p> values are used for indexing innobase_change_buffering_values[], they should start at 0 and there should not be any gaps. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a264f49b69a06c6b96a704bbbf79f4bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> ibuf_bitmap_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page address is an ibuf bitmap page (level 3 page) address. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a bitmap page in: page number</dd></dl>
<p>Checks if a page address is an ibuf bitmap page address. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a bitmap page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad47a4b2eeba24112529f97c8454c5a7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_bitmap_page_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an ibuf bitmap page. in: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: bitmap page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a297e7bbf74df6325a02f4973f3f90d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ibuf_check_bitmap_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the insert buffer bitmaps on IMPORT TABLESPACE. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">space_id</td><td>in: tablespace identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac51c353e54046cab4436fefa4922b08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes insert buffer and frees the data structures. </p>

</div>
</div>
<a class="anchor" id="a1d5e4864f4d26ccde2f5fbdec64ae74f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ibuf_contract_in_background </td>
          <td>(</td>
          <td class="paramtype">table_id_t&#160;</td>
          <td class="paramname"><em>table_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contracts insert buffer trees by reading pages to the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty in: TRUE if the caller wants to do a full contract based on PCT_IO(100). If FALSE then the size of contract batch is determined based on the current size of the ibuf tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_id</td><td>in: if merge should be done only for a specific table, for all tables this should be 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d0e59772dcccb8060cd281dd2b86f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_delete_for_discarded_space </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all entries in the insert buffer for a given space id. This is used in DISCARD TABLESPACE and IMPORT TABLESPACE. NOTE: this does not update the page free bitmaps in the space. The space will become CORRUPT when you call this function! in: space id </p>

</div>
</div>
<a class="anchor" id="af7477357b4685fcf1cf4ba5c45cdc33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_free_excess_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees excess pages from the ibuf free list. This function is called when an OS thread calls fsp services to allocate a new file segment, or a new page to a file segment, and the thread did not own the fsp latch before this call. </p>

</div>
</div>
<a class="anchor" id="a0f026a0cad6ac211baac812ed0ad6924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_init_at_db_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the insert buffer data structure at a database startup. </p>

</div>
</div>
<a class="anchor" id="adab374ff907a9fca3935d9b8af22fc29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> ibuf_insert </td>
          <td>(</td>
          <td class="paramtype">ibuf_op_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. Does not do it if the index is clustered or unique. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success in: query thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operation type </td></tr>
    <tr><td class="paramname">entry</td><td>in: index entry to insert </td></tr>
    <tr><td class="paramname">index</td><td>in: index where to insert </td></tr>
    <tr><td class="paramname">space</td><td>in: space id where to insert </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number where to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32a114a0c7852593314d9736c9807036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> ibuf_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the current OS thread is performing an insert buffer routine.</p>
<p>For instance, a read-ahead of non-ibuf pages is forbidden by threads that are executing an insert buffer routine. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if inside an insert buffer routine </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9105388eb09aaf0930146eeb58cd392d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool ibuf_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks if the insert buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if empty </dd></dl>

</div>
</div>
<a class="anchor" id="aebf12932ee35e8653752790ee3ae5141"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_max_size_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the max_size value for ibuf. in: new value in terms of percentage of the buffer pool size </p>

</div>
</div>
<a class="anchor" id="a1d3820e76d62e8fc272bac12e8e79bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_merge_or_delete_for_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>update_ibuf_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When an index page is read from a disk to the buffer pool, this function applies any buffered operations to the page and deletes the entries from the insert buffer. If the page is not read, but created in the buffer pool, this function deletes its buffered entries from the insert buffer; there can exist entries for such a page if the page belonged to an index which subsequently was dropped. in: normally this is set to TRUE, but if we have deleted or are deleting the tablespace, then we naturally do not want to update a non-existent bitmap page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: if page has been read from disk, pointer to the page x-latched, else NULL </td></tr>
    <tr><td class="paramname">space</td><td>in: space id of the index page </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of the index page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d65b77e12be6c0d48e4b78a02fbfe42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_mtr_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits an insert buffer mini-transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8566c6678cd762fd57c2282eaa079d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_mtr_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an insert buffer mini-transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac89b57c4c9fc6dc4a45f3942f971f153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> ibuf_page_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>x_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is a level 2 or 3 page in the ibuf hierarchy of pages. Must not be called when recv_no_ibuf_operations==TRUE. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if level 2 or level 3 page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes, or 0 </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">x_latch</td><td>in: FALSE if relaxed check (avoid latching the bitmap page) </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr which will contain an x-latch to the bitmap page if the page is not one of the fixed address ibuf pages, or NULL, in which case a new transaction is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab32ce92b83e50309a7d0733f392043a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* ibuf_parse_bitmap_init </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of an ibuf bitmap page init. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: mtr or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">block</td><td>in: block or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f1fe433b34b5033dd5aed08e83f3b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of ibuf. in: file where to print </p>

</div>
</div>
<a class="anchor" id="a4c4ab4c3e4f65b6776d5f0db44dcb6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ibuf_rec_get_counter </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: ibuf record </p>

</div>
</div>
<a class="anchor" id="ac0fa1ac9abb6d51ec99ac39e3b9378d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_reset_free_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the free bits of the page in the ibuf bitmap. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to decrement or reset the bits in the bitmap in a mini-transaction that is committed before the mini-transaction that affects the free space. in: index page; free bits are set to 0 if the index is a non-clustered non-unique, and page level is 0 </p>

</div>
</div>
<a class="anchor" id="a0369066ee09b5aff6c0f2670ce753ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> ibuf_should_try </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>ignore_sec_unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A basic partial test if an insert to the insert buffer could be possible and recommended. in: if != 0, we should ignore UNIQUE constraint on a secondary index when we decide</p>
<p>A basic partial test if an insert to the insert buffer could be possible and recommended. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index where to insert </td></tr>
    <tr><td class="paramname">ignore_sec_unique</td><td>in: if != 0, we should ignore UNIQUE constraint on a secondary index when we decide </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04bdbfd04d4c22d602d67d153b4424f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_for_two_pages_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for the two pages to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the pages. in: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes; 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">block1</td><td>in: index page </td></tr>
    <tr><td class="paramname">block2</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c9b8d6c6a893191b914c6193faadcc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_update_free_bits_if_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_ins_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>increase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits of an uncompressed page in the ibuf bitmap if there is not enough free on the page any more. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is unsafe to increment the bits in a separately committed mini-transaction, because in crash recovery, the free bits could momentarily be set too high. It is only safe to use this function for decrementing the free bits. Should more free space become available, we must not update the free bits here, because that would break crash recovery. in: upper limit for the additional space used in the latest operation, if known, or ULINT_UNDEFINED</p>
<p>Updates the free bits of an uncompressed page in the ibuf bitmap if there is not enough free on the page any more. This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is unsafe to increment the bits in a separately committed mini-transaction, because in crash recovery, the free bits could momentarily be set too high. It is only safe to use this function for decrementing the free bits. Should more free space become available, we must not update the free bits here, because that would break crash recovery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which we have added new records; the free bits are updated if the index is non-clustered and non-unique and the page level is 0, and the page becomes fuller </td></tr>
    <tr><td class="paramname">max_ins_size</td><td>in: value of maximum insert size with reorganize before the latest operation performed to the page </td></tr>
    <tr><td class="paramname">increase</td><td>in: upper limit for the additional space used in the latest operation, if known, or ULINT_UNDEFINED </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e6b74d1c85f5de973847a75a11192a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_ins_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for an uncompressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. in/out: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">max_ins_size</td><td>in: value of maximum insert size with reorganize before the latest operation performed to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a420088ad2008b7d667fa430c044273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_free_bits_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the free bits for a compressed page to reflect the present state. Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. in/out: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef509cb3f972ec513b2e072cebc36cd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ibuf_update_max_tablespace_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the biggest tablespace id from the high end of the insert buffer tree and updates the counter in fil_system. </p>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="acc138f660c81dccfb4179744e640a50d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structibuf__t.html">ibuf_t</a>* ibuf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The insert buffer control structure </p>

</div>
</div>
<a class="anchor" id="adbb87198861959d990f4ff15f902fda9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0">ibuf_use_t</a> ibuf_use</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operations that can currently be buffered. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:25 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
