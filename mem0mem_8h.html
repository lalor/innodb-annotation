<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/mem0mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mem0mem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0rnd_8h_source.html">ut0rnd.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem0dbg_8h_source.html">mem0dbg.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mem0mem_8ic.html">mem0mem.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for mem0mem.h:</div>
<div class="dyncontent">
<div class="center"><img src="mem0mem_8h__incl.png" border="0" usemap="#include_2mem0mem_8h" alt=""/></div>
<map name="include_2mem0mem_8h" id="include_2mem0mem_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="mem0mem_8h__dep__incl.png" border="0" usemap="#include_2mem0mem_8hdep" alt=""/></div>
<map name="include_2mem0mem_8hdep" id="include_2mem0mem_8hdep">
</map>
</div>
</div>
<p><a href="mem0mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__block__info__t.html">mem_block_info_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac7fc6050ef7fde046b8aa0af92c2afae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7fc6050ef7fde046b8aa0af92c2afae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_DYNAMIC</b>&#160;&#160;&#160;0	/* the most common type */</td></tr>
<tr class="memitem:ad2623d2577c63e89bd0173f928be08e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2623d2577c63e89bd0173f928be08e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_BUFFER</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:a6621ead8a647eed62fbd8a311a62330c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_BTR_SEARCH</b></td></tr>
<tr class="memitem:a47d3586895796c6473e46aa6a64bd998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47d3586895796c6473e46aa6a64bd998"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_BTR_SEARCH</b>&#160;&#160;&#160;(MEM_HEAP_BTR_SEARCH | MEM_HEAP_BUFFER)</td></tr>
<tr class="memitem:a7c1e03a482e10cf25756bb96b3368bc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c1e03a482e10cf25756bb96b3368bc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_PAGE_HASH</b>&#160;&#160;&#160;(MEM_HEAP_DYNAMIC)</td></tr>
<tr class="memitem:a83e266b884663510a1c569492edfc3a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83e266b884663510a1c569492edfc3a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_RECV_SYS</b>&#160;&#160;&#160;(MEM_HEAP_BUFFER)</td></tr>
<tr class="memitem:a68a390063fcee97542cade99064c3014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68a390063fcee97542cade99064c3014"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_HEAP_FOR_LOCK_HEAP</b>&#160;&#160;&#160;(MEM_HEAP_BUFFER)</td></tr>
<tr class="memitem:a07412b5b33ff3b94be36b581449cbeb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07412b5b33ff3b94be36b581449cbeb7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_START_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="memitem:aff86ded019fa67facacc67b8a615001b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff86ded019fa67facacc67b8a615001b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_STANDARD_SIZE</b>&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> &gt;= 16384 ? 8000 : MEM_MAX_ALLOC_IN_BUF)</td></tr>
<tr class="memitem:a737ff56ffe835fe44b1a133a459141e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a737ff56ffe835fe44b1a133a459141e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_MAX_ALLOC_IN_BUF</b>&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> - 200)</td></tr>
<tr class="memitem:a37b03a5cbf64e5271e6c62a9cc6bb5b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a37b03a5cbf64e5271e6c62a9cc6bb5b5">mem_heap_create</a>(N)</td></tr>
<tr class="memitem:aa3cad9edc7402f0af61a42fbd09343b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#aa3cad9edc7402f0af61a42fbd09343b9">mem_heap_create_typed</a>(N, T)</td></tr>
<tr class="memitem:ab163da885b759ff5ece673bdf89950d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ab163da885b759ff5ece673bdf89950d9">mem_heap_free</a>(heap)</td></tr>
<tr class="memitem:a933476069d9c87d190e4d6a18eeca199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a933476069d9c87d190e4d6a18eeca199">mem_zalloc</a>(N)&#160;&#160;&#160;memset(mem_alloc(N), 0, (N))</td></tr>
<tr class="memitem:accbb534010925c9124d8ec0c855b75b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accbb534010925c9124d8ec0c855b75b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>mem_alloc</b>(N)&#160;&#160;&#160;<a class="el" href="mem0mem_8ic.html#a9270a0ab9de0a0aaf9b26509cb10598a">mem_alloc_func</a>((N), __FILE__, __LINE__, NULL)</td></tr>
<tr class="memitem:a406a62553140ff71eb7bca005631dd33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a406a62553140ff71eb7bca005631dd33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>mem_alloc2</b>(N, S)&#160;&#160;&#160;<a class="el" href="mem0mem_8ic.html#a9270a0ab9de0a0aaf9b26509cb10598a">mem_alloc_func</a>((N), __FILE__, __LINE__, (S))</td></tr>
<tr class="memitem:a4cdeda261ea5f6db299898f33e6bbdbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free</a>(PTR)&#160;&#160;&#160;<a class="el" href="mem0mem_8ic.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a>((PTR), __FILE__, __LINE__)</td></tr>
<tr class="memitem:a339a3734708830e0bee01de7eaf96715"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a339a3734708830e0bee01de7eaf96715"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_MAGIC_N</b>&#160;&#160;&#160;764741555</td></tr>
<tr class="memitem:a708a8efd990e3d65c4446d992cb6ee4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a708a8efd990e3d65c4446d992cb6ee4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_FREED_BLOCK_MAGIC_N</b>&#160;&#160;&#160;547711122</td></tr>
<tr class="memitem:ad6a2ed79ee7aa82b1c09651e1047eda1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MEM_BLOCK_HEADER_SIZE</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5e3855e50a4a7a806a1f012dbb63e0f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e3855e50a4a7a806a1f012dbb63e0f5"></a>
typedef struct <a class="el" href="structmem__block__info__t.html">mem_block_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mem_block_t</b></td></tr>
<tr class="memitem:a29a10a74bdb0acc8a530dd6ec3c8538a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a10a74bdb0acc8a530dd6ec3c8538a"></a>
typedef <a class="el" href="structmem__block__info__t.html">mem_block_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mem_heap_t</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a35202ac8c0599fd2ba745cf7c8660104"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a35202ac8c0599fd2ba745cf7c8660104">mem_init</a> (ulint size)</td></tr>
<tr class="memitem:ac8c1e14f38416a0128af1ddf92f4a08d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ac8c1e14f38416a0128af1ddf92f4a08d">mem_close</a> (void)</td></tr>
<tr class="memitem:a8c712959b55472fb92497b8d76f79862"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8c712959b55472fb92497b8d76f79862">mem_heap_create_func</a> (ulint n, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, ulint type)</td></tr>
<tr class="memitem:a34047c1601b14ffef20989e6da7697c3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a34047c1601b14ffef20989e6da7697c3">mem_heap_free_func</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a8162d816aada62ef8f84c83b6787befa"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8162d816aada62ef8f84c83b6787befa">mem_heap_zalloc</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, ulint n)</td></tr>
<tr class="memitem:a92f7ee9ca3354fdd5bc633f5ae7b9421"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a92f7ee9ca3354fdd5bc633f5ae7b9421">mem_heap_alloc</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, ulint n)</td></tr>
<tr class="memitem:abf86da5f1414a8bb3f80e50321a8e55e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#abf86da5f1414a8bb3f80e50321a8e55e">mem_heap_get_heap_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a8b274fd0d860517ff623eef01a6a099a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8b274fd0d860517ff623eef01a6a099a">mem_heap_free_heap_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, byte *old_top)</td></tr>
<tr class="memitem:a98ae9a39a4d557c68977578bd0db3fa8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a98ae9a39a4d557c68977578bd0db3fa8">mem_heap_empty</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a854d0114bb14a2fc66685af99642c4f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a854d0114bb14a2fc66685af99642c4f2">mem_heap_get_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, ulint n)</td></tr>
<tr class="memitem:a0bbaa90de4133e744d809cfd6c764046"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a0bbaa90de4133e744d809cfd6c764046">mem_heap_free_top</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, ulint n)</td></tr>
<tr class="memitem:a469829136569041fbd26404dd7af7e08"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a469829136569041fbd26404dd7af7e08">mem_heap_get_size</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a9270a0ab9de0a0aaf9b26509cb10598a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a9270a0ab9de0a0aaf9b26509cb10598a">mem_alloc_func</a> (ulint n, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, ulint *size)</td></tr>
<tr class="memitem:a8b8f05469f9f6eec258bbe5e75bc4b1a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a> (void *ptr, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:ad40ee2ae09b8776ea6f7b258d94ee276"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ad40ee2ae09b8776ea6f7b258d94ee276">mem_strdup</a> (const char *str)</td></tr>
<tr class="memitem:a601462ebfa8661c981f405734f77cf22"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a601462ebfa8661c981f405734f77cf22">mem_strdupl</a> (const char *str, ulint len)</td></tr>
<tr class="memitem:a3de3ebcaa704fafbfb878154e0eb8367"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a3de3ebcaa704fafbfb878154e0eb8367">mem_heap_strdup</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const char *str)</td></tr>
<tr class="memitem:a4cb6550c0724daf639e0cef00b7b5b63"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a4cb6550c0724daf639e0cef00b7b5b63">mem_heap_strdupl</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const char *str, ulint len)</td></tr>
<tr class="memitem:a14c7003eedd1e8e7d40eab34c3569658"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a14c7003eedd1e8e7d40eab34c3569658">mem_heap_strcat</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const char *s1, const char *s2)</td></tr>
<tr class="memitem:ada8024cec0a01e9107caaee5c69ec2f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#ada8024cec0a01e9107caaee5c69ec2f1">mem_heap_dup</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const void *data, ulint len)</td></tr>
<tr class="memitem:a5748f8d58c53b8d7c4cff7f8bd25f0c5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem0mem_8h.html#a5748f8d58c53b8d7c4cff7f8bd25f0c5">mem_heap_printf</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, const char *format,...)))</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The memory management</p>
<p>Created 6/9/1994 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="ad6a2ed79ee7aa82b1c09651e1047eda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_BLOCK_HEADER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="ut0ut_8h.html#adb061a676254d8943de08e15cafa062a">ut_calc_align</a>(<span class="keyword">sizeof</span>(<a class="code" href="structmem__block__info__t.html">mem_block_info_t</a>),\</div>
<div class="line">                                                        <a class="code" href="univ_8i.html#ad733ca9989da9c13b705f5886e815f05">UNIV_MEM_ALIGNMENT</a>)</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4cdeda261ea5f6db299898f33e6bbdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">PTR</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="mem0mem_8ic.html#a8b8f05469f9f6eec258bbe5e75bc4b1a">mem_free_func</a>((PTR), __FILE__, __LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this macro instead of the corresponding function! Macro for memory buffer freeing </p>

</div>
</div>
<a class="anchor" id="a6621ead8a647eed62fbd8a311a62330c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_HEAP_BTR_SEARCH</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* this flag can optionally be</span></div>
<div class="line"><span class="comment">                                        ORed to MEM_HEAP_BUFFER, in which</span></div>
<div class="line"><span class="comment">                                        case heap-&gt;free_block is used in</span></div>
<div class="line"><span class="comment">                                        some cases for memory allocations,</span></div>
<div class="line"><span class="comment">                                        and if it&#39;s NULL, the memory</span></div>
<div class="line"><span class="comment">                                        allocation functions can return</span></div>
<div class="line"><span class="comment">                                        NULL. */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a37b03a5cbf64e5271e6c62a9cc6bb5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#a8c712959b55472fb92497b8d76f79862">mem_heap_create_func</a>(           \</div>
<div class="line">                (N), __FILE__, __LINE__, MEM_HEAP_DYNAMIC)</div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap creation. </p>

</div>
</div>
<a class="anchor" id="aa3cad9edc7402f0af61a42fbd09343b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_create_typed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#a8c712959b55472fb92497b8d76f79862">mem_heap_create_func</a>(   \</div>
<div class="line">                (N), __FILE__, __LINE__, (T))</div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap creation. </p>

</div>
</div>
<a class="anchor" id="ab163da885b759ff5ece673bdf89950d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_heap_free</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="mem0mem_8h.html#a34047c1601b14ffef20989e6da7697c3">mem_heap_free_func</a>(\</div>
<div class="line">                                          (heap), __FILE__, __LINE__)</div>
</div><!-- fragment --><p>Use this macro instead of the corresponding function! Macro for memory heap freeing. </p>

</div>
</div>
<a class="anchor" id="a933476069d9c87d190e4d6a18eeca199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mem_zalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">N</td><td>)</td>
          <td>&#160;&#160;&#160;memset(mem_alloc(N), 0, (N))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this macro instead of the corresponding function! Macro for memory buffer allocation </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a9270a0ab9de0a0aaf9b26509cb10598a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_alloc_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Allocates a single buffer of memory from the dynamic memory of the C compiler. Is like malloc of C. The buffer must be freed with mem_free. </p>
<dl class="section return"><dt>Returns</dt><dd>own: free storage out: allocated size in bytes, or NULL</dd></dl>
<p>NOTE: Use the corresponding macro instead of this function. Allocates a single buffer of memory from the dynamic memory of the C compiler. Is like malloc of C. The buffer must be freed with mem_free. </p>
<dl class="section return"><dt>Returns</dt><dd>own: free storage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: desired number of bytes </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where created </td></tr>
    <tr><td class="paramname">line</td><td>in: line where created </td></tr>
    <tr><td class="paramname">size</td><td>out: allocated size in bytes, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8c1e14f38416a0128af1ddf92f4a08d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void mem_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the memory system. </p>

</div>
</div>
<a class="anchor" id="a8b8f05469f9f6eec258bbe5e75bc4b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_free_func </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Frees a single buffer of storage from the dynamic memory of C compiler. Similar to free of C. in: line where created</p>
<p>NOTE: Use the corresponding macro instead of this function. Frees a single buffer of storage from the dynamic memory of the C compiler. Similar to the free of C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in, own: buffer to be freed </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where created </td></tr>
    <tr><td class="paramname">line</td><td>in: line where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92f7ee9ca3354fdd5bc633f5ae7b9421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates n bytes of memory from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF</dd></dl>
<p>Allocates n bytes of memory from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>allocated storage, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c712959b55472fb92497b8d76f79862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* mem_heap_create_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macros instead of this function. Creates a memory heap. For debugging purposes, takes also the file name and line as arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>own: memory heap, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) in: heap type</dd></dl>
<p>NOTE: Use the corresponding macros instead of this function. Creates a memory heap. For debugging purposes, takes also the file name and line as argument. </p>
<dl class="section return"><dt>Returns</dt><dd>own: memory heap, NULL if did not succeed (only possible for MEM_HEAP_BTR_SEARCH type heaps) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: desired start block size, this means that a single user buffer of size n will fit in the block, 0 creates a default size block </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where created </td></tr>
    <tr><td class="paramname">line</td><td>in: line where created </td></tr>
    <tr><td class="paramname">type</td><td>in: heap type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada8024cec0a01e9107caaee5c69ec2f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* mem_heap_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicate a block of data, allocated from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the data in: length of data, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where copy is allocated </td></tr>
    <tr><td class="paramname">data</td><td>in: data to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98ae9a39a4d557c68977578bd0db3fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties a memory heap. The first memory block of the heap is not freed. in: heap to empty</p>
<p>Empties a memory heap. The first memory block of the heap is not freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap to empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34047c1601b14ffef20989e6da7697c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: Use the corresponding macro instead of this function. Frees the space occupied by a memory heap. In the debug version erases the heap memory blocks. in: line where freed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in, own: heap to be freed </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b274fd0d860517ff623eef01a6a099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>old_top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the space in a memory heap exceeding the pointer given. The pointer must have been acquired from mem_heap_get_heap_top. The first memory block of the heap is not freed. in: pointer to old top of heap</p>
<p>Frees the space in a memory heap exceeding the pointer given. The pointer must have been acquired from mem_heap_get_heap_top. The first memory block of the heap is not freed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap from which to free </td></tr>
    <tr><td class="paramname">old_top</td><td>in: pointer to old top of heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bbaa90de4133e744d809cfd6c764046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void mem_heap_free_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the topmost element in a memory heap. The size of the element must be given. in: size of the topmost element</p>
<p>Frees the topmost element in a memory heap. The size of the element must be given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">n</td><td>in: size of the topmost element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf86da5f1414a8bb3f80e50321a8e55e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* mem_heap_get_heap_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the heap top. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the heap top in: memory heap</dd></dl>
<p>Returns a pointer to the heap top. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the heap top </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a469829136569041fbd26404dd7af7e08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint mem_heap_get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the space in bytes occupied by a memory heap. in: heap</p>
<p>Returns the space in bytes occupied by a memory heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a854d0114bb14a2fc66685af99642c4f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_get_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the topmost element in a memory heap. The size of the element must be given. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the topmost element in: size of the topmost element</dd></dl>
<p>Returns a pointer to the topmost element in a memory heap. The size of the element must be given. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the topmost element </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">n</td><td>in: size of the topmost element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5748f8d58c53b8d7c4cff7f8bd25f0c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple sprintf replacement that dynamically allocates the space for the formatted string from the given heap. This supports a very limited set of the printf syntax: types 's' and 'u' and length modifier 'l' (which is required for the 'u' type). </p>
<dl class="section return"><dt>Returns</dt><dd>heap-allocated formatted string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">format</td><td>in: format string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14c7003eedd1e8e7d40eab34c3569658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_strcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate two strings and return the result, using a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the result in: string 2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">s1</td><td>in: string 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3de3ebcaa704fafbfb878154e0eb8367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* mem_heap_strdup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates a NUL-terminated string, allocated from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string in: string to be copied </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cb6550c0724daf639e0cef00b7b5b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_heap_strdupl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a NUL-terminated copy of a nonterminated string, allocated from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string in: length of str, in bytes</dd></dl>
<p>Makes a NUL-terminated copy of a nonterminated string, allocated from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where string is allocated </td></tr>
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
    <tr><td class="paramname">len</td><td>in: length of str, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8162d816aada62ef8f84c83b6787befa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* mem_heap_zalloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates and zero-fills n bytes of memory from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>allocated, zero-filled storage in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF</dd></dl>
<p>Allocates and zero-fills n bytes of memory from a memory heap. </p>
<dl class="section return"><dt>Returns</dt><dd>allocated, zero-filled storage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes; if the heap is allowed to grow into the buffer pool, this must be &lt;= MEM_MAX_ALLOC_IN_BUF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35202ac8c0599fd2ba745cf7c8660104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void mem_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the memory system. in: common pool size in bytes </p>

</div>
</div>
<a class="anchor" id="ad40ee2ae09b8776ea6f7b258d94ee276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates a NUL-terminated string. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free in: string to be copied</dd></dl>
<p>Duplicates a NUL-terminated string. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601462ebfa8661c981f405734f77cf22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* mem_strdupl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a NUL-terminated copy of a nonterminated string. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free in: length of str, in bytes</dd></dl>
<p>Makes a NUL-terminated copy of a nonterminated string. </p>
<dl class="section return"><dt>Returns</dt><dd>own: a copy of the string, must be deallocated with mem_free </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string to be copied </td></tr>
    <tr><td class="paramname">len</td><td>in: length of str, in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:20 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
