<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/buf0buf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0buf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="page0types_8h_source.html">page0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0rbt_8h_source.html">ut0rbt.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="os0proc_8h_source.html">os0proc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0buf_8ic.html">buf0buf.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for buf0buf.h:</div>
<div class="dyncontent">
<div class="center"><img src="buf0buf_8h__incl.png" border="0" usemap="#include_2buf0buf_8h" alt=""/></div>
<map name="include_2buf0buf_8h" id="include_2buf0buf_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="909,547,963,575"/><area shape="rect" id="node28" href="fil0fil_8h.html" title="fil0fil.h" alt="" coords="523,161,584,189"/><area shape="rect" id="node33" href="ut0byte_8h.html" title="ut0byte.h" alt="" coords="1011,315,1093,343"/><area shape="rect" id="node51" href="log0log_8h.html" title="log0log.h" alt="" coords="811,238,891,266"/><area shape="rect" id="node59" href="mtr0types_8h.html" title="mtr0types.h" alt="" coords="1424,315,1523,343"/><area shape="rect" id="node61" href="buf0types_8h.html" title="buf0types.h" alt="" coords="1605,238,1701,266"/><area shape="rect" id="node63" href="hash0hash_8h.html" title="hash0hash.h" alt="" coords="224,161,328,189"/><area shape="rect" id="node77" href="page0types_8h.html" title="page0types.h" alt="" coords="1320,238,1429,266"/><area shape="rect" id="node82" href="ut0rbt_8h.html" title="ut0rbt.h" alt="" coords="943,393,1015,421"/><area shape="rect" id="node86" href="os0proc_8h.html" title="os0proc.h" alt="" coords="1793,83,1879,111"/><area shape="rect" id="node92" href="buf0buf_8ic.html" title="buf0buf.ic" alt="" coords="1381,83,1464,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="821,625,899,653"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="973,625,1040,653"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="933,702,1008,730"/><area shape="rect" id="node31" href="dict0types_8h.html" title="dict0types.h" alt="" coords="1235,315,1333,343"/><area shape="rect" id="node36" href="os0file_8h.html" title="os0file.h" alt="" coords="240,470,315,498"/><area shape="rect" id="node40" href="sync0rw_8h.html" title="sync0rw.h" alt="" coords="572,315,655,343"/><area shape="rect" id="node49" href="ibuf0types_8h.html" title="ibuf0types.h" alt="" coords="504,238,603,266"/><area shape="rect" id="node43" href="sync0sync_8h.html" title="sync0sync.h" alt="" coords="649,393,748,421"/><area shape="rect" id="node46" href="ut0mem_8h.html" title="ut0mem.h" alt="" coords="729,470,817,498"/><area shape="rect" id="node66" href="mem0mem_8h.html" title="mem0mem.h" alt="" coords="677,238,787,266"/><area shape="rect" id="node74" href="hash0hash_8ic.html" title="hash0hash.ic" alt="" coords="5,238,112,266"/><area shape="rect" id="node89" href="os0proc_8ic.html" title="os0proc.ic" alt="" coords="1793,161,1879,189"/><area shape="rect" id="node94" href="mtr0mtr_8h.html" title="mtr0mtr.h" alt="" coords="1088,161,1173,189"/><area shape="rect" id="node104" href="buf0flu_8h.html" title="buf0flu.h" alt="" coords="1383,161,1460,189"/><area shape="rect" id="node111" href="buf0lru_8h.html" title="buf0lru.h" alt="" coords="1484,161,1561,189"/><area shape="rect" id="node116" href="buf0rea_8h.html" title="buf0rea.h" alt="" coords="1585,161,1668,189"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="buf0buf_8h__dep__incl.png" border="0" usemap="#include_2buf0buf_8hdep" alt=""/></div>
<map name="include_2buf0buf_8hdep" id="include_2buf0buf_8hdep">
<area shape="rect" id="node3" href="trx0sys_8h.html" title="include/trx0sys.h" alt="" coords="725,83,853,111"/><area shape="rect" id="node7" href="mtr0log_8ic.html" title="include/mtr0log.ic" alt="" coords="5,161,139,189"/><area shape="rect" id="node11" href="lock0lock_8ic.html" title="include/lock0lock.ic" alt="" coords="1197,161,1339,189"/><area shape="rect" id="node24" href="buf0flu_8ic.html" title="include/buf0flu.ic" alt="" coords="1360,83,1488,111"/><area shape="rect" id="node28" href="fut0fut_8ic.html" title="include/fut0fut.ic" alt="" coords="1563,83,1688,111"/><area shape="rect" id="node32" href="fut0lst_8ic.html" title="include/fut0lst.ic" alt="" coords="1512,238,1637,266"/><area shape="rect" id="node36" href="page0page_8h.html" title="include/page0page.h" alt="" coords="1131,83,1285,111"/><area shape="rect" id="node40" href="btr0sea_8ic.html" title="include/btr0sea.ic" alt="" coords="1712,83,1845,111"/><area shape="rect" id="node42" href="buf0buddy_8ic.html" title="include/buf0buddy.ic" alt="" coords="1869,83,2019,111"/><area shape="rect" id="node47" href="dict0boot_8h.html" title="include/dict0boot.h" alt="" coords="2043,83,2184,111"/><area shape="rect" id="node5" href="trx0roll_8h.html" title="include/trx0roll.h" alt="" coords="880,161,1005,189"/><area shape="rect" id="node9" href="trx0undo_8h.html" title="include/trx0undo.h" alt="" coords="163,161,301,189"/><area shape="rect" id="node13" href="read0read_8ic.html" title="include/read0read.ic" alt="" coords="325,161,475,189"/><area shape="rect" id="node15" href="row0undo_8h.html" title="include/row0undo.h" alt="" coords="499,161,643,189"/><area shape="rect" id="node17" href="trx0purge_8h.html" title="include/trx0purge.h" alt="" coords="1029,161,1173,189"/><area shape="rect" id="node19" href="trx0rseg_8h.html" title="include/trx0rseg.h" alt="" coords="721,238,857,266"/><area shape="rect" id="node21" href="trx0rseg_8ic.html" title="include/trx0rseg.ic" alt="" coords="667,161,805,189"/><area shape="rect" id="node26" href="buf0flu_8h.html" title="include/buf0flu.h" alt="" coords="1363,161,1488,189"/><area shape="rect" id="node30" href="fut0fut_8h.html" title="include/fut0fut.h" alt="" coords="1563,161,1688,189"/><area shape="rect" id="node44" href="buf0buddy_8h.html" title="include/buf0buddy.h" alt="" coords="1871,161,2017,189"/></map>
</div>
</div>
<p><a href="buf0buf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__page__t.html">buf_page_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__block__t.html">buf_block_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__buddy__free__t.html">buf_buddy_free_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pool statistics structure.  <a href="structbuf__pool__stat__t.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__buddy__stat__t.html">buf_buddy_stat_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer pool structure.  <a href="structbuf__pool__t.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckInLRUList.html">CheckInLRUList</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckInFreeList.html">CheckInFreeList</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCheckUnzipLRUAndLRUList.html">CheckUnzipLRUAndLRUList</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1eb6deaefa35074b65922f2751143b76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1eb6deaefa35074b65922f2751143b76">MAX_BUFFER_POOLS_BITS</a>&#160;&#160;&#160;6</td></tr>
<tr class="memitem:a1082f72aaa5cd92502df0cd9b0506195"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1082f72aaa5cd92502df0cd9b0506195">MAX_BUFFER_POOLS</a>&#160;&#160;&#160;(1 &lt;&lt; <a class="el" href="buf0buf_8h.html#a1eb6deaefa35074b65922f2751143b76">MAX_BUFFER_POOLS_BITS</a>)</td></tr>
<tr class="memitem:a43a4f552119eafa1c0c2b71404c50ebe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a43a4f552119eafa1c0c2b71404c50ebe">BUF_POOL_WATCH_SIZE</a>&#160;&#160;&#160;(srv_n_purge_threads + 1)</td></tr>
<tr class="memitem:a54dcea5e3b5d7216b50559eabf13ae9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a54dcea5e3b5d7216b50559eabf13ae9d">MAX_PAGE_HASH_LOCKS</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:aa96b185c83ee3675e19cdd7195f0529c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa96b185c83ee3675e19cdd7195f0529c">BUF_NO_CHECKSUM_MAGIC</a>&#160;&#160;&#160;0xDEADBEEFUL</td></tr>
<tr class="memitem:af42256ee94cebb3086096244fcbb872d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af42256ee94cebb3086096244fcbb872d">buf_page_get</a>(SP, ZS, OF, LA, MTR)</td></tr>
<tr class="memitem:af639cf80c7c2a48521049a8235425703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af639cf80c7c2a48521049a8235425703">buf_page_get_with_no_latch</a>(SP, ZS, OF, MTR)</td></tr>
<tr class="memitem:aab831f92f719df32c428a1e46c0f5e1d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aab831f92f719df32c428a1e46c0f5e1d">buf_page_try_get</a>(space_id, page_no, mtr)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a2ecdc5cbcd0ed4554e3dfd1dfe96d452">buf_page_try_get_func</a>(space_id, page_no, __FILE__, __LINE__, mtr);</td></tr>
<tr class="memitem:ab992c7712a4353abf34bfafbe3a6431a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab992c7712a4353abf34bfafbe3a6431a">buf_block_buf_fix_inc</a>(b, f, l)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#aac193f180fc2dea1a6daf0a133e4977b">buf_block_buf_fix_inc_func</a>(f,l,b)</td></tr>
<tr class="memitem:a78b0bcde049a4c30e62ec696daa55dff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a78b0bcde049a4c30e62ec696daa55dff">buf_block_get_page_zip</a>(<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)&#160;&#160;&#160;((<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)-&gt;page.zip.data ? &amp;(<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)-&gt;page.zip : NULL)</td></tr>
<tr class="memitem:a6a3b4fc4c67b20026d078f0a22bf5be6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6a3b4fc4c67b20026d078f0a22bf5be6">buf_pool_is_block_mutex</a>(m)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a>((const void*)(m))</td></tr>
<tr class="memitem:af684e31863d4f9f57dffae52b7895653"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af684e31863d4f9f57dffae52b7895653">buf_pool_is_block_lock</a>(l)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a>((const void*)(l))</td></tr>
<tr class="memitem:afceb14b2a074d069c18bc2226361eed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afceb14b2a074d069c18bc2226361eed6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_page_hash_get_s_locked</b>(b, s, o, l)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#adff4aec08748024c1e0e7242831d171a">buf_page_hash_get_locked</a>(b, s, o, l, RW_LOCK_SHARED)</td></tr>
<tr class="memitem:a6525352a2e20e3ae0edd1ebb730fea77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6525352a2e20e3ae0edd1ebb730fea77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_page_hash_get_x_locked</b>(b, s, o, l)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#adff4aec08748024c1e0e7242831d171a">buf_page_hash_get_locked</a>(b, s, o, l, RW_LOCK_EX)</td></tr>
<tr class="memitem:ad00ddc3eb28ad013b32a5a43cac201ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00ddc3eb28ad013b32a5a43cac201ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_page_hash_get</b>(b, s, o)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#adff4aec08748024c1e0e7242831d171a">buf_page_hash_get_locked</a>(b, s, o, NULL, 0)</td></tr>
<tr class="memitem:acc4f7a7f3b151d1f72e9e995c580d045"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc4f7a7f3b151d1f72e9e995c580d045"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_page_get_also_watch</b>(b, s, o)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#adff4aec08748024c1e0e7242831d171a">buf_page_hash_get_locked</a>(b, s, o, NULL, 0, true)</td></tr>
<tr class="memitem:ad97a52f94efb717a880f9b9493649987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad97a52f94efb717a880f9b9493649987"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_get_s_locked</b>(b, s, o, l)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#a98c52dccde10bc29a162cb815c0e03c9">buf_block_hash_get_locked</a>(b, s, o, l, RW_LOCK_SHARED)</td></tr>
<tr class="memitem:ae07cd82aeb4d4b9df3791d29f8b4d8fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae07cd82aeb4d4b9df3791d29f8b4d8fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_get_x_locked</b>(b, s, o, l)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#a98c52dccde10bc29a162cb815c0e03c9">buf_block_hash_get_locked</a>(b, s, o, l, RW_LOCK_EX)</td></tr>
<tr class="memitem:a19e474592d21fd1265c3542229a14d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e474592d21fd1265c3542229a14d53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_get</b>(b, s, o)&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#a98c52dccde10bc29a162cb815c0e03c9">buf_block_hash_get_locked</a>(b, s, o, NULL, 0)</td></tr>
<tr class="memitem:a8164aaa09f898842fd978f6fd4797cfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8164aaa09f898842fd978f6fd4797cfc">BUF_PAGE_STATE_BITS</a>&#160;&#160;&#160;3</td></tr>
<tr class="memitem:aa20f5c2f2899db5e3414580b07b50ed9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa20f5c2f2899db5e3414580b07b50ed9">buf_block_state_valid</a>(<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modes for buf_page_get_gen</div></td></tr>
<tr class="memitem:a44fc9fa4746274dad06b2d1f32ff8fc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a44fc9fa4746274dad06b2d1f32ff8fc1">BUF_GET</a>&#160;&#160;&#160;10</td></tr>
<tr class="memitem:abdb9afd2ef5fbd22769359c7db3b5a95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#abdb9afd2ef5fbd22769359c7db3b5a95">BUF_GET_IF_IN_POOL</a>&#160;&#160;&#160;11</td></tr>
<tr class="memitem:a2266e9f454c211c7eaf63ee4b2799383"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2266e9f454c211c7eaf63ee4b2799383">BUF_PEEK_IF_IN_POOL</a>&#160;&#160;&#160;12</td></tr>
<tr class="memitem:ac8df476ac2b95ad8c0d25d3ed4fca43e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac8df476ac2b95ad8c0d25d3ed4fca43e">BUF_GET_NO_LATCH</a>&#160;&#160;&#160;14</td></tr>
<tr class="memitem:a73c317958672e1b1988e08f8ed5b3ca3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a73c317958672e1b1988e08f8ed5b3ca3">BUF_GET_IF_IN_POOL_OR_WATCH</a>&#160;&#160;&#160;15</td></tr>
<tr class="memitem:ad9efb1ed3aec51fd0280fb58175c4e84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad9efb1ed3aec51fd0280fb58175c4e84">BUF_GET_POSSIBLY_FREED</a>&#160;&#160;&#160;16</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modes for buf_page_get_known_nowait</div></td></tr>
<tr class="memitem:a2982b27f638be922b0f0be0fa6eecc98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2982b27f638be922b0f0be0fa6eecc98">BUF_MAKE_YOUNG</a>&#160;&#160;&#160;51</td></tr>
<tr class="memitem:a4a372deecff68a38a16714d7c404843b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4a372deecff68a38a16714d7c404843b">BUF_KEEP_OLD</a>&#160;&#160;&#160;52</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf241fbcf516b9cd38017fbf9a7d211b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acf241fbcf516b9cd38017fbf9a7d211b">BUF_POOL_ZIP_FOLD_PTR</a>(ptr)&#160;&#160;&#160;((ulint) (ptr) / <a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a>)</td></tr>
<tr class="memitem:a9c028eac069f92725d6fef2d502c33bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c028eac069f92725d6fef2d502c33bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_POOL_ZIP_FOLD</b>(b)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#acf241fbcf516b9cd38017fbf9a7d211b">BUF_POOL_ZIP_FOLD_PTR</a>((b)-&gt;frame)</td></tr>
<tr class="memitem:a7ca27db7bba7c227b5a7b2f02ee5a8f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ca27db7bba7c227b5a7b2f02ee5a8f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_POOL_ZIP_FOLD_BPAGE</b>(b)&#160;&#160;&#160;BUF_POOL_ZIP_FOLD((<a class="el" href="structbuf__block__t.html">buf_block_t</a>*) (b))</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for buf_pool-&gt;mutex.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Use these instead of accessing buf_pool-&gt;mutex directly. </p>
</div></td></tr>
<tr class="memitem:af996360800fd59fb8681a329ad2575bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af996360800fd59fb8681a329ad2575bf">buf_pool_mutex_own</a>(b)&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;b-&gt;mutex)</td></tr>
<tr class="memitem:ab38d13c8b2fc9bb6f83dca458cb13e89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab38d13c8b2fc9bb6f83dca458cb13e89">buf_pool_mutex_enter</a>(b)</td></tr>
<tr class="memitem:a7134f85ae33367e8860b6814c0866ff5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7134f85ae33367e8860b6814c0866ff5">buf_flush_list_mutex_own</a>(b)&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;b-&gt;flush_list_mutex)</td></tr>
<tr class="memitem:a095adbc797576159cfc092fb6bdedeb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a095adbc797576159cfc092fb6bdedeb2">buf_flush_list_mutex_enter</a>(b)</td></tr>
<tr class="memitem:aaefd70716bf3351e09b6e52ea9ca6783"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aaefd70716bf3351e09b6e52ea9ca6783">buf_flush_list_mutex_exit</a>(b)</td></tr>
<tr class="memitem:ac646c8d55412a81a0ad6285ec65cea0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac646c8d55412a81a0ad6285ec65cea0a">buf_block_mutex_own</a>(b)&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;(b)-&gt;mutex)</td></tr>
<tr class="memitem:a58b9bdc92869c7be41c65d4013151b41"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a58b9bdc92869c7be41c65d4013151b41">buf_block_mutex_enter</a>(b)</td></tr>
<tr class="memitem:a416662e2711051d765dc9bf811a7237d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a416662e2711051d765dc9bf811a7237d">buf_block_mutex_exit</a>(b)</td></tr>
<tr class="memitem:aeb1399574113871a8846a75eefeffde6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aeb1399574113871a8846a75eefeffde6">buf_page_hash_lock_get</a>(b, f)&#160;&#160;&#160;<a class="el" href="hash0hash_8ic.html#ac2c915b43186f53f8c63dfd22bf4562c">hash_get_lock</a>(b-&gt;page_hash, f)</td></tr>
<tr class="memitem:a4ac5aa316025e85f6d819661845771c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4ac5aa316025e85f6d819661845771c2">buf_page_hash_lock_held_s</a>(b, p)</td></tr>
<tr class="memitem:a6c180fb2c8fe2d7cd550a0271ce7da52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6c180fb2c8fe2d7cd550a0271ce7da52">buf_page_hash_lock_held_x</a>(b, p)</td></tr>
<tr class="memitem:af721dd9d066797337b9fd5da6297ff2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af721dd9d066797337b9fd5da6297ff2c">buf_page_hash_lock_held_s_or_x</a>(b, p)</td></tr>
<tr class="memitem:a84eceba2d23a52543514f437098e0052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84eceba2d23a52543514f437098e0052"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_lock_held_s</b>(b, p)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a4ac5aa316025e85f6d819661845771c2">buf_page_hash_lock_held_s</a>(b, &amp;(p-&gt;page))</td></tr>
<tr class="memitem:a3a856e4b2ed54c539c480bb4f74301c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a856e4b2ed54c539c480bb4f74301c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_lock_held_x</b>(b, p)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a6c180fb2c8fe2d7cd550a0271ce7da52">buf_page_hash_lock_held_x</a>(b, &amp;(p-&gt;page))</td></tr>
<tr class="memitem:a1294f0b7bcdb42387ea901f7d15c8747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1294f0b7bcdb42387ea901f7d15c8747"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>buf_block_hash_lock_held_s_or_x</b>(b, p)&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#af721dd9d066797337b9fd5da6297ff2c">buf_page_hash_lock_held_s_or_x</a>(b, &amp;(p-&gt;page))</td></tr>
<tr class="memitem:a912f55f1a0e191784595b0efd57b5658"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a912f55f1a0e191784595b0efd57b5658">buf_pool_mutex_exit_forbid</a>(b)</td></tr>
<tr class="memitem:a7cc33ac578b47cdf7e0d462abef5c130"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7cc33ac578b47cdf7e0d462abef5c130">buf_pool_mutex_exit_allow</a>(b)</td></tr>
<tr class="memitem:a660aa390cd79424e2a7022085eb49b50"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a660aa390cd79424e2a7022085eb49b50">buf_pool_mutex_exit</a>(b)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab8edfb8ad98167f82518879ade67dc8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> { <br/>
&#160;&#160;<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aaa5d948d8c9ee109afa2f2b05672a3930">BUF_BLOCK_POOL_WATCH</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa21e9fab74d2c9e64609dd53570bdfaec">BUF_BLOCK_ZIP_PAGE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa9135ba69991c7e4a4943f289de621509">BUF_BLOCK_ZIP_DIRTY</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c">BUF_BLOCK_NOT_USED</a>, 
<br/>
&#160;&#160;<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aad5dffb35305e497c0afd120525221d18">BUF_BLOCK_READY_FOR_USE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aaf26cdfc58e629f98cf27da284f6cf5f9">BUF_BLOCK_FILE_PAGE</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa7278567ff34beb6c693af5267611c4c7">BUF_BLOCK_MEMORY</a>, 
<a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87">BUF_BLOCK_REMOVE_HASH</a>
<br/>
 }</td></tr>
<tr class="memdesc:ab8edfb8ad98167f82518879ade67dc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">States of a control block.  <a href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">More...</a><br/></td></tr>
<tr class="memitem:aa6098ccc0d0f4a65b3bdfcb0d430ba46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46">buf_page_print_flags</a> { <a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46a4de99c6b59acbd5c2aa46fd0632cb281">BUF_PAGE_PRINT_NO_CRASH</a> =  1, 
<a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46a476478124a1ec5bbf5faa153d2ff4763">BUF_PAGE_PRINT_NO_FULL</a> =  2
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac76936f6689fef74b464bb45ad40610d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac76936f6689fef74b464bb45ad40610d">buf_pool_mutex_enter_all</a> (void)</td></tr>
<tr class="memitem:a6121f55712fb2b5b574234a5a1db278c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6121f55712fb2b5b574234a5a1db278c">buf_pool_mutex_exit_all</a> (void)</td></tr>
<tr class="memitem:a00594803ebde3419ce812f88294dfe20"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a00594803ebde3419ce812f88294dfe20">buf_pool_init</a> (ulint size, ulint n_instances)</td></tr>
<tr class="memitem:a0a32cbba300ff8f3f33bc54e47eb4360"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0a32cbba300ff8f3f33bc54e47eb4360">buf_pool_free</a> (ulint n_instances)</td></tr>
<tr class="memitem:a5358efb915e801353ddfc12178c7331b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5358efb915e801353ddfc12178c7331b">buf_pool_clear_hash_index</a> (void)</td></tr>
<tr class="memitem:a35e03a01f6d0f2b961a3f0341a720f73"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a35e03a01f6d0f2b961a3f0341a720f73">buf_relocate</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="structbuf__page__t.html">buf_page_t</a> *dpage))</td></tr>
<tr class="memitem:a23372a7fc86173052a9bfe927c9312b4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a23372a7fc86173052a9bfe927c9312b4">buf_pool_get_curr_size</a> (void)</td></tr>
<tr class="memitem:acff3e4e95015baaa1740ff6098e6e164"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acff3e4e95015baaa1740ff6098e6e164">buf_pool_get_n_pages</a> (void)</td></tr>
<tr class="memitem:a7f96406b87de005b0234f06c369d8ad4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7f96406b87de005b0234f06c369d8ad4">buf_pool_get_oldest_modification</a> (void)</td></tr>
<tr class="memitem:a693e861ee761ae35f0be48fea286a1d3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a693e861ee761ae35f0be48fea286a1d3">buf_page_alloc_descriptor</a> (void))</td></tr>
<tr class="memitem:a487f5b2e7a030166033d79086d0be585"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a487f5b2e7a030166033d79086d0be585">buf_page_free_descriptor</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:af1364bb9b989dc1f07c913b14f29a9fb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af1364bb9b989dc1f07c913b14f29a9fb">buf_block_alloc</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:a58d8810e5f830e55bdf31da6b88972ea"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a58d8810e5f830e55bdf31da6b88972ea">buf_block_free</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a70c8e79f9fad932a3f06f1edf84c2147"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a70c8e79f9fad932a3f06f1edf84c2147">buf_frame_copy</a> (byte *buf, const <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *frame)</td></tr>
<tr class="memitem:a4b2249b3ba3868dc2afd2ebea3480a01"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4b2249b3ba3868dc2afd2ebea3480a01">buf_page_optimistic_get</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ib_uint64_t modify_clock, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aa084c3df8c4e1390fc8389cdc639e69b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa084c3df8c4e1390fc8389cdc639e69b">buf_page_get_known_nowait</a> (ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint mode, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a2ecdc5cbcd0ed4554e3dfd1dfe96d452"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2ecdc5cbcd0ed4554e3dfd1dfe96d452">buf_page_try_get_func</a> (ulint space_id, ulint page_no, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aba8580c21048bc75fc52fcf1b14f7b2d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aba8580c21048bc75fc52fcf1b14f7b2d">buf_page_get_zip</a> (ulint space, ulint zip_size, ulint offset)</td></tr>
<tr class="memitem:a35978421b8e05e91ad4f4bd48b1db416"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a35978421b8e05e91ad4f4bd48b1db416">buf_page_get_gen</a> (ulint space, ulint zip_size, ulint offset, ulint rw_latch, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *guess, ulint mode, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aa46fda4f90104f3919b4577d11caf957"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa46fda4f90104f3919b4577d11caf957">buf_page_create</a> (ulint space, ulint offset, ulint zip_size, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a6ce5d2fc2911e993640a50d360670592"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6ce5d2fc2911e993640a50d360670592">buf_page_release_zip</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a61e2f995432617daf7c32b633d61055f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a61e2f995432617daf7c32b633d61055f">buf_page_release</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint rw_latch)</td></tr>
<tr class="memitem:a2fb94effb9f9c0de7b40c07a91ceee16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2fb94effb9f9c0de7b40c07a91ceee16">buf_page_make_young</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a101528fa6fbcef8e22c11b63bf8bff28"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a101528fa6fbcef8e22c11b63bf8bff28">buf_page_peek</a> (ulint space, ulint offset)</td></tr>
<tr class="memitem:a8db60f41f12aff8aebb7e53e6c014011"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8db60f41f12aff8aebb7e53e6c014011">buf_page_set_file_page_was_freed</a> (ulint space, ulint offset)</td></tr>
<tr class="memitem:ad9292fa36d7601927df112e3ab42a1a5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad9292fa36d7601927df112e3ab42a1a5">buf_page_reset_file_page_was_freed</a> (ulint space, ulint offset)</td></tr>
<tr class="memitem:a46271b3a89ac82366873b9760feb3cf8"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a46271b3a89ac82366873b9760feb3cf8">buf_page_get_freed_page_clock</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a7093bd2038fedbf233dabd7488363e2c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7093bd2038fedbf233dabd7488363e2c">buf_block_get_freed_page_clock</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:a47ffed634c26feb6e975600b553e48c5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a47ffed634c26feb6e975600b553e48c5">buf_page_peek_if_young</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:ac8bcc2e01e4ffe6abf420008166b1062"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac8bcc2e01e4ffe6abf420008166b1062">buf_page_peek_if_too_old</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a5df3bda5bcc128a66ddb88607f7aa7fc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5df3bda5bcc128a66ddb88607f7aa7fc">buf_page_get_newest_modification</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:aab0fe6ab9881b94fe49c82d25dbe819a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aab0fe6ab9881b94fe49c82d25dbe819a">buf_block_modify_clock_inc</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a4b8e1e6da6d695762349b237dadcd982"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4b8e1e6da6d695762349b237dadcd982">buf_block_get_modify_clock</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a2c94e35b115562bb13cdad1016ba9937"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2c94e35b115562bb13cdad1016ba9937">buf_block_buf_fix_inc_func</a> (const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:a72a343e7650c641f8d1ccedc95f632a1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a72a343e7650c641f8d1ccedc95f632a1">buf_block_fix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a760064e6e2e6277c43a1af888fbbaafb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a760064e6e2e6277c43a1af888fbbaafb">buf_block_unfix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:aeb0398f2f98a2fe3462072dba70fb4cd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aeb0398f2f98a2fe3462072dba70fb4cd">buf_page_is_corrupted</a> (bool check_lsn, const byte *read_buf, ulint zip_size))</td></tr>
<tr class="memitem:adc3917d4a5b0630a356a9d244886ebf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adc3917d4a5b0630a356a9d244886ebf9">buf_page_is_zeroes</a> (const byte *read_buf, const ulint zip_size)</td></tr>
<tr class="memitem:a31fb62a395c54b928a66563a73010677"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a31fb62a395c54b928a66563a73010677">buf_ptr_get_fsp_addr</a> (const void *ptr, ulint *space, <a class="el" href="structfil__addr__t.html">fil_addr_t</a> *addr)</td></tr>
<tr class="memitem:ad07f334ac0e6ac453d69aec198aa9bf0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad07f334ac0e6ac453d69aec198aa9bf0">buf_block_get_lock_hash_val</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:ab53bd858064780246c5d6c6141db8b36"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab53bd858064780246c5d6c6141db8b36">buf_pool_contains_zip</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const void *data)</td></tr>
<tr class="memitem:aac0ec477ed8bba5d447e069f5ac6d31b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac0ec477ed8bba5d447e069f5ac6d31b"></a>
UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buf_frame_align</b> (byte *ptr)</td></tr>
<tr class="memitem:ad8ea10ef89cb3d974bec6c056de295f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad8ea10ef89cb3d974bec6c056de295f1">buf_validate</a> (void)</td></tr>
<tr class="memitem:a70ef2a65e5054be667ff252648a1b901"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a70ef2a65e5054be667ff252648a1b901">buf_print</a> (void)</td></tr>
<tr class="memitem:a8341706850d2b0af4b44208afc8c1718"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8341706850d2b0af4b44208afc8c1718">buf_page_print</a> (const byte *read_buf, ulint zip_size, ulint flags) UNIV_COLD)</td></tr>
<tr class="memitem:ae97c93aa8f9ecd83bbc579fc36640ff1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae97c93aa8f9ecd83bbc579fc36640ff1">buf_zip_decompress</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> check)</td></tr>
<tr class="memitem:af4b823851e97551f1a9c7e7952f887ab"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#af4b823851e97551f1a9c7e7952f887ab">buf_get_latched_pages_number</a> (void)</td></tr>
<tr class="memitem:aa81cf5958ac70dc03d2bd8c69b355975"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa81cf5958ac70dc03d2bd8c69b355975">buf_get_n_pending_read_ios</a> (void)</td></tr>
<tr class="memitem:ab20138c8871f85d710230adc053943f3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab20138c8871f85d710230adc053943f3">buf_print_io</a> (FILE *file)</td></tr>
<tr class="memitem:a0657a55a27fb821febe21fd93c5e1bb7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0657a55a27fb821febe21fd93c5e1bb7">buf_stats_get_pool_info</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint pool_id, <a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *all_pool_info)</td></tr>
<tr class="memitem:ab66718ee074230bc14001aee57e5044a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab66718ee074230bc14001aee57e5044a">buf_get_modified_ratio_pct</a> (void)</td></tr>
<tr class="memitem:ae7cb16ef6711245409a7e117e6da54e1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ae7cb16ef6711245409a7e117e6da54e1">buf_refresh_io_stats</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memitem:a6817c8278c04718851b86d4c4a613e43"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6817c8278c04718851b86d4c4a613e43">buf_refresh_io_stats_all</a> (void)</td></tr>
<tr class="memitem:a6f9e1d761f5c154cf5c5ab26a07c6444"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6f9e1d761f5c154cf5c5ab26a07c6444">buf_all_freed</a> (void)</td></tr>
<tr class="memitem:ac12113d926b18d7fd1ffef49e5d72ea4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ac12113d926b18d7fd1ffef49e5d72ea4">buf_pool_check_no_pending_io</a> (void)</td></tr>
<tr class="memitem:a65e9d3982cda06d0032aa5dec9a3fc69"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a65e9d3982cda06d0032aa5dec9a3fc69">buf_pool_invalidate</a> (void)</td></tr>
<tr class="memitem:a7f5e1ca4adc326a3240f16b494f38aed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7f5e1ca4adc326a3240f16b494f38aed">buf_block_dbg_add_level</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint level)</td></tr>
<tr class="memitem:a4a99189b090a1af68ff81b98b5418a0f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4a99189b090a1af68ff81b98b5418a0f">buf_page_get_state</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:aa88fbb80cef26e86eddb323817c36c46"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa88fbb80cef26e86eddb323817c36c46">buf_block_get_state</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:a38ae1a9052817ce692827243ce970d3e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a38ae1a9052817ce692827243ce970d3e">buf_page_set_state</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> state)</td></tr>
<tr class="memitem:a542cb040a75435f73008c7009d9a908b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a542cb040a75435f73008c7009d9a908b">buf_block_set_state</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> state)</td></tr>
<tr class="memitem:a905320d982d927f5d1bd2fad94e5742f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a905320d982d927f5d1bd2fad94e5742f">buf_page_in_file</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a2d57411802ceb05bcde2f18a74f64117"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2d57411802ceb05bcde2f18a74f64117">buf_page_belongs_to_unzip_LRU</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a9aeabb407e37058610eda62ebf0c1f67"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structib__mutex__t.html">ib_mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a9aeabb407e37058610eda62ebf0c1f67">buf_page_get_mutex</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a06fd3f2072036f03082b0373a77ca296"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a06fd3f2072036f03082b0373a77ca296">buf_page_get_flush_type</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a53437d54ec990de81e9644d3ee6c4337"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a53437d54ec990de81e9644d3ee6c4337">buf_page_set_flush_type</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> flush_type)</td></tr>
<tr class="memitem:aa5fe5c9c1a1090dc7c5f05dec606a8a3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa5fe5c9c1a1090dc7c5f05dec606a8a3">buf_block_set_file_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint space, ulint page_no)</td></tr>
<tr class="memitem:a3f71eede4d9217492ffabd8fcfc7f584"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3f71eede4d9217492ffabd8fcfc7f584">buf_page_get_io_fix</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a8211423df81edc2a582ac2adaeb2cdd1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8211423df81edc2a582ac2adaeb2cdd1">buf_block_get_io_fix</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:ab1a8f29ac35531394d5cc6abb4e7bc2a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ab1a8f29ac35531394d5cc6abb4e7bc2a">buf_page_set_io_fix</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_fix)</td></tr>
<tr class="memitem:a427515122e86a7b344f79896801f30cb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a427515122e86a7b344f79896801f30cb">buf_block_set_io_fix</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> io_fix)</td></tr>
<tr class="memitem:aafc6d1173140eb14d5ca4a83a62d0f4a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aafc6d1173140eb14d5ca4a83a62d0f4a">buf_page_set_sticky</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:ad9b8b75af8fa0ad4e4ebb7723ec8a215"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad9b8b75af8fa0ad4e4ebb7723ec8a215">buf_page_unset_sticky</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a2dd9e8f0cf154f2e5acd92ff4585697b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2dd9e8f0cf154f2e5acd92ff4585697b">buf_page_can_relocate</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a4b069f2b5e2c8209b6b0299f2bbc1830"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a4b069f2b5e2c8209b6b0299f2bbc1830">buf_page_is_old</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:acaf46d5fc3b73bc26bf115615fb81d0d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#acaf46d5fc3b73bc26bf115615fb81d0d">buf_page_set_old</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> old)</td></tr>
<tr class="memitem:a5353bcf06b39c283357373a2c9e4be0c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5353bcf06b39c283357373a2c9e4be0c">buf_page_is_accessed</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a84322a8e0b7d690e53e1364b72e91ddd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a84322a8e0b7d690e53e1364b72e91ddd">buf_page_set_accessed</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a3588ddc8b6ec0c971bbfc6beed52cbeb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3588ddc8b6ec0c971bbfc6beed52cbeb">buf_page_get_block</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a7d369eb98363c43512a7f74c024a6381"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a7d369eb98363c43512a7f74c024a6381">buf_block_get_frame</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:ad6daca7f7e50ec0c81d6a7094b3f65ea"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad6daca7f7e50ec0c81d6a7094b3f65ea">buf_page_get_space</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a34b3552c9e5e4c09355d193a3f4bd573"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a34b3552c9e5e4c09355d193a3f4bd573">buf_block_get_space</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:a05bc307775a024942a188827f67bf31b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a05bc307775a024942a188827f67bf31b">buf_page_get_page_no</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:aa58f9b6f6ee178d4b9104f0b7623d750"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa58f9b6f6ee178d4b9104f0b7623d750">buf_block_get_page_no</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:ad2b21229dc8724079d645ca77d0e6ef3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad2b21229dc8724079d645ca77d0e6ef3">buf_page_get_zip_size</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:a8bc2133ef2d7bcfc9f4c0a80932cef36"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a8bc2133ef2d7bcfc9f4c0a80932cef36">buf_block_get_zip_size</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>))</td></tr>
<tr class="memitem:a856825cf58c3701a4654dde470217932"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a856825cf58c3701a4654dde470217932">buf_block_align</a> (const byte *ptr)</td></tr>
<tr class="memitem:a0cabada29220f8ab778c3d5d849772f5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a> (const void *ptr)</td></tr>
<tr class="memitem:a5cb587a6d2459041dbfc44abda970bae"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5cb587a6d2459041dbfc44abda970bae">buf_frame_get_page_zip</a> (const byte *ptr)</td></tr>
<tr class="memitem:a6424ffc76b8af1be289e341334f14905"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6424ffc76b8af1be289e341334f14905">buf_page_init_for_read</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err, ulint mode, ulint space, ulint zip_size, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> unzip, ib_int64_t tablespace_version, ulint offset)</td></tr>
<tr class="memitem:a1b42a085941cbde456551be2ebf514c6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1b42a085941cbde456551be2ebf514c6">buf_page_io_complete</a> (<a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:ad5aa5b06ebe41fd91c97723a2b074763"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad5aa5b06ebe41fd91c97723a2b074763">buf_page_address_fold</a> (ulint space, ulint offset))</td></tr>
<tr class="memitem:a6a25c12212deaa1d7c277f3b41aaa97d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a6a25c12212deaa1d7c277f3b41aaa97d">buf_pool_index</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool))</td></tr>
<tr class="memitem:a803b791d0706583d685f7f9413da45d7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a803b791d0706583d685f7f9413da45d7">buf_pool_from_bpage</a> (const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memitem:a499d41dc7d50849f883c2b06c07dbb02"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a499d41dc7d50849f883c2b06c07dbb02">buf_pool_from_block</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a38f885a522c33e61c4187d08f57f55cd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a38f885a522c33e61c4187d08f57f55cd">buf_pool_get</a> (ulint space, ulint offset)</td></tr>
<tr class="memitem:aac71426ec4d18966a8fa309954653b5e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aac71426ec4d18966a8fa309954653b5e">buf_pool_from_array</a> (ulint index)</td></tr>
<tr class="memitem:a82e4bd838178ed27ad3f174ac5084390"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a82e4bd838178ed27ad3f174ac5084390">buf_page_hash_get_low</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint space, ulint offset, ulint fold)</td></tr>
<tr class="memitem:a5ccd6c8cf03c0134b095b2f0d97c5eea"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a5ccd6c8cf03c0134b095b2f0d97c5eea">buf_page_hash_get_locked</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint space, ulint offset, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> **lock, ulint lock_mode, bool watch=false)</td></tr>
<tr class="memitem:a98c52dccde10bc29a162cb815c0e03c9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a98c52dccde10bc29a162cb815c0e03c9">buf_block_hash_get_locked</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint space, ulint offset, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> **lock, ulint lock_mode)</td></tr>
<tr class="memitem:a851c5c02d091e973f63e3d3fea5514ef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a851c5c02d091e973f63e3d3fea5514ef">buf_get_free_list_len</a> (void)</td></tr>
<tr class="memitem:a2b66139edd63334363dbd329566eece9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2b66139edd63334363dbd329566eece9">buf_pool_watch_is_sentinel</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *bpage))</td></tr>
<tr class="memitem:abb122295689df731668c04d5c69bc56b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#abb122295689df731668c04d5c69bc56b">buf_pool_watch_set</a> (ulint space, ulint offset, ulint fold))</td></tr>
<tr class="memitem:ad347338911fe564cc72f4a5f3f11a608"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad347338911fe564cc72f4a5f3f11a608">buf_pool_watch_unset</a> (ulint space, ulint offset)</td></tr>
<tr class="memitem:a87f2bec0d116db814ffc296eb92df589"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a87f2bec0d116db814ffc296eb92df589">buf_pool_watch_occurred</a> (ulint space, ulint offset))</td></tr>
<tr class="memitem:aeeb02ffe09cbab0f33f013804f32ce8e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aeeb02ffe09cbab0f33f013804f32ce8e">buf_get_total_list_len</a> (ulint *LRU_len, ulint *free_len, ulint *flush_list_len)</td></tr>
<tr class="memitem:aa68fb2e98dd06f51f607d86e5e68505f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#aa68fb2e98dd06f51f607d86e5e68505f">buf_get_total_list_size_in_bytes</a> (<a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *buf_pools_list_size)</td></tr>
<tr class="memitem:a1cb3cc3b0face86f802cc1e827c18c23"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a1cb3cc3b0face86f802cc1e827c18c23">buf_get_total_stat</a> (<a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *tot_stat)</td></tr>
<tr class="memitem:adfcde42037dc3ee66cfe5e74fad1c015"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#adfcde42037dc3ee66cfe5e74fad1c015">buf_get_nth_chunk_block</a> (const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, ulint n, ulint *chunk_size)</td></tr>
<tr class="memitem:a2c09491b9228b827cab2f286adc944f6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a2c09491b9228b827cab2f286adc944f6">buf_flush_update_zip_checksum</a> (<a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *page, ulint zip_size, lsn_t lsn)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3fdf9e142c6096556e3722d7c91b9065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#a3fdf9e142c6096556e3722d7c91b9065">buf_pool_ptr</a></td></tr>
<tr class="memitem:ad1ad6c1630b263389d0b8a6b5192f591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0buf_8h.html#ad1ad6c1630b263389d0b8a6b5192f591">buf_debug_prints</a></td></tr>
<tr class="memitem:a452192bad51b10d706636c8a9fb7c44f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a452192bad51b10d706636c8a9fb7c44f"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>srv_buf_pool_instances</b></td></tr>
<tr class="memitem:adced4ce61b895a42d583c60713334e76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adced4ce61b895a42d583c60713334e76"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>srv_buf_pool_curr_size</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The database buffer pool high-level routines</p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="ab992c7712a4353abf34bfafbe3a6431a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_buf_fix_inc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8ic.html#aac193f180fc2dea1a6daf0a133e4977b">buf_block_buf_fix_inc_func</a>(f,l,b)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Increments the bufferfix count.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>in/out: block to bufferfix </td></tr>
    <tr><td class="paramname">f</td><td>in: file name where requested </td></tr>
    <tr><td class="paramname">l</td><td>in: line number where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78b0bcde049a4c30e62ec696daa55dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_get_page_zip</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a></td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)-&gt;page.zip.data ? &amp;(<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)-&gt;page.zip : NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the compressed page descriptor corresponding to an uncompressed page if applicable. </p>

</div>
</div>
<a class="anchor" id="a58b9bdc92869c7be41c65d4013151b41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_mutex_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        mutex_enter(&amp;(b)-&gt;mutex);                       \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Acquire the block-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="a416662e2711051d765dc9bf811a7237d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_mutex_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        mutex_exit(&amp;(b)-&gt;mutex);                                \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Release the trx-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="ac646c8d55412a81a0ad6285ec65cea0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_mutex_own</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;(b)-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if block-&gt;mutex is owned. </p>

</div>
</div>
<a class="anchor" id="aa20f5c2f2899db5e3414580b07b50ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_block_state_valid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="buf0buf_8h.html#aa88fbb80cef26e86eddb323817c36c46">buf_block_get_state</a>(<a class="code" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>) &gt;= <a class="code" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c">BUF_BLOCK_NOT_USED</a>               \</div>
<div class="line"> &amp;&amp; (<a class="code" href="buf0buf_8h.html#aa88fbb80cef26e86eddb323817c36c46">buf_block_get_state</a>(<a class="code" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>) &lt;= <a class="code" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87">BUF_BLOCK_REMOVE_HASH</a>))</div>
</div><!-- fragment --><pre class="fragment">Check if a buf_block_t object is in a valid state
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>buffer block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if valid </dd></dl>

</div>
</div>
<a class="anchor" id="a095adbc797576159cfc092fb6bdedeb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        mutex_enter(&amp;b-&gt;flush_list_mutex);              \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Acquire the flush list mutex. </p>

</div>
</div>
<a class="anchor" id="aaefd70716bf3351e09b6e52ea9ca6783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        mutex_exit(&amp;b-&gt;flush_list_mutex);               \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Release the flush list mutex. </p>

</div>
</div>
<a class="anchor" id="a7134f85ae33367e8860b6814c0866ff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_flush_list_mutex_own</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;b-&gt;flush_list_mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if flush list mutex is owned. </p>

</div>
</div>
<a class="anchor" id="a44fc9fa4746274dad06b2d1f32ff8fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get always </p>

</div>
</div>
<a class="anchor" id="abdb9afd2ef5fbd22769359c7db3b5a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_IF_IN_POOL&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get if in pool </p>

</div>
</div>
<a class="anchor" id="a73c317958672e1b1988e08f8ed5b3ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_IF_IN_POOL_OR_WATCH&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the page only if it's in the buffer pool, if not then set a watch on the page. </p>

</div>
</div>
<a class="anchor" id="ac8df476ac2b95ad8c0d25d3ed4fca43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_NO_LATCH&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get and bufferfix, but set no latch; we have separated this case, because it is error-prone programming not to set a latch, and it should be used with care </p>

</div>
</div>
<a class="anchor" id="ad9efb1ed3aec51fd0280fb58175c4e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_GET_POSSIBLY_FREED&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like BUF_GET, but do not mind if the file page has been freed. </p>

</div>
</div>
<a class="anchor" id="a4a372deecff68a38a16714d7c404843b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_KEEP_OLD&#160;&#160;&#160;52</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preserve the current LRU position of the block. </p>

</div>
</div>
<a class="anchor" id="a2982b27f638be922b0f0be0fa6eecc98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_MAKE_YOUNG&#160;&#160;&#160;51</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the block to the start of the LRU list if there is a danger that the block would drift out of the buffer pool </p>

</div>
</div>
<a class="anchor" id="aa96b185c83ee3675e19cdd7195f0529c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_NO_CHECKSUM_MAGIC&#160;&#160;&#160;0xDEADBEEFUL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Magic value to use instead of checksums when they are disabled </p>

</div>
</div>
<a class="anchor" id="af42256ee94cebb3086096244fcbb872d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SP, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ZS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OF, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MTR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="buf0buf_8h.html#a35978421b8e05e91ad4f4bd48b1db416">buf_page_get_gen</a>(\</div>
<div class="line">                                SP, ZS, OF, LA, NULL,\</div>
<div class="line">                                <a class="code" href="buf0buf_8h.html#a44fc9fa4746274dad06b2d1f32ff8fc1">BUF_GET</a>, __FILE__, __LINE__, MTR)</div>
</div><!-- fragment --><p>NOTE! The following macros should be used instead of buf_page_get_gen, to improve debugging. Only values RW_S_LATCH and RW_X_LATCH are allowed in LA! </p>

</div>
</div>
<a class="anchor" id="af639cf80c7c2a48521049a8235425703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_get_with_no_latch</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SP, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ZS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OF, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MTR&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="buf0buf_8h.html#a35978421b8e05e91ad4f4bd48b1db416">buf_page_get_gen</a>(\</div>
<div class="line">                                SP, ZS, OF, RW_NO_LATCH, NULL,\</div>
<div class="line">                                <a class="code" href="buf0buf_8h.html#ac8df476ac2b95ad8c0d25d3ed4fca43e">BUF_GET_NO_LATCH</a>, __FILE__, __LINE__, MTR)</div>
</div><!-- fragment --><p>Use these macros to bufferfix a page with no latching. Remember not to read the contents of the page unless you know it is safe. Do not modify the contents of the page! We have separated this case, because it is error-prone programming not to set a latch, and it should be used with care. </p>

</div>
</div>
<a class="anchor" id="aeb1399574113871a8846a75eefeffde6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="hash0hash_8ic.html#ac2c915b43186f53f8c63dfd22bf4562c">hash_get_lock</a>(b-&gt;page_hash, f)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get appropriate page_hash_lock. </p>

</div>
</div>
<a class="anchor" id="a4ac5aa316025e85f6d819661845771c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_s</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="sync0rw_8h.html#aee0428509dd1bcc1d9120bda297806ec">rw_lock_own</a>(<a class="code" href="buf0buf_8h.html#aeb1399574113871a8846a75eefeffde6">buf_page_hash_lock_get</a>(b,           \</div>
<div class="line">                  <a class="code" href="buf0buf_8h.html#ad5aa5b06ebe41fd91c97723a2b074763">buf_page_address_fold</a>(p-&gt;space,       \</div>
<div class="line">                                        p-&gt;offset)),    \</div>
<div class="line">                                        RW_LOCK_SHARED)</div>
</div><!-- fragment --><p>Test if page_hash lock is held in s-mode. </p>

</div>
</div>
<a class="anchor" id="af721dd9d066797337b9fd5da6297ff2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_s_or_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="buf0buf_8h.html#a4ac5aa316025e85f6d819661845771c2">buf_page_hash_lock_held_s</a>(b, p)                \</div>
<div class="line">         || <a class="code" href="buf0buf_8h.html#a6c180fb2c8fe2d7cd550a0271ce7da52">buf_page_hash_lock_held_x</a>(b, p))</div>
</div><!-- fragment --><p>Test if page_hash lock is held in x or s-mode. </p>

</div>
</div>
<a class="anchor" id="a6c180fb2c8fe2d7cd550a0271ce7da52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_hash_lock_held_x</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="sync0rw_8h.html#aee0428509dd1bcc1d9120bda297806ec">rw_lock_own</a>(<a class="code" href="buf0buf_8h.html#aeb1399574113871a8846a75eefeffde6">buf_page_hash_lock_get</a>(b,           \</div>
<div class="line">                  <a class="code" href="buf0buf_8h.html#ad5aa5b06ebe41fd91c97723a2b074763">buf_page_address_fold</a>(p-&gt;space,       \</div>
<div class="line">                                        p-&gt;offset)),    \</div>
<div class="line">                                        RW_LOCK_EX)</div>
</div><!-- fragment --><p>Test if page_hash lock is held in x-mode. </p>

</div>
</div>
<a class="anchor" id="a8164aaa09f898842fd978f6fd4797cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PAGE_STATE_BITS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The common buffer control block structure
</pre><p> for compressed and uncompressed frames Number of bits used for buffer page states. </p>

</div>
</div>
<a class="anchor" id="aab831f92f719df32c428a1e46c0f5e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_page_try_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a2ecdc5cbcd0ed4554e3dfd1dfe96d452">buf_page_try_get_func</a>(space_id, page_no, __FILE__, __LINE__, mtr);</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Tries to get a page. If the page is not in the buffer pool it is
</pre><p> not loaded. Suitable for using when holding the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: tablespace id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the page if in buffer pool, NULL if not </dd></dl>

</div>
</div>
<a class="anchor" id="a2266e9f454c211c7eaf63ee4b2799383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_PEEK_IF_IN_POOL&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get if in pool, do not make the block young in the LRU list </p>

</div>
</div>
<a class="anchor" id="af684e31863d4f9f57dffae52b7895653"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_is_block_lock</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a>((const void*)(l))</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find out if a pointer corresponds to a buf_block_t::lock.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>in: rw-lock candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if l is a <a class="el" href="structbuf__block__t.html#a84194c0e8cc98af09907235f52e7ae16">buf_block_t::lock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3b4fc4c67b20026d078f0a22bf5be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_is_block_mutex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="buf0buf_8h.html#a0cabada29220f8ab778c3d5d849772f5">buf_pointer_is_block_field</a>((const void*)(m))</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find out if a pointer corresponds to a buf_block_t::mutex.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>in: mutex candidate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if m is a <a class="el" href="structbuf__block__t.html#a633e35f46dcb07789f728c15d020fd75">buf_block_t::mutex</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab38d13c8b2fc9bb6f83dca458cb13e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_mutex_enter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        ut_ad(!<a class="code" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;b-&gt;zip_mutex));               \</div>
<div class="line">        mutex_enter(&amp;b-&gt;mutex);                         \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Acquire a buffer pool mutex. </p>

</div>
</div>
<a class="anchor" id="a660aa390cd79424e2a7022085eb49b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_mutex_exit</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        ut_a(!b-&gt;mutex_exit_forbidden);         \</div>
<div class="line">        mutex_exit(&amp;b-&gt;mutex);                  \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Release the buffer pool mutex. </p>

</div>
</div>
<a class="anchor" id="a7cc33ac578b47cdf7e0d462abef5c130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_mutex_exit_allow</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {    \</div>
<div class="line">        ut_ad(<a class="code" href="buf0buf_8h.html#af996360800fd59fb8681a329ad2575bf">buf_pool_mutex_own</a>(b));           \</div>
<div class="line">        ut_a(b-&gt;mutex_exit_forbidden);  \</div>
<div class="line">        b-&gt;mutex_exit_forbidden--;              \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Allow the release of the buffer pool mutex. </p>

</div>
</div>
<a class="anchor" id="a912f55f1a0e191784595b0efd57b5658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_mutex_exit_forbid</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {    \</div>
<div class="line">        ut_ad(<a class="code" href="buf0buf_8h.html#af996360800fd59fb8681a329ad2575bf">buf_pool_mutex_own</a>(b));           \</div>
<div class="line">        b-&gt;mutex_exit_forbidden++;              \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Forbid the release of the buffer pool mutex. </p>

</div>
</div>
<a class="anchor" id="af996360800fd59fb8681a329ad2575bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define buf_pool_mutex_own</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;b-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if a buffer pool mutex is owned. </p>

</div>
</div>
<a class="anchor" id="a43a4f552119eafa1c0c2b71404c50ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_WATCH_SIZE&#160;&#160;&#160;(srv_n_purge_threads + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of concurrent buffer pool watches </p>

</div>
</div>
<a class="anchor" id="acf241fbcf516b9cd38017fbf9a7d211b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUF_POOL_ZIP_FOLD_PTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;((ulint) (ptr) / <a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the hash fold value for blocks in buf_pool-&gt;zip_hash. </p>

</div>
</div>
<a class="anchor" id="a1082f72aaa5cd92502df0cd9b0506195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUFFER_POOLS&#160;&#160;&#160;(1 &lt;&lt; <a class="el" href="buf0buf_8h.html#a1eb6deaefa35074b65922f2751143b76">MAX_BUFFER_POOLS_BITS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of buffer pools that can be defined </p>

</div>
</div>
<a class="anchor" id="a1eb6deaefa35074b65922f2751143b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUFFER_POOLS_BITS&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of bits to representing a buffer pool ID </p>

</div>
</div>
<a class="anchor" id="a54dcea5e3b5d7216b50559eabf13ae9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_PAGE_HASH_LOCKS&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of page_hash locks </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="aa6098ccc0d0f4a65b3bdfcb0d430ba46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#aa6098ccc0d0f4a65b3bdfcb0d430ba46">buf_page_print_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa6098ccc0d0f4a65b3bdfcb0d430ba46a4de99c6b59acbd5c2aa46fd0632cb281"></a>BUF_PAGE_PRINT_NO_CRASH</em>&nbsp;</td><td>
<p>Do not crash at the end of <a class="el" href="buf0buf_8h.html#a8341706850d2b0af4b44208afc8c1718">buf_page_print()</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6098ccc0d0f4a65b3bdfcb0d430ba46a476478124a1ec5bbf5faa153d2ff4763"></a>BUF_PAGE_PRINT_NO_FULL</em>&nbsp;</td><td>
<p>Do not print the full page dump. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>States of a control block. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structbuf__page__t.html">buf_page_t</a></dd></dl>
<p>The enumeration values must be 0..7. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aaa5d948d8c9ee109afa2f2b05672a3930"></a>BUF_BLOCK_POOL_WATCH</em>&nbsp;</td><td>
<p>a sentinel for the buffer pool watch, element of buf_pool-&gt;watch[] </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aa21e9fab74d2c9e64609dd53570bdfaec"></a>BUF_BLOCK_ZIP_PAGE</em>&nbsp;</td><td>
<p>contains a clean compressed page </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aa9135ba69991c7e4a4943f289de621509"></a>BUF_BLOCK_ZIP_DIRTY</em>&nbsp;</td><td>
<p>contains a compressed page that is in the buf_pool-&gt;flush_list </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aa0d31b0fc25c2381e6f6d59e7eb671f7c"></a>BUF_BLOCK_NOT_USED</em>&nbsp;</td><td>
<p>is in the free list; must be after the BUF_BLOCK_ZIP_ constants for compressed-only pages </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="buf0buf_8h.html#aa20f5c2f2899db5e3414580b07b50ed9">buf_block_state_valid()</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aad5dffb35305e497c0afd120525221d18"></a>BUF_BLOCK_READY_FOR_USE</em>&nbsp;</td><td>
<p>when buf_LRU_get_free_block returns a block, it is in this state </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aaf26cdfc58e629f98cf27da284f6cf5f9"></a>BUF_BLOCK_FILE_PAGE</em>&nbsp;</td><td>
<p>contains a buffered file page </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aa7278567ff34beb6c693af5267611c4c7"></a>BUF_BLOCK_MEMORY</em>&nbsp;</td><td>
<p>contains some main memory object </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab8edfb8ad98167f82518879ade67dc8aa3eeed1a3010bb586fc0fa54581a9ef87"></a>BUF_BLOCK_REMOVE_HASH</em>&nbsp;</td><td>
<p>hash index should be removed before putting to the free list </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a6f9e1d761f5c154cf5c5ab26a07c6444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_all_freed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asserts that all file pages in the buffer are in a replaceable state. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE </dd></dl>

</div>
</div>
<a class="anchor" id="a856825cf58c3701a4654dde470217932"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_align </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the block to whose frame the pointer is pointing to. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to block, never NULL in: pointer to a frame </dd></dl>

</div>
</div>
<a class="anchor" id="af1364bb9b989dc1f07c913b14f29a9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the allocated block, in state BUF_BLOCK_MEMORY in: buffer pool instance, or NULL for round-robin selection of the buffer pool </dd></dl>

</div>
</div>
<a class="anchor" id="a2c94e35b115562bb13cdad1016ba9937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_buf_fix_inc_func </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block to bufferfix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f5e1ca4adc326a3240f16b494f38aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_dbg_add_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds latch level info for the rw-lock protecting the buffer frame. This should be called in the debug version after a successful latching of a page if we know the latching order level of the acquired latch. in: latching order level</p>
<p>Adds latch level info for the rw-lock protecting the buffer frame. This should be called in the debug version after a successful latching of a page if we know the latching order level of the acquired latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer page where we have acquired latch </td></tr>
    <tr><td class="paramname">level</td><td>in: latching order level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72a343e7650c641f8d1ccedc95f632a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the bufferfix count. in/out: block to bufferfix</p>
<p>Increments the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block to bufferfix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58d8810e5f830e55bdf31da6b88972ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a buffer block which does not contain a file page. in, own: block to be freed</p>
<p>Frees a buffer block which does not contain a file page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in, own: block to be freed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d369eb98363c43512a7f74c024a6381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a>* buf_block_get_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the memory frame of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the frame </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7093bd2038fedbf233dabd7488363e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_freed_page_clock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the freed_page_clock of a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>freed_page_clock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8211423df81edc2a582ac2adaeb2cdd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_block_get_io_fix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the io_fix state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>io_fix state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad07f334ac0e6ac453d69aec198aa9bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_lock_hash_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the hash value of a block. This can be used in searches in the lock hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>lock hash value</dd></dl>
<p>Gets the hash value of the page the pointer is pointing to. This can be used in searches in the lock hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>lock hash value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b8e1e6da6d695762349b237dadcd982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ib_uint64_t buf_block_get_modify_clock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the modify clock. The caller must have an s-lock or x-lock on the block. </p>
<dl class="section return"><dt>Returns</dt><dd>value in: block</dd></dl>
<p>Returns the value of the modify clock. The caller must have an s-lock or x-lock on the block. </p>
<dl class="section return"><dt>Returns</dt><dd>value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa58f9b6f6ee178d4b9104f0b7623d750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the page number of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34b3552c9e5e4c09355d193a3f4bd573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the space id of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>space id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa88fbb80cef26e86eddb323817c36c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> buf_block_get_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bc2133ef2d7bcfc9f4c0a80932cef36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_block_get_zip_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the compressed page size of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>compressed page size, or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98c52dccde10bc29a162cb815c0e03c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_block_hash_get_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the control block of a file page, NULL if not found. If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found in: RW_LOCK_EX or RW_LOCK_SHARED. Ignored if lock == NULL</dd></dl>
<p>Returns the control block of a file page, NULL if not found. If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>out: pointer to the bpage, or NULL; if NULL, hash_lock is also NULL. buffer pool instance </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: lock of the page hash acquired if bpage is found. NULL otherwise. If NULL is passed then the hash_lock is released by this function </td></tr>
    <tr><td class="paramname">lock_mode</td><td>in: RW_LOCK_EX or RW_LOCK_SHARED. Ignored if lock == NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab0fe6ab9881b94fe49c82d25dbe819a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_modify_clock_inc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the modify clock of a frame by 1. The caller must (1) own the buf_pool-&gt;mutex and block bufferfix count has to be zero, (2) or own an x-lock on the block. in: block</p>
<p>Increments the modify clock of a frame by 1. The caller must (1) own the buf_pool mutex and block bufferfix count has to be zero, (2) or own an x-lock on the block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5fe5c9c1a1090dc7c5f05dec606a8a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_file_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map a block to a file page. in: page number</p>
<p>Map a block to a file page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: pointer to control block </td></tr>
    <tr><td class="paramname">space</td><td>in: tablespace id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a427515122e86a7b344f79896801f30cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_io_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_fix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the io_fix state of a block. in: io_fix state</p>
<p>Sets the io_fix state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: control block </td></tr>
    <tr><td class="paramname">io_fix</td><td>in: io_fix state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a542cb040a75435f73008c7009d9a908b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the state of a block. in: state</p>
<p>Sets the state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: pointer to control block </td></tr>
    <tr><td class="paramname">state</td><td>in: state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a760064e6e2e6277c43a1af888fbbaafb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_block_unfix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments the bufferfix count. in/out: block to bufferfix</p>
<p>Decrements the bufferfix count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block to bufferunfix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c09491b9228b827cab2f286adc944f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_flush_update_zip_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the checksum of a page from compressed table and update the page. in: Lsn to stamp on the page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>in/out: Page to update </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: Compressed page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70c8e79f9fad932a3f06f1edf84c2147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE byte* buf_frame_copy </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="buf0types_8h.html#a03c346e355d639f165c311ad5946b3e2">buf_frame_t</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies contents of a buffer frame to a given buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>buf in: buffer frame</dd></dl>
<p>Copies contents of a buffer frame to a given buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>buf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in: buffer to copy to </td></tr>
    <tr><td class="paramname">frame</td><td>in: buffer frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cb587a6d2459041dbfc44abda970bae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a>* buf_frame_get_page_zip </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the compressed page descriptor corresponding to an uncompressed page if applicable. </p>
<dl class="section return"><dt>Returns</dt><dd>compressed page descriptor, or NULL in: pointer to the page</dd></dl>
<p>Gets the compressed page descriptor corresponding to an uncompressed page if applicable. </p>
<dl class="section return"><dt>Returns</dt><dd>compressed page descriptor, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to the page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a851c5c02d091e973f63e3d3fea5514ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_free_list_len </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current length of the free list of buffer blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>length of the free list </dd></dl>

</div>
</div>
<a class="anchor" id="af4b823851e97551f1a9c7e7952f887ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_latched_pages_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of latched pages in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of latched pages </dd></dl>

</div>
</div>
<a class="anchor" id="ab66718ee074230bc14001aee57e5044a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_modified_ratio_pct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the ratio in percents of modified pages in the buffer pool / database pages in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>modified page percentage ratio </dd></dl>

</div>
</div>
<a class="anchor" id="aa81cf5958ac70dc03d2bd8c69b355975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_get_n_pending_read_ios </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of pending buf pool read ios. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending read I/O operations </dd></dl>

</div>
</div>
<a class="anchor" id="adfcde42037dc3ee66cfe5e74fad1c015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_get_nth_chunk_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>chunk_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the nth chunk's buffer block in the specified buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>the nth chunk's buffer block. in: chunk size</dd></dl>
<p>Get the nth chunk's buffer block in the specified buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>the nth chunk's buffer block. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
    <tr><td class="paramname">n</td><td>in: nth chunk in the buffer pool </td></tr>
    <tr><td class="paramname">chunk_size</td><td>in: chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeeb02ffe09cbab0f33f013804f32ce8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_list_len </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>LRU_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>free_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>flush_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total buffer pool statistics. out: length of all flush lists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LRU_len</td><td>out: length of all LRU lists </td></tr>
    <tr><td class="paramname">free_len</td><td>out: length of all free lists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa68fb2e98dd06f51f607d86e5e68505f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_list_size_in_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pools__list__size__t.html">buf_pools_list_size_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pools_list_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total list size in bytes from all buffer pools. out: list sizes in all buffer pools </p>

</div>
</div>
<a class="anchor" id="a1cb3cc3b0face86f802cc1e827c18c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_get_total_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__stat__t.html">buf_pool_stat_t</a> *&#160;</td>
          <td class="paramname"><em>tot_stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total buffer pool statistics. out: buffer pool stats </p>

</div>
</div>
<a class="anchor" id="ad5aa5b06ebe41fd91c97723a2b074763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_address_fold </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a folded value of a file page address to use in the page hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>the folded value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of the page within space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a693e861ee761ae35f0be48fea286a1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_alloc_descriptor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a <a class="el" href="structbuf__page__t.html">buf_page_t</a> descriptor. This function must succeed. In case of failure we assert in this function.</p>
<p>Allocates a <a class="el" href="structbuf__page__t.html">buf_page_t</a> descriptor. This function must succeed. In case of failure we assert in this function. </p>
<dl class="section return"><dt>Returns</dt><dd>: the allocated descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d57411802ceb05bcde2f18a74f64117"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_belongs_to_unzip_LRU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a block should be on unzip_LRU list. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if block belongs to unzip_LRU </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dd9e8f0cf154f2e5acd92ff4585697b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_can_relocate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a buffer block can be relocated in memory. The block can be dirty, but it must not be I/O-fixed or bufferfixed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>control block being relocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa46fda4f90104f3919b4577d11caf957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a page to the buffer buf_pool. The page is usually not read from a file even if it cannot be found in the buffer buf_pool. This is one of the functions which perform to a block a state transition NOT_USED =&gt; FILE_PAGE (the other is buf_page_get_gen). </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block, page bufferfixed in: mini-transaction handle </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of the page within space in units of a page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a487f5b2e7a030166033d79086d0be585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_free_descriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a <a class="el" href="structbuf__page__t.html">buf_page_t</a> descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: bpage descriptor to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3588ddc8b6ec0c971bbfc6beed52cbeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="structbuf__block__t.html">buf_block_t</a> handle of a buffered file block if an uncompressed page frame exists, or NULL. Note: even though bpage is not declared a const we don't update its value. It is safe to make this pure. </p>
<dl class="section return"><dt>Returns</dt><dd>control block, or NULL</dd></dl>
<p>Gets the <a class="el" href="structbuf__block__t.html">buf_block_t</a> handle of a buffered file block if an uncompressed page frame exists, or NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>control block, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06fd3f2072036f03082b0373a77ca296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> buf_page_get_flush_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the flush type of a page. </p>
<dl class="section return"><dt>Returns</dt><dd>flush type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46271b3a89ac82366873b9760feb3cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_get_freed_page_clock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the freed_page_clock of a buffer block. </p>
<dl class="section return"><dt>Returns</dt><dd>freed_page_clock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35978421b8e05e91ad4f4bd48b1db416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_get_gen </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the general function used to get access to a database page. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL in: mini-transaction </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size in bytes or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
    <tr><td class="paramname">guess</td><td>in: guessed block or NULL </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_GET, BUF_GET_IF_IN_POOL, BUF_PEEK_IF_IN_POOL, BUF_GET_NO_LATCH or BUF_GET_IF_IN_POOL_OR_WATCH </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f71eede4d9217492ffabd8fcfc7f584"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a> buf_page_get_io_fix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the io_fix state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>io_fix state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa084c3df8c4e1390fc8389cdc639e69b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_get_known_nowait </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to get access to a known database page, when no waiting can be done. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success in: mini-transaction </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramname">block</td><td>in: the known page </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_MAKE_YOUNG or BUF_KEEP_OLD </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aeabb407e37058610eda62ebf0c1f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structib__mutex__t.html">ib_mutex_t</a>* buf_page_get_mutex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the mutex of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to mutex protecting bpage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5df3bda5bcc128a66ddb88607f7aa7fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lsn_t buf_page_get_newest_modification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the youngest modification log sequence number for a frame. Returns zero if not file page or no modification occurred yet. </p>
<dl class="section return"><dt>Returns</dt><dd>newest modification to page in: block containing the page frame</dd></dl>
<p>Gets the youngest modification log sequence number for a frame. Returns zero if not file page or no modification occurred yet. </p>
<dl class="section return"><dt>Returns</dt><dd>newest modification to page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block containing the page frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05bc307775a024942a188827f67bf31b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_get_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the page number of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6daca7f7e50ec0c81d6a7094b3f65ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_get_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the space id of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>space id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a99189b090a1af68ff81b98b5418a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a> buf_page_get_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>state in: pointer to the control block</dd></dl>
<p>Gets the state of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>state </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba8580c21048bc75fc52fcf1b14f7b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_get_zip </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get read access to a compressed page (usually of type FIL_PAGE_TYPE_ZBLOB or FIL_PAGE_TYPE_ZBLOB2). The page must be released with <a class="el" href="buf0buf_8h.html#a6ce5d2fc2911e993640a50d360670592">buf_page_release_zip()</a>. NOTE: the page is not protected by any latch. Mutual exclusion has to be implemented at a higher level. In other words, all possible accesses to a given page through this function must be protected by the same set of mutexes or latches. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block, or NULL if not compressed in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2b21229dc8724079d645ca77d0e6ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_page_get_zip_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the compressed page size of a block. </p>
<dl class="section return"><dt>Returns</dt><dd>compressed page size, or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to the control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ccd6c8cf03c0134b095b2f0d97c5eea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_hash_get_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> **&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>watch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the control block of a file page, NULL if not found. If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found, or watch sentinel (if watch is true) in: if true, return watch sentinel also.</dd></dl>
<p>Returns the control block of a file page, NULL if not found. If the block is found and lock is not NULL then the appropriate page_hash lock is acquired in the specified lock mode. Otherwise, mode value is ignored. It is up to the caller to release the lock. If the block is found and the lock is NULL then the page_hash lock is released by this function. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found, or watch sentinel (if watch is true) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>out: pointer to the bpage, or NULL; if NULL, hash_lock is also NULL. buffer pool instance </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: lock of the page hash acquired if bpage is found. NULL otherwise. If NULL is passed then the hash_lock is released by this function </td></tr>
    <tr><td class="paramname">lock_mode</td><td>in: RW_LOCK_EX or RW_LOCK_SHARED. Ignored if lock == NULL </td></tr>
    <tr><td class="paramname">watch</td><td>in: if true, return watch sentinel also. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e4bd838178ed27ad3f174ac5084390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_hash_get_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the control block of a file page, NULL if not found. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found in: buf_page_address_fold(space, offset)</dd></dl>
<p>Returns the control block of a file page, NULL if not found. </p>
<dl class="section return"><dt>Returns</dt><dd>block, NULL if not found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of the page within space </td></tr>
    <tr><td class="paramname">fold</td><td>in: buf_page_address_fold(space, offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a905320d982d927f5d1bd2fad94e5742f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_in_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a block is mapped to a tablespace. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if mapped </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: pointer to control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6424ffc76b8af1be289e341334f14905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_init_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>unzip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_int64_t&#160;</td>
          <td class="paramname"><em>tablespace_version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function which inits a page for read to the buffer buf_pool. If the page is (1) already in buf_pool, or (2) if we specify to read only ibuf pages and the page is not an ibuf page, or (3) if the space is deleted or being deleted, then this function does nothing. Sets the io_fix flag to BUF_IO_READ and sets a non-recursive exclusive lock on the buffer frame. The io-handler must take care that the flag is cleared and the lock released later. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the block or NULL in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: DB_SUCCESS or DB_TABLESPACE_DELETED </td></tr>
    <tr><td class="paramname">mode</td><td>in: BUF_READ_IBUF_PAGES_ONLY, ... </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 </td></tr>
    <tr><td class="paramname">unzip</td><td>in: TRUE=request uncompressed page </td></tr>
    <tr><td class="paramname">tablespace_version</td><td>in: prevents reading from a wrong version of the tablespace in case we have done DISCARD + IMPORT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b42a085941cbde456551be2ebf514c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool buf_page_io_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes an asynchronous read or write request of a file page to or from the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>true if successful in: pointer to the block in question </dd></dl>

</div>
</div>
<a class="anchor" id="a5353bcf06b39c283357373a2c9e4be0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE unsigned buf_page_is_accessed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the time of first access of a block in the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="ut0ut_8h.html#a179d6f4646ca97d7bf70bbfd3a1890be">ut_time_ms()</a> at the time of first access, 0 if not accessed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb0398f2f98a2fe3462072dba70fb4cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_is_corrupted </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is corrupt. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if corrupted </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">check_lsn</td><td>in: true if we need to check the and complain about the LSN </td></tr>
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: size of compressed page; 0 for uncompressed pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b069f2b5e2c8209b6b0299f2bbc1830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_is_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a block has been flagged old. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if old </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc3917d4a5b0630a356a9d244886ebf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool buf_page_is_zeroes </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a page is all zeroes. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the page is all zeroes in: size of compressed page; 0 for uncompressed pages </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fb94effb9f9c0de7b40c07a91ceee16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_page_make_young </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves a page to the start of the buffer pool LRU list. This high-level function can be used to prevent an important page from slipping out of the buffer pool. in: buffer block of a file page </p>

</div>
</div>
<a class="anchor" id="a4b2249b3ba3868dc2afd2ebea3480a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_optimistic_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>modify_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the general function used to get optimistic access to a database page. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success in: mini-transaction </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH </td></tr>
    <tr><td class="paramname">block</td><td>in: guessed block </td></tr>
    <tr><td class="paramname">modify_clock</td><td>in: modify clock value </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a101528fa6fbcef8e22c11b63bf8bff28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_peek </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if the page can be found in the buffer pool hash table.</p>
<p>NOTE that it is possible that the page is not yet read from disk, though.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if found in the page hash table in: page number</dd></dl>
<p>Returns TRUE if the page can be found in the buffer pool hash table.</p>
<p>NOTE that it is possible that the page is not yet read from disk, though.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if found in the page hash table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bcc2e01e4ffe6abf420008166b1062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_peek_if_too_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recommends a move of a block to the start of the LRU list if there is danger of dropping from the buffer pool. NOTE: does not reserve the buffer pool mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if should be made younger in: block to make younger</dd></dl>
<p>Recommends a move of a block to the start of the LRU list if there is danger of dropping from the buffer pool. NOTE: does not reserve the buffer pool mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if should be made younger </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block to make younger </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47ffed634c26feb6e975600b553e48c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_page_peek_if_young </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells if a block is still close enough to the MRU end of the LRU list meaning that it is not in danger of getting evicted and also implying that it has been accessed recently. Note that this is for heuristics only and does not reserve buffer pool mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if block is close to MRU end of LRU in: block</dd></dl>
<p>Tells if a block is still close enough to the MRU end of the LRU list meaning that it is not in danger of getting evicted and also implying that it has been accessed recently. Note that this is for heuristics only and does not reserve buffer pool mutex. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if block is close to MRU end of LRU </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8341706850d2b0af4b44208afc8c1718"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_page_print </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>read_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a page to stderr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_buf</td><td>in: a database page </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: compressed page size, or 0 for uncompressed pages </td></tr>
    <tr><td class="paramname">flags</td><td>in: 0 or BUF_PAGE_PRINT_NO_CRASH or BUF_PAGE_PRINT_NO_FULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61e2f995432617daf7c32b633d61055f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>rw_latch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements the bufferfix count of a buffer control block and releases a latch, if specified. in: RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH</p>
<p>Decrements the bufferfix count of a buffer control block and releases a latch, if specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">rw_latch</td><td>in: RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ce5d2fc2911e993640a50d360670592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_release_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a compressed-only page acquired with <a class="el" href="buf0buf_8h.html#aba8580c21048bc75fc52fcf1b14f7b2d">buf_page_get_zip()</a>. in: buffer block</p>
<p>Releases a compressed-only page acquired with <a class="el" href="buf0buf_8h.html#aba8580c21048bc75fc52fcf1b14f7b2d">buf_page_get_zip()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9292fa36d7601927df112e3ab42a1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_reset_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets file_page_was_freed FALSE if the page is found in the buffer pool. This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84322a8e0b7d690e53e1364b72e91ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_accessed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag a block accessed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8db60f41f12aff8aebb7e53e6c014011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_page_set_file_page_was_freed </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets file_page_was_freed TRUE if the page is found in the buffer pool. This function should be called when we free a file page and want the debug version to check that it is not accessed any more unless reallocated. </p>
<dl class="section return"><dt>Returns</dt><dd>control block if found in page hash table, otherwise NULL in: page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53437d54ec990de81e9644d3ee6c4337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_flush_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the flush type of a page. in: flush type</p>
<p>Set the flush type of a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer page </td></tr>
    <tr><td class="paramname">flush_type</td><td>in: flush type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1a8f29ac35531394d5cc6abb4e7bc2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_io_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0types_8h.html#a9d992d311e12fe579c419e7f98f80e27">buf_io_fix</a>&#160;</td>
          <td class="paramname"><em>io_fix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the io_fix state of a block. in: io_fix state</p>
<p>Sets the io_fix state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block </td></tr>
    <tr><td class="paramname">io_fix</td><td>in: io_fix state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acaf46d5fc3b73bc26bf115615fb81d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_old </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag a block old. in: old</p>
<p>Flag a block old. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block </td></tr>
    <tr><td class="paramname">old</td><td>in: old </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38ae1a9052817ce692827243ce970d3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="buf0buf_8h.html#ab8edfb8ad98167f82518879ade67dc8a">buf_page_state</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the state of a block. in: state</p>
<p>Sets the state of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: pointer to control block </td></tr>
    <tr><td class="paramname">state</td><td>in: state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafc6d1173140eb14d5ca4a83a62d0f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_set_sticky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a block sticky. A sticky block implies that even after we release the buf_pool-&gt;mutex and the block-&gt;mutex: it cannot be removed from the flush_list the block descriptor cannot be relocated it cannot be removed from the LRU list Note that: the block can still change its position in the LRU list the next and previous pointers can change. in/out: control block</p>
<p>Makes a block sticky. A sticky block implies that even after we release the buf_pool-&gt;mutex and the block-&gt;mutex: it cannot be removed from the flush_list the block descriptor cannot be relocated it cannot be removed from the LRU list Note that: the block can still change its position in the LRU list the next and previous pointers can change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ecdc5cbcd0ed4554e3dfd1dfe96d452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_page_try_get_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a tablespace id and page number tries to get that page. If the page is not in the buffer pool it is not loaded and NULL is returned. Suitable for using when holding the <a class="el" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">lock_sys_t::mutex</a>. in: mini-transaction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space_id</td><td>in: tablespace id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9b8b75af8fa0ad4e4ebb7723ec8a215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_page_unset_sticky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes stickiness of a block. in/out: control block</p>
<p>Removes stickiness of a block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cabada29220f8ab778c3d5d849772f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_pointer_is_block_field </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find out if a pointer belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a>. It can be a pointer to the <a class="el" href="structbuf__block__t.html">buf_block_t</a> itself or a member of it </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if ptr belongs to a <a class="el" href="structbuf__block__t.html">buf_block_t</a> struct in: pointer not dereferenced </dd></dl>

</div>
</div>
<a class="anchor" id="ac12113d926b18d7fd1ffef49e5d72ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint buf_pool_check_no_pending_io </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that there currently are no pending i/o-operations for the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pending i/o operations </dd></dl>

</div>
</div>
<a class="anchor" id="a5358efb915e801353ddfc12178c7331b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_clear_hash_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the adaptive hash index on all pages in the buffer pool. </p>

</div>
</div>
<a class="anchor" id="ab53bd858064780246c5d6c6141db8b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__block__t.html">buf_block_t</a>* buf_pool_contains_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a block in the buffer pool that points to a given compressed page. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer block pointing to the compressed page, or NULL in: pointer to compressed page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a32cbba300ff8f3f33bc54e47eb4360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_free </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the buffer pool at shutdown. This must not be invoked before freeing all mutexes. in: numbere of instances to free </p>

</div>
</div>
<a class="anchor" id="aac71426ec4d18966a8fa309954653b5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_array </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer pool instance given its array index </p>
<dl class="section return"><dt>Returns</dt><dd>buffer pool in: array index to get buffer pool instance from</dd></dl>
<p>Returns the buffer pool instance given its array index </p>
<dl class="section return"><dt>Returns</dt><dd>buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: array index to get buffer pool instance from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a499d41dc7d50849f883c2b06c07dbb02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer pool instance given a block instance </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool in: block</dd></dl>
<p>Returns the buffer pool instance given a block instance </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a803b791d0706583d685f7f9413da45d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_from_bpage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer pool instance given a page instance </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool in: buffer pool page</dd></dl>
<p>Returns the buffer pool instance given a page instance </p>
<dl class="section return"><dt>Returns</dt><dd>buf_pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in: buffer pool page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38f885a522c33e61c4187d08f57f55cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_get </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer pool instance given space and offset of page </p>
<dl class="section return"><dt>Returns</dt><dd>buffer pool in: offset of the page within space</dd></dl>
<p>Returns the buffer pool instance given space and offset of page </p>
<dl class="section return"><dt>Returns</dt><dd>buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: offset of the page within space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23372a7fc86173052a9bfe927c9312b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_get_curr_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current size of buffer buf_pool in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="acff3e4e95015baaa1740ff6098e6e164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_get_n_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current size of buffer buf_pool in frames. </p>
<dl class="section return"><dt>Returns</dt><dd>size in pages</dd></dl>
<p>Gets the current size of buffer buf_pool in pages. </p>
<dl class="section return"><dt>Returns</dt><dd>size in pages </dd></dl>

</div>
</div>
<a class="anchor" id="a7f96406b87de005b0234f06c369d8ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN lsn_t buf_pool_get_oldest_modification </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the smallest oldest_modification lsn for any page in the pool. Returns zero if all modified pages have been flushed to disk. </p>
<dl class="section return"><dt>Returns</dt><dd>oldest modification in pool, zero if none </dd></dl>

</div>
</div>
<a class="anchor" id="a6a25c12212deaa1d7c277f3b41aaa97d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint buf_pool_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the index of a buffer pool to the buf_pool[] array. </p>
<dl class="section return"><dt>Returns</dt><dd>the position of the buffer pool in buf_pool[] </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00594803ebde3419ce812f88294dfe20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> buf_pool_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if success, DB_ERROR if not enough memory or error in: Number of instances </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>in: Size of the total pool in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65e9d3982cda06d0032aa5dec9a3fc69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_invalidate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates the file pages in the buffer pool when an archive recovery is completed. All the file pages buffered must be in a replaceable state when this function is called: not latched and not modified. </p>

</div>
</div>
<a class="anchor" id="ac76936f6689fef74b464bb45ad40610d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_pool_mutex_enter_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquire mutex on all buffer pool instances</p>
<p>Acquire mutex on all buffer pool instances. </p>

</div>
</div>
<a class="anchor" id="a6121f55712fb2b5b574234a5a1db278c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_pool_mutex_exit_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release mutex on all buffer pool instances</p>
<p>Release mutex on all buffer pool instances. </p>

</div>
</div>
<a class="anchor" id="a2b66139edd63334363dbd329566eece9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_pool_watch_is_sentinel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a block is a sentinel for a buffer pool watch. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a sentinel for a buffer pool watch, FALSE if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramname">bpage</td><td>in: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87f2bec0d116db814ffc296eb92df589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_pool_watch_occurred </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the page has been read in. This may only be called after buf_pool_watch_set(space,offset) has returned NULL and before invoking buf_pool_watch_unset(space,offset). </p>
<dl class="section return"><dt>Returns</dt><dd>FALSE if the given page was not read in, TRUE if it was </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb122295689df731668c04d5c69bc56b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structbuf__page__t.html">buf_page_t</a>* buf_pool_watch_set </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>fold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add watch for the given page to be read in. Caller must have the buffer pool </p>
<dl class="section return"><dt>Returns</dt><dd>NULL if watch set, block if the page is in the buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">offset</td><td>in: page number </td></tr>
    <tr><td class="paramname">fold</td><td>in: buf_page_address_fold(space, offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad347338911fe564cc72f4a5f3f11a608"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_pool_watch_unset </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop watching if the page has been read in. buf_pool_watch_set(space,offset) must have returned NULL before. in: page number </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70ef2a65e5054be667ff252648a1b901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the buffer pool data structure. </p>

</div>
</div>
<a class="anchor" id="ab20138c8871f85d710230adc053943f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_print_io </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the buffer i/o. in: file where to print </p>

</div>
</div>
<a class="anchor" id="a31fb62a395c54b928a66563a73010677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_ptr_get_fsp_addr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfil__addr__t.html">fil_addr_t</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the space id, page offset, and byte offset within page of a pointer pointing to a buffer frame containing a file page. out: page offset and byte offset</p>
<p>Gets the space id, page offset, and byte offset within page of a pointer pointing to a buffer frame containing a file page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to a buffer frame </td></tr>
    <tr><td class="paramname">space</td><td>out: space id </td></tr>
    <tr><td class="paramname">addr</td><td>out: page offset and byte offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7cb16ef6711245409a7e117e6da54e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_refresh_io_stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. buffer pool instance </p>

</div>
</div>
<a class="anchor" id="a6817c8278c04718851b86d4c4a613e43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_refresh_io_stats_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the statistics used to print per-second averages. </p>

</div>
</div>
<a class="anchor" id="a35e03a01f6d0f2b961a3f0341a720f73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_relocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Relocate a buffer control block. Relocates the block on the LRU list and in buf_pool-&gt;page_hash. Does not relocate bpage-&gt;list. The caller must take care of relocating bpage-&gt;list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being relocated; buf_page_get_state(bpage) must be BUF_BLOCK_ZIP_DIRTY or BUF_BLOCK_ZIP_PAGE </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination control block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0657a55a27fb821febe21fd93c5e1bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void buf_stats_get_pool_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pool_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__pool__info__t.html">buf_pool_info_t</a> *&#160;</td>
          <td class="paramname"><em>all_pool_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect buffer pool stats information for a buffer pool. Also record aggregated stats if there are more than one buffer pool in the server in/out: buffer pool info to fill </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">pool_id</td><td>in: buffer pool ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8ea10ef89cb3d974bec6c056de295f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_validate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the buffer pool data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE </dd></dl>

</div>
</div>
<a class="anchor" id="ae97c93aa8f9ecd83bbc579fc36640ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_zip_decompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decompress a block. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if successful in: TRUE=verify the page checksum </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="ad1ad6c1630b263389d0b8a6b5192f591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> buf_debug_prints</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this is set TRUE, the program prints info whenever read or flush occurs </p>

</div>
</div>
<a class="anchor" id="a3fdf9e142c6096556e3722d7c91b9065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a>* buf_pool_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The buffer pools of the database </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:25 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
