<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: row_prebuilt_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">row_prebuilt_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for row_prebuilt_t:</div>
<div class="dyncontent">
<div class="center"><img src="structrow__prebuilt__t__coll__graph.png" border="0" usemap="#row__prebuilt__t_coll__map" alt="Collaboration graph"/></div>
<map name="row__prebuilt__t_coll__map" id="row__prebuilt__t_coll__map">
<area shape="rect" id="node2" href="structupd__node__t.html" title="upd_node_t" alt="" coords="1543,866,1639,894"/><area shape="rect" id="node4" href="structrow__ext__t.html" title="row_ext_t" alt="" coords="1249,939,1332,967"/><area shape="rect" id="node6" href="structque__common__t.html" title="que_common_t" alt="" coords="13,945,136,973"/><area shape="rect" id="node19" href="structque__fork__t.html" title="que_fork_t" alt="" coords="285,1070,373,1098"/><area shape="rect" id="node23" href="structsel__node__t.html" title="sel_node_t" alt="" coords="1245,838,1336,866"/><area shape="rect" id="node26" href="structsym__node__t.html" title="sym_node_t" alt="" coords="936,862,1035,890"/><area shape="rect" id="node60" href="structins__node__t.html" title="ins_node_t" alt="" coords="1545,349,1636,377"/><area shape="rect" id="node9" href="structdict__index__t.html" title="dict_index_t" alt="" coords="936,603,1035,631"/><area shape="rect" id="node15" href="structtrx__t.html" title="trx_t" alt="" coords="501,1102,552,1130"/><area shape="rect" id="node36" href="structdict__foreign__t.html" title="dict_foreign_t" alt="" coords="1237,785,1344,813"/><area shape="rect" id="node11" href="structdict__table__t.html" title="dict_table_t" alt="" coords="688,793,784,821"/><area shape="rect" id="node13" href="structmem__block__info__t.html" title="mem_block_info_t" alt="" coords="5,514,144,542"/><area shape="rect" id="node47" href="structbtr__pcur__t.html" title="btr_pcur_t" alt="" coords="1248,1118,1333,1146"/><area shape="rect" id="node42" href="structupd__t.html" title="upd_t" alt="" coords="1261,670,1320,698"/><area shape="rect" id="node45" href="structdtuple__t.html" title="dtuple_t" alt="" coords="948,242,1023,270"/><area shape="rect" id="node68" href="structut__list__base.html" title="ut_list_base\&lt; dtuple_t \&gt;" alt="" coords="1201,273,1380,301"/><area shape="rect" id="node56" href="structmysql__row__templ__t.html" title="mysql_row_templ_t" alt="" coords="1519,1353,1663,1381"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ad936db2921893119b95f7e33727f2d2a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad936db2921893119b95f7e33727f2d2a">magic_n</a></td></tr>
<tr class="memitem:a19c2a8205446e84d2e64f80088a7846c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a19c2a8205446e84d2e64f80088a7846c">table</a></td></tr>
<tr class="memitem:afeb88835f509e12ea05929f410f4df0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afeb88835f509e12ea05929f410f4df0a">index</a></td></tr>
<tr class="memitem:aa177d7d5264d91df66db86414dfa7da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa177d7d5264d91df66db86414dfa7da8">trx</a></td></tr>
<tr class="memitem:a1004d8c54485ba370f756c48f26d93a7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1004d8c54485ba370f756c48f26d93a7">sql_stat_start</a>:1</td></tr>
<tr class="memitem:a6abfde48ea9d8abc5c235403e2f3b022"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6abfde48ea9d8abc5c235403e2f3b022">mysql_has_locked</a>:1</td></tr>
<tr class="memitem:abd76361eda548fa2e2f8d80d66d08612"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#abd76361eda548fa2e2f8d80d66d08612">clust_index_was_generated</a>:1</td></tr>
<tr class="memitem:ac59950f1aed60deccf5ba6a917afc357"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac59950f1aed60deccf5ba6a917afc357">index_usable</a>:1</td></tr>
<tr class="memitem:aa2406d22fe6361a563ec8b4e9b010287"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa2406d22fe6361a563ec8b4e9b010287">read_just_key</a>:1</td></tr>
<tr class="memitem:a0568bf55e0cd59e39cbf5264e0107a04"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0568bf55e0cd59e39cbf5264e0107a04">used_in_HANDLER</a>:1</td></tr>
<tr class="memitem:afa6cf19178262078ea73dd92941a88ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa6cf19178262078ea73dd92941a88ca">template_type</a>:2</td></tr>
<tr class="memitem:a551a6896bb6da7d979e6fb20decf18ba"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a551a6896bb6da7d979e6fb20decf18ba">n_template</a>:10</td></tr>
<tr class="memitem:a4218e8b9331e26a43e2507663d59bdc1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4218e8b9331e26a43e2507663d59bdc1">null_bitmap_len</a>:10</td></tr>
<tr class="memitem:a94506e9f10462650bfa377f9414cf7db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a94506e9f10462650bfa377f9414cf7db">need_to_access_clustered</a>:1</td></tr>
<tr class="memitem:a666323e0b2127c47e743adf5ba2bef94"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a666323e0b2127c47e743adf5ba2bef94">templ_contains_blob</a>:1</td></tr>
<tr class="memitem:a25c5641e4244b609f7e89f11069239e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a25c5641e4244b609f7e89f11069239e5">mysql_template</a></td></tr>
<tr class="memitem:afa1114f766781ead5174ff03d9bfcaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#afa1114f766781ead5174ff03d9bfcaac">heap</a></td></tr>
<tr class="memitem:a4d7c9cc595e33ade9ceeb4a1f14a9d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4d7c9cc595e33ade9ceeb4a1f14a9d76">ins_node</a></td></tr>
<tr class="memitem:aa1085ad273bb47a95631ac73a16a9a22"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aa1085ad273bb47a95631ac73a16a9a22">ins_upd_rec_buff</a></td></tr>
<tr class="memitem:a1b397e188f2d0d2ebc9af03578617d35"><td class="memItemLeft" align="right" valign="top">const byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1b397e188f2d0d2ebc9af03578617d35">default_rec</a></td></tr>
<tr class="memitem:a23328500b0f9834d0baddce5d3bbbc48"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a23328500b0f9834d0baddce5d3bbbc48">hint_need_to_fetch_extra_cols</a></td></tr>
<tr class="memitem:a0f54b68eb4f1a5349eef999f88a9967f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0f54b68eb4f1a5349eef999f88a9967f">upd_node</a></td></tr>
<tr class="memitem:a0079ca440c8a887b00c656ca73c767c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a0079ca440c8a887b00c656ca73c767c6">trx_id</a></td></tr>
<tr class="memitem:ae46537393407eb4071c703343586d22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ae46537393407eb4071c703343586d22a">ins_graph</a></td></tr>
<tr class="memitem:a9a3aca3ac08088406e83cd47adb824a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9a3aca3ac08088406e83cd47adb824a4">upd_graph</a></td></tr>
<tr class="memitem:a999d8694c7f57409124f50c937caedf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a999d8694c7f57409124f50c937caedf9">pcur</a></td></tr>
<tr class="memitem:a3738d2771017637a67cbdbdee9871be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3738d2771017637a67cbdbdee9871be7">clust_pcur</a></td></tr>
<tr class="memitem:affb3504add5a29b9352f5f7a70da89e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affb3504add5a29b9352f5f7a70da89e9">sel_graph</a></td></tr>
<tr class="memitem:a2110e245f510fe5703437190bdf7c9e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2110e245f510fe5703437190bdf7c9e1">search_tuple</a></td></tr>
<tr class="memitem:aac44d559d12885d25cceeebba46c7e6c"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aac44d559d12885d25cceeebba46c7e6c">row_id</a> [DATA_ROW_ID_LEN]</td></tr>
<tr class="memitem:a2ab1fb978fc37f85f0f278ec6c09180d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ab1fb978fc37f85f0f278ec6c09180d"></a>
<a class="el" href="fts0fts_8h.html#a380910af8d69503a3e3dcbf6d809a3b6">doc_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fts_doc_id</b></td></tr>
<tr class="memitem:ad849b52ec988d5c989838523993998aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad849b52ec988d5c989838523993998aa">clust_ref</a></td></tr>
<tr class="memitem:a33ba7f40688b0b0acd0e46ce459eb134"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a33ba7f40688b0b0acd0e46ce459eb134">select_lock_type</a></td></tr>
<tr class="memitem:a1a8d86728884036618a531bc50546deb"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a1a8d86728884036618a531bc50546deb">stored_select_lock_type</a></td></tr>
<tr class="memitem:a6b853f8cb36486a637e6f58ad95b458c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6b853f8cb36486a637e6f58ad95b458c">row_read_type</a></td></tr>
<tr class="memitem:ac3a9ba86fe41e70b9a84837054fc0088"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ac3a9ba86fe41e70b9a84837054fc0088">new_rec_locks</a></td></tr>
<tr class="memitem:a2656fbd8b2cf6d356622f37bace7444a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a2656fbd8b2cf6d356622f37bace7444a">mysql_prefix_len</a></td></tr>
<tr class="memitem:a930a910f8de38274b71e4dcc79888496"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a930a910f8de38274b71e4dcc79888496">mysql_row_len</a></td></tr>
<tr class="memitem:a9219653973849987e00efd71c57cd9b5"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9219653973849987e00efd71c57cd9b5">n_rows_fetched</a></td></tr>
<tr class="memitem:a8befaa7c077a4d5a0c3e673b09c4c361"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a8befaa7c077a4d5a0c3e673b09c4c361">fetch_direction</a></td></tr>
<tr class="memitem:a9f1ab35f63cdb3d2b64bb81a0a12cf84"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f1ab35f63cdb3d2b64bb81a0a12cf84">fetch_cache</a> [MYSQL_FETCH_CACHE_SIZE]</td></tr>
<tr class="memitem:ab6b52068ec945cf852151523434a786a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ab6b52068ec945cf852151523434a786a">keep_other_fields_on_keyread</a></td></tr>
<tr class="memitem:ad1a497bcd529e69f9b9ca11de686cc72"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#ad1a497bcd529e69f9b9ca11de686cc72">fetch_cache_first</a></td></tr>
<tr class="memitem:a633f4db03c18e781fe73864afb32fd4a"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a633f4db03c18e781fe73864afb32fd4a">n_fetch_cached</a></td></tr>
<tr class="memitem:a4b2bf20a06ef44d9114b5a7667f028c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a4b2bf20a06ef44d9114b5a7667f028c2">blob_heap</a></td></tr>
<tr class="memitem:a7f020430b4ec6fdd33b90bc1a811f6f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7f020430b4ec6fdd33b90bc1a811f6f3">old_vers_heap</a></td></tr>
<tr class="memitem:a7d0dfee13cc2dd7f8603d873d0155d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a7d0dfee13cc2dd7f8603d873d0155d41">in_fts_query</a></td></tr>
<tr class="memitem:aec305f742e5262b09eeaad0e64066d0c"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aec305f742e5262b09eeaad0e64066d0c">autoinc_last_value</a></td></tr>
<tr class="memitem:a6646ec8dded9b73f2ed89f14177fbbcd"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6646ec8dded9b73f2ed89f14177fbbcd">autoinc_increment</a></td></tr>
<tr class="memitem:a38c818b53352ba1e88d517b9e2d74c44"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a38c818b53352ba1e88d517b9e2d74c44">autoinc_offset</a></td></tr>
<tr class="memitem:a9f9ef76992b0b772c92df797bb0b1f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a9f9ef76992b0b772c92df797bb0b1f01">autoinc_error</a></td></tr>
<tr class="memitem:a54cde88cb2f601a3e3c5a04697b3e7fe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a54cde88cb2f601a3e3c5a04697b3e7fe">idx_cond</a></td></tr>
<tr class="memitem:a6a85744d402aac8d6bd38de0d637ef4d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a6a85744d402aac8d6bd38de0d637ef4d">idx_cond_n_cols</a></td></tr>
<tr class="memitem:affc0a986a1cfa9c1af8d0c881d326f4b"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#affc0a986a1cfa9c1af8d0c881d326f4b">magic_n2</a></td></tr>
<tr class="memitem:a3cb2c828efad5ccf81c3165c79269f80"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a3cb2c828efad5ccf81c3165c79269f80">innodb_api</a>:1</td></tr>
<tr class="memitem:aace90681d96b49e946dcade7a36f935a"><td class="memItemLeft" align="right" valign="top">const rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aace90681d96b49e946dcade7a36f935a">innodb_api_rec</a></td></tr>
<tr class="memitem:a93437253882fa8d53a3b576a4633fc94"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a93437253882fa8d53a3b576a4633fc94">srch_key_val1</a></td></tr>
<tr class="memitem:a05fe59b7101e2d8df0b534618b591511"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#a05fe59b7101e2d8df0b534618b591511">srch_key_val2</a></td></tr>
<tr class="memitem:aefd747a430fb3aa32a2db04cebf345b6"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__prebuilt__t.html#aefd747a430fb3aa32a2db04cebf345b6">srch_key_val_len</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><pre class="fragment">A struct for (sometimes lazily) prebuilt structures in an Innobase table
</pre><p> handle used within MySQL; these are used to save CPU time. </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="a9f9ef76992b0b772c92df797bb0b1f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_prebuilt_t::autoinc_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The actual error code encountered while trying to init or read the autoinc value from the table. We store it here so that we can return it to MySQL </p>

</div>
</div>
<a class="anchor" id="a6646ec8dded9b73f2ed89f14177fbbcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_increment</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The increment step of the auto increment column. Value must be greater than or equal to 1. Required to calculate the next value </p>

</div>
</div>
<a class="anchor" id="aec305f742e5262b09eeaad0e64066d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_last_value</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>last value of AUTO-INC interval </p>

</div>
</div>
<a class="anchor" id="a38c818b53352ba1e88d517b9e2d74c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong row_prebuilt_t::autoinc_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The offset passed to get_auto_increment() by MySQL. Required to calculate the next value </p>

</div>
</div>
<a class="anchor" id="a4b2bf20a06ef44d9114b5a7667f028c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::blob_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in SELECTS BLOB fields are copied to this heap </p>

</div>
</div>
<a class="anchor" id="abd76361eda548fa2e2f8d80d66d08612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::clust_index_was_generated</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if the user did not define a primary key in MySQL, then Innobase automatically generated a clustered index where the ordering column is the row id: in this case this flag is set to TRUE </p>

</div>
</div>
<a class="anchor" id="a3738d2771017637a67cbdbdee9871be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> row_prebuilt_t::clust_pcur</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>persistent cursor used in some selects and updates </p>

</div>
</div>
<a class="anchor" id="ad849b52ec988d5c989838523993998aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::clust_ref</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prebuilt dtuple used in sel/upd/del </p>

</div>
</div>
<a class="anchor" id="a1b397e188f2d0d2ebc9af03578617d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const byte* row_prebuilt_t::default_rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the default values of all columns (a "default row") in MySQL format </p>

</div>
</div>
<a class="anchor" id="a9f1ab35f63cdb3d2b64bb81a0a12cf84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::fetch_cache[MYSQL_FETCH_CACHE_SIZE]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>a cache for fetched rows if we fetch many rows from the same cursor: it saves CPU time to fetch them in a batch; we reserve mysql_row_len bytes for each such row; these pointers point 4 bytes past the allocated mem buf start, because there is a 4 byte magic number at the start and at the end </p>

</div>
</div>
<a class="anchor" id="ad1a497bcd529e69f9b9ca11de686cc72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_cache_first</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>position of the first not yet fetched row in fetch_cache </p>

</div>
</div>
<a class="anchor" id="a8befaa7c077a4d5a0c3e673b09c4c361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::fetch_direction</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_SEL_NEXT or ROW_SEL_PREV </p>

</div>
</div>
<a class="anchor" id="afa1114f766781ead5174ff03d9bfcaac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap from which these auxiliary structures are allocated when needed </p>

</div>
</div>
<a class="anchor" id="a23328500b0f9834d0baddce5d3bbbc48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::hint_need_to_fetch_extra_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normally this is set to 0; if this is set to ROW_RETRIEVE_PRIMARY_KEY, then we should at least retrieve all columns in the primary key; if this is set to ROW_RETRIEVE_ALL_COLS, then we must retrieve all columns in the key (if read_just_key == 1), or all columns in the table </p>

</div>
</div>
<a class="anchor" id="a54cde88cb2f601a3e3c5a04697b3e7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* row_prebuilt_t::idx_cond</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In ICP, pointer to a <a class="el" href="classha__innobase.html">ha_innobase</a>, passed to <a class="el" href="ha__prototypes_8h.html#a2631c959553aa4831aae9f95ae945345">innobase_index_cond()</a>. NULL if index condition pushdown is not used. </p>

</div>
</div>
<a class="anchor" id="a6a85744d402aac8d6bd38de0d637ef4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::idx_cond_n_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of fields in idx_cond_cols. 0 if and only if idx_cond == NULL. </p>

</div>
</div>
<a class="anchor" id="a7d0dfee13cc2dd7f8603d873d0155d41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool row_prebuilt_t::in_fts_query</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether we are in a FTS query </p>

</div>
</div>
<a class="anchor" id="afeb88835f509e12ea05929f410f4df0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__index__t.html">dict_index_t</a>* row_prebuilt_t::index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current index for a search, if any </p>

</div>
</div>
<a class="anchor" id="ac59950f1aed60deccf5ba6a917afc357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::index_usable</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>caches the value of row_merge_is_index_usable(trx,index) </p>

</div>
</div>
<a class="anchor" id="a3cb2c828efad5ccf81c3165c79269f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::innodb_api</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>whether this is a InnoDB API query </p>

</div>
</div>
<a class="anchor" id="aace90681d96b49e946dcade7a36f935a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const rec_t* row_prebuilt_t::innodb_api_rec</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>InnoDB API search result </p>

</div>
</div>
<a class="anchor" id="ae46537393407eb4071c703343586d22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::ins_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL query graph used in inserts. Will be rebuilt on trx_id or n_indexes mismatch. </p>

</div>
</div>
<a class="anchor" id="a4d7c9cc595e33ade9ceeb4a1f14a9d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structins__node__t.html">ins_node_t</a>* row_prebuilt_t::ins_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL insert node used to perform inserts to the table </p>

</div>
</div>
<a class="anchor" id="aa1085ad273bb47a95631ac73a16a9a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::ins_upd_rec_buff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer for storing data converted to the Innobase format from the MySQL format </p>

</div>
</div>
<a class="anchor" id="ab6b52068ec945cf852151523434a786a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> row_prebuilt_t::keep_other_fields_on_keyread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when using fetch cache with HA_EXTRA_KEYREAD, don't overwrite other fields in mysql row row buffer. </p>

</div>
</div>
<a class="anchor" id="ad936db2921893119b95f7e33727f2d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this magic number is set to ROW_PREBUILT_ALLOCATED when created, or ROW_PREBUILT_FREED when the struct has been freed </p>

</div>
</div>
<a class="anchor" id="affc0a986a1cfa9c1af8d0c881d326f4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::magic_n2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this should be the same as magic_n </p>

</div>
</div>
<a class="anchor" id="a6abfde48ea9d8abc5c235403e2f3b022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::mysql_has_locked</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this is set TRUE when MySQL calls external_lock on this handle with a lock flag, and set FALSE when with the F_UNLOCK flag </p>

</div>
</div>
<a class="anchor" id="a2656fbd8b2cf6d356622f37bace7444a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_prefix_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>byte offset of the end of the last requested column </p>

</div>
</div>
<a class="anchor" id="a930a910f8de38274b71e4dcc79888496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::mysql_row_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>length in bytes of a row in the MySQL format </p>

</div>
</div>
<a class="anchor" id="a25c5641e4244b609f7e89f11069239e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a>* row_prebuilt_t::mysql_template</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>template used to transform rows fast between MySQL and Innobase formats; memory for this template is not allocated from 'heap' </p>

</div>
</div>
<a class="anchor" id="a633f4db03c18e781fe73864afb32fd4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_fetch_cached</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of not yet fetched rows in fetch_cache </p>

</div>
</div>
<a class="anchor" id="a9219653973849987e00efd71c57cd9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::n_rows_fetched</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of rows fetched after positioning the current cursor </p>

</div>
</div>
<a class="anchor" id="a551a6896bb6da7d979e6fb20decf18ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::n_template</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of elements in the template </p>

</div>
</div>
<a class="anchor" id="a94506e9f10462650bfa377f9414cf7db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::need_to_access_clustered</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if we are fetching columns through a secondary index and at least one column is not in the secondary index, then this is set to TRUE </p>

</div>
</div>
<a class="anchor" id="ac3a9ba86fe41e70b9a84837054fc0088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::new_rec_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>normally 0; if srv_locks_unsafe_for_binlog is TRUE or session is using READ COMMITTED or READ UNCOMMITTED isolation level, set in <a class="el" href="row0sel_8h.html#a5afcfca75d1be134194de2a36fb109a3">row_search_for_mysql()</a> if we set a new record lock on the secondary or clustered index; this is used in <a class="el" href="row0mysql_8h.html#a15bc119f5540eb748bb3deae21a3b8a5">row_unlock_for_mysql()</a> when releasing the lock under the cursor if we determine after retrieving the row that it does not need to be locked ('mini-rollback') </p>

</div>
</div>
<a class="anchor" id="a4218e8b9331e26a43e2507663d59bdc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::null_bitmap_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of bytes in the SQL NULL bitmap at the start of a row in the MySQL format </p>

</div>
</div>
<a class="anchor" id="a7f020430b4ec6fdd33b90bc1a811f6f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* row_prebuilt_t::old_vers_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap where a previous version is built in consistent read </p>

</div>
</div>
<a class="anchor" id="a999d8694c7f57409124f50c937caedf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> row_prebuilt_t::pcur</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>persistent cursor used in selects and updates </p>

</div>
</div>
<a class="anchor" id="aa2406d22fe6361a563ec8b4e9b010287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::read_just_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set to 1 when MySQL calls ha_innobase::extra with the argument HA_EXTRA_KEYREAD; it is enough to read just columns defined in the index (i.e., no read of the clustered index record necessary) </p>

</div>
</div>
<a class="anchor" id="aac44d559d12885d25cceeebba46c7e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte row_prebuilt_t::row_id[DATA_ROW_ID_LEN]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if the clustered index was generated, the row id of the last row fetched is stored here </p>

</div>
</div>
<a class="anchor" id="a6b853f8cb36486a637e6f58ad95b458c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::row_read_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_READ_WITH_LOCKS if row locks should be the obtained for records under an UPDATE or DELETE cursor. If innodb_locks_unsafe_for_binlog is TRUE, this can be set to ROW_READ_TRY_SEMI_CONSISTENT, so that if the row under an UPDATE or DELETE cursor was locked by another transaction, InnoDB will resort to reading the last committed value ('semi-consistent read'). Then, this field will be set to ROW_READ_DID_SEMI_CONSISTENT to indicate that. If the row does not match the WHERE condition, MySQL will invoke handler::unlock_row() to clear the flag back to ROW_READ_TRY_SEMI_CONSISTENT and to simply skip the row. If the row matches, the next call to <a class="el" href="row0sel_8h.html#a5afcfca75d1be134194de2a36fb109a3">row_search_for_mysql()</a> will lock the row. This eliminates lock waits in some cases; note that this breaks serializability. </p>

</div>
</div>
<a class="anchor" id="a2110e245f510fe5703437190bdf7c9e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdtuple__t.html">dtuple_t</a>* row_prebuilt_t::search_tuple</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>prebuilt dtuple used in selects </p>

</div>
</div>
<a class="anchor" id="affb3504add5a29b9352f5f7a70da89e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::sel_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dummy query graph used in selects </p>

</div>
</div>
<a class="anchor" id="a33ba7f40688b0b0acd0e46ce459eb134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::select_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LOCK_NONE, LOCK_S, or LOCK_X </p>

</div>
</div>
<a class="anchor" id="a1004d8c54485ba370f756c48f26d93a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::sql_stat_start</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE when we start processing of an SQL statement: we may have to set an intention lock on the table, create a consistent read view etc. </p>

</div>
</div>
<a class="anchor" id="a93437253882fa8d53a3b576a4633fc94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::srch_key_val1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a class="anchor" id="a05fe59b7101e2d8df0b534618b591511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* row_prebuilt_t::srch_key_val2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>buffer used in converting search key values from MySQL format to InnoDB format. </p>

</div>
</div>
<a class="anchor" id="aefd747a430fb3aa32a2db04cebf345b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint row_prebuilt_t::srch_key_val_len</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of search key </p>

</div>
</div>
<a class="anchor" id="a1a8d86728884036618a531bc50546deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint row_prebuilt_t::stored_select_lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this field is used to remember the original select_lock_type that was decided in ha_innodb.cc, ::store_lock(), ::external_lock(), etc. </p>

</div>
</div>
<a class="anchor" id="a19c2a8205446e84d2e64f80088a7846c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdict__table__t.html">dict_table_t</a>* row_prebuilt_t::table</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase table handle </p>

</div>
</div>
<a class="anchor" id="a666323e0b2127c47e743adf5ba2bef94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::templ_contains_blob</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the template contains a column with DATA_BLOB == <a class="el" href="ha__prototypes_8h.html#a45fec30bd8c2b2e9d21654edcabd3f78">get_innobase_type_from_mysql_type()</a>; not to be confused with InnoDB externally stored columns (VARCHAR can be off-page too) </p>

</div>
</div>
<a class="anchor" id="afa6cf19178262078ea73dd92941a88ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::template_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ROW_MYSQL_WHOLE_ROW, ROW_MYSQL_REC_FIELDS, ROW_MYSQL_DUMMY_TEMPLATE, or ROW_MYSQL_NO_TEMPLATE </p>

</div>
</div>
<a class="anchor" id="aa177d7d5264d91df66db86414dfa7da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtrx__t.html">trx_t</a>* row_prebuilt_t::trx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current transaction handle </p>

</div>
</div>
<a class="anchor" id="a0079ca440c8a887b00c656ca73c767c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> row_prebuilt_t::trx_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The table-&gt;def_trx_id when ins_graph was built </p>

</div>
</div>
<a class="anchor" id="a9a3aca3ac08088406e83cd47adb824a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__fork__t.html">que_fork_t</a>* row_prebuilt_t::upd_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL query graph used in updates or deletes </p>

</div>
</div>
<a class="anchor" id="a0f54b68eb4f1a5349eef999f88a9967f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structupd__node__t.html">upd_node_t</a>* row_prebuilt_t::upd_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Innobase SQL update node used to perform updates and deletes </p>

</div>
</div>
<a class="anchor" id="a0568bf55e0cd59e39cbf5264e0107a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned row_prebuilt_t::used_in_HANDLER</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if we have been using this handle in a MySQL HANDLER low level index cursor command: then we must store the pcur position even in a unique search from a clustered index, because HANDLER allows NEXT and PREV in such a situation </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:28 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
