<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/ha0storage.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ha0storage.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ha0storage_8ic.html">ha0storage.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ha0storage.h:</div>
<div class="dyncontent">
<div class="center"><img src="ha0storage_8h__incl.png" border="0" usemap="#include_2ha0storage_8h" alt=""/></div>
<map name="include_2ha0storage_8h" id="include_2ha0storage_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ha0storage_8h__dep__incl.png" border="0" usemap="#include_2ha0storage_8hdep" alt=""/></div>
<map name="include_2ha0storage_8hdep" id="include_2ha0storage_8hdep">
</map>
</div>
</div>
<p><a href="ha0storage_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abc962381687af1413ca12c4e8b4e66f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#abc962381687af1413ca12c4e8b4e66f5">HA_STORAGE_DEFAULT_HEAP_BYTES</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:a74363ddaf2f0f2f95e3fd6ecfb576e31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a74363ddaf2f0f2f95e3fd6ecfb576e31">HA_STORAGE_DEFAULT_HASH_CELLS</a>&#160;&#160;&#160;4096</td></tr>
<tr class="memitem:aaed0fd495a3214cb851169236c1b2972"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put</a>(storage, data, data_len)&#160;&#160;&#160;<a class="el" href="ha0storage_8h.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim</a>((storage), (data), (data_len), 0)</td></tr>
<tr class="memitem:a386e8a40a86625ecf93a105f689b0ec5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a386e8a40a86625ecf93a105f689b0ec5">ha_storage_put_str</a>(storage, str)&#160;&#160;&#160;((const char*) <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put</a>((storage), (str), strlen(str) + 1))</td></tr>
<tr class="memitem:a3eec962a10c510eef910e0c87f76b816"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a3eec962a10c510eef910e0c87f76b816">ha_storage_put_str_memlim</a>(storage, str, memlim)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a252293c8b6653ccc68597e97cad871a2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structha__storage__t.html">ha_storage_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a252293c8b6653ccc68597e97cad871a2">ha_storage_create</a> (ulint initial_heap_bytes, ulint initial_hash_cells)</td></tr>
<tr class="memitem:a5b5c7d979ca0d2c056e60a391df21dd1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim</a> (<a class="el" href="structha__storage__t.html">ha_storage_t</a> *storage, const void *data, ulint data_len, ulint memlim)</td></tr>
<tr class="memitem:aa132fdb4ba1cd528c299165b80ef67bb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#aa132fdb4ba1cd528c299165b80ef67bb">ha_storage_empty</a> (<a class="el" href="structha__storage__t.html">ha_storage_t</a> **storage)</td></tr>
<tr class="memitem:a8f1be12d17cc66a9b7852c6a7251cdc1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a8f1be12d17cc66a9b7852c6a7251cdc1">ha_storage_free</a> (<a class="el" href="structha__storage__t.html">ha_storage_t</a> *storage)</td></tr>
<tr class="memitem:a525903647192e960bac5334b4374f263"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ha0storage_8h.html#a525903647192e960bac5334b4374f263">ha_storage_get_size</a> (const <a class="el" href="structha__storage__t.html">ha_storage_t</a> *storage)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Hash storage. Provides a data structure that stores chunks of data in its own storage, avoiding duplicates.</p>
<p>Created September 22, 2007 Vasil Dimov </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a74363ddaf2f0f2f95e3fd6ecfb576e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HA_STORAGE_DEFAULT_HASH_CELLS&#160;&#160;&#160;4096</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This value is used by default by ha_storage_create(). It is a
</pre><p> constant per ha_storage's lifetime. </p>

</div>
</div>
<a class="anchor" id="abc962381687af1413ca12c4e8b4e66f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HA_STORAGE_DEFAULT_HEAP_BYTES&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This value is used by default by ha_storage_create(). More memory
</pre><p> is allocated later when/if it is needed. </p>

</div>
</div>
<a class="anchor" id="aaed0fd495a3214cb851169236c1b2972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ha_storage_put</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ha0storage_8h.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim</a>((storage), (data), (data_len), 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="ha0storage_8h.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim()</a> but without memory limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in/out: hash storage </td></tr>
    <tr><td class="paramname">data</td><td>in: data to store </td></tr>
    <tr><td class="paramname">data_len</td><td>in: data length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the copy of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a386e8a40a86625ecf93a105f689b0ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ha_storage_put_str</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const char*) <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put</a>((storage), (str), strlen(str) + 1))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies string into the storage and returns a pointer to the copy. If the same string is already present, then pointer to it is returned. Strings are considered to be equal if strcmp(str1, str2) == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in/out: hash storage </td></tr>
    <tr><td class="paramname">str</td><td>in: string to put </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the copy of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a3eec962a10c510eef910e0c87f76b816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ha_storage_put_str_memlim</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">storage, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memlim&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<span class="keyword">const</span> <span class="keywordtype">char</span>*) <a class="code" href="ha0storage_8h.html#a5b5c7d979ca0d2c056e60a391df21dd1">ha_storage_put_memlim</a>((storage), (str),  \</div>
<div class="line">                                             strlen(str) + 1, (memlim)))</div>
</div><!-- fragment --><p>Copies string into the storage and returns a pointer to the copy obeying a memory limit. If the same string is already present, then pointer to it is returned. Strings are considered to be equal if strcmp(str1, str2) == 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in/out: hash storage </td></tr>
    <tr><td class="paramname">str</td><td>in: string to put </td></tr>
    <tr><td class="paramname">memlim</td><td>in: memory limit to obey </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the copy of the string </dd></dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a252293c8b6653ccc68597e97cad871a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structha__storage__t.html">ha_storage_t</a>* ha_storage_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>initial_heap_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>initial_hash_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a hash storage. If any of the parameters is 0, then a default value is used. </p>
<dl class="section return"><dt>Returns</dt><dd>own: hash storage in: initial number of cells in the hash table</dd></dl>
<p>Creates a hash storage. If any of the parameters is 0, then a default value is used. </p>
<dl class="section return"><dt>Returns</dt><dd>own: hash storage </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_heap_bytes</td><td>in: initial heap's size </td></tr>
    <tr><td class="paramname">initial_hash_cells</td><td>in: initial number of cells in the hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa132fdb4ba1cd528c299165b80ef67bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ha_storage_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structha__storage__t.html">ha_storage_t</a> **&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties a hash storage, freeing memory occupied by data chunks. This invalidates any pointers previously returned by <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put()</a>. The hash storage is not invalidated itself and can be used again. in/out: hash storage</p>
<p>Empties a hash storage, freeing memory occupied by data chunks. This invalidates any pointers previously returned by <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put()</a>. The hash storage is not invalidated itself and can be used again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in/out: hash storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f1be12d17cc66a9b7852c6a7251cdc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ha_storage_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structha__storage__t.html">ha_storage_t</a> *&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a hash storage and everything it contains, it cannot be used after this call. This invalidates any pointers previously returned by <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put()</a>. in, own: hash storage</p>
<p>Frees a hash storage and everything it contains, it cannot be used after this call. This invalidates any pointers previously returned by <a class="el" href="ha0storage_8h.html#aaed0fd495a3214cb851169236c1b2972">ha_storage_put()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in, own: hash storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a525903647192e960bac5334b4374f263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ha_storage_get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structha__storage__t.html">ha_storage_t</a> *&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the memory used by a storage. </p>
<dl class="section return"><dt>Returns</dt><dd>bytes used in: hash storage</dd></dl>
<p>Gets the size of the memory used by a storage. </p>
<dl class="section return"><dt>Returns</dt><dd>bytes used </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in: hash storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b5c7d979ca0d2c056e60a391df21dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const void* ha_storage_put_memlim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structha__storage__t.html">ha_storage_t</a> *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>memlim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies data into the storage and returns a pointer to the copy. If the same data chunk is already present, then pointer to it is returned. Data chunks are considered to be equal if len1 == len2 and memcmp(data1, data2, len1) == 0. If "data" is not present (and thus data_len bytes need to be allocated) and the size of storage is going to become more than "memlim" then "data" is not added and NULL is returned. To disable this behavior "memlim" can be set to 0, which stands for "no limit". </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the copy in: memory limit to obey </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>in/out: hash storage </td></tr>
    <tr><td class="paramname">data</td><td>in: data to store </td></tr>
    <tr><td class="paramname">data_len</td><td>in: data length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:20 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
