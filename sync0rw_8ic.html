<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/sync0rw.ic File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sync0rw.ic File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sync0rw_8ic__dep__incl.png" border="0" usemap="#include_2sync0rw_8icdep" alt=""/></div>
<map name="include_2sync0rw_8icdep" id="include_2sync0rw_8icdep">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3d1d2377951cc87ea63e51f3b930dfdd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a3d1d2377951cc87ea63e51f3b930dfdd">rw_lock_s_lock_spin</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a57d027cadbd4861e6f321075c10e5f61"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a57d027cadbd4861e6f321075c10e5f61">rw_lock_add_debug_info</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, ulint lock_type, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a2f88814e5711fa9791b6f970bf69e757"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a2f88814e5711fa9791b6f970bf69e757">rw_lock_remove_debug_info</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, ulint lock_type)</td></tr>
<tr class="memitem:accc192baf074e7cba3590651df4b4194"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#accc192baf074e7cba3590651df4b4194">rw_lock_get_waiters</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a42d74392816f22b52603d0a3fb257562"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a42d74392816f22b52603d0a3fb257562">rw_lock_set_waiter_flag</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:aa7922ad594d35c26f80313aa77764502"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#aa7922ad594d35c26f80313aa77764502">rw_lock_reset_waiter_flag</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:acd5acf23523e06ae0ce287173349c2ff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#acd5acf23523e06ae0ce287173349c2ff">rw_lock_get_writer</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:ae24ac5c3f41388704830966b07d50936"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#ae24ac5c3f41388704830966b07d50936">rw_lock_get_reader_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a1ef555197dbf6378f96f26a2e05e6624"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ef555197dbf6378f96f26a2e05e6624"></a>
UNIV_INLINE <a class="el" href="structib__mutex__t.html">ib_mutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_get_mutex</b> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:add5b9c0969702ede99cdabbbc40fce33"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#add5b9c0969702ede99cdabbbc40fce33">rw_lock_get_x_lock_count</a> (const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a7cbd8f9cce63535b6d1196e067deecff"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a7cbd8f9cce63535b6d1196e067deecff">rw_lock_lock_word_decr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="memitem:ae2190009fb2d146f6b082fda6a339452"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE lint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#ae2190009fb2d146f6b082fda6a339452">rw_lock_lock_word_incr</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint amount)</td></tr>
<tr class="memitem:a1d25e4a616558afa15d4c302d42c1f3c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a1d25e4a616558afa15d4c302d42c1f3c">rw_lock_set_writer_id_and_recursion_flag</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> recursive)</td></tr>
<tr class="memitem:a359cd00fb32985538e22e25bf623a6d1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a359cd00fb32985538e22e25bf623a6d1">rw_lock_s_lock_low</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass)</td></tr>
<tr class="memitem:ae32bc0d594df7939bbab036fefcb32d6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char <br class="typebreak"/>
ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#ae32bc0d594df7939bbab036fefcb32d6">if</a> (!<a class="el" href="sync0rw_8ic.html#a7cbd8f9cce63535b6d1196e067deecff">rw_lock_lock_word_decr</a>(lock, 1))</td></tr>
<tr class="memitem:ac9f82f736489ded30704002d7bbb7659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9f82f736489ded30704002d7bbb7659"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rw_lock_add_debug_info</b> (lock, pass, RW_LOCK_SHARED, <a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:afc794263f34d1e80b2344450756ed72b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc794263f34d1e80b2344450756ed72b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> (TRUE)</td></tr>
<tr class="memitem:a1dfb8bac26c0ede1f1cbb1c94d415370"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a1dfb8bac26c0ede1f1cbb1c94d415370">rw_lock_s_lock_func</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, ulint pass, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a9ec3c37952ede1fb7178c8ee66c35b14"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a9ec3c37952ede1fb7178c8ee66c35b14">rw_lock_x_lock_func_nowait</a> (<a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock, const char *<a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a>, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>)</td></tr>
<tr class="memitem:a841d018693f38edcea0e3316f47761c2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a841d018693f38edcea0e3316f47761c2">rw_lock_s_unlock_func</a> (ulint pass, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
<tr class="memitem:a461109512901bbb42f1317ba16c0dabc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a461109512901bbb42f1317ba16c0dabc">rw_lock_x_unlock_func</a> (ulint pass, <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *lock)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a536d52293912f9ecfa49addcaa4877c3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a></td></tr>
<tr class="memitem:aa8604776a5055166ef0ee9ecd30d37da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8604776a5055166ef0ee9ecd30d37da"></a>
lock&#160;</td><td class="memItemRight" valign="bottom"><b>last_s_file_name</b> = <a class="el" href="sync0rw_8ic.html#a536d52293912f9ecfa49addcaa4877c3">file_name</a></td></tr>
<tr class="memitem:ac12cfdf832840ebb3bf66b8f038fe533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac12cfdf832840ebb3bf66b8f038fe533"></a>
lock&#160;</td><td class="memItemRight" valign="bottom"><b>last_s_line</b> = <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The read-write lock (for threads)</p>
<p>Created 9/11/1995 Heikki Tuuri </p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="ae32bc0d594df7939bbab036fefcb32d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a> if </td>
          <td>(</td>
          <td class="paramtype">!&#160;</td>
          <td class="paramname"><em>rw_lock_lock_word_decr</em>lock, 1</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: line where requested </p>

</div>
</div>
<a class="anchor" id="a57d027cadbd4861e6f321075c10e5f61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_add_debug_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the debug information for an rw-lock. in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value </td></tr>
    <tr><td class="paramname">lock_type</td><td>in: lock type </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae24ac5c3f41388704830966b07d50936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_reader_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of readers. </p>
<dl class="section return"><dt>Returns</dt><dd>number of readers </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accc192baf074e7cba3590651df4b4194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_waiters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are threads waiting for the rw-lock. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if waiters, 0 otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd5acf23523e06ae0ce287173349c2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_writer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the write-status of the lock - this function made more sense with the old rw_lock implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>RW_LOCK_NOT_LOCKED, RW_LOCK_EX, RW_LOCK_WAIT_EX </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add5b9c0969702ede99cdabbbc40fce33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint rw_lock_get_x_lock_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of writer_count for the lock. Does not reserve the lock mutex, so the caller must be sure it is not changed during the call. </p>
<dl class="section return"><dt>Returns</dt><dd>value of writer_count </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cbd8f9cce63535b6d1196e067deecff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_lock_word_decr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two different implementations for decrementing the lock_word of a rw_lock: one for systems supporting atomic operations, one for others. This does does not support recusive x-locks: they should be handled by the caller and need not be atomic since they are performed by the current lock holder. Returns true if the decrement was made, false if not. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if decr occurs </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
    <tr><td class="paramname">amount</td><td>in: amount to decrement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2190009fb2d146f6b082fda6a339452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE lint rw_lock_lock_word_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments lock_word the specified amount and returns new value. </p>
<dl class="section return"><dt>Returns</dt><dd>lock-&gt;lock_word after increment </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
    <tr><td class="paramname">amount</td><td>in: amount of increment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f88814e5711fa9791b6f970bf69e757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_remove_debug_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a debug information struct for an rw-lock. in: lock type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7922ad594d35c26f80313aa77764502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_reset_waiter_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets lock-&gt;waiters to 0. It is not an error if lock-&gt;waiters is already 0. On platforms where ATOMIC builtins are used this function enforces a memory barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dfb8bac26c0ede1f1cbb1c94d415370"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_lock_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in shared mode for the current thread. If the rw-lock is locked in exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock, before suspending the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a359cd00fb32985538e22e25bf623a6d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_s_lock_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Low-level function which tries to lock an rw-lock in s-mode. Performs no spinning. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d1d2377951cc87ea63e51f3b930dfdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rw_lock_s_lock_spin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock an rw-lock in shared mode for the current thread. If the rw-lock is locked in exclusive mode, or there is an exclusive lock request waiting, the function spins a preset time (controlled by SYNC_SPIN_ROUNDS), waiting for the lock before suspending the thread. in: line where requested </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock will be passed to another thread to unlock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a841d018693f38edcea0e3316f47761c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_s_unlock_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a shared mode lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock may have been passed to another thread to unlock </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42d74392816f22b52603d0a3fb257562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_set_waiter_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets lock-&gt;waiters to 1. It is not an error if lock-&gt;waiters is already</p>
<ol type="1">
<li>On platforms where ATOMIC builtins are used this function enforces a memory barrier. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d25e4a616558afa15d4c302d42c1f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_set_writer_id_and_recursion_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the lock-&gt;writer_thread and lock-&gt;recursive fields. For platforms where we are using atomic builtins instead of lock-&gt;mutex it sets the lock-&gt;writer_thread field using atomics to ensure memory ordering. Note that it is assumed that the caller of this function effectively owns the lock i.e.: nobody else is allowed to modify lock-&gt;writer_thread at this point in time. The protocol is that lock-&gt;writer_thread MUST be updated BEFORE the lock-&gt;recursive flag is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: lock to work on </td></tr>
    <tr><td class="paramname">recursive</td><td>in: TRUE if recursion allowed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec3c37952ede1fb7178c8ee66c35b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rw_lock_x_lock_func_nowait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE! Use the corresponding macro, not directly this function! Lock an rw-lock in exclusive mode for the current thread if the lock can be obtained immediately. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: pointer to rw-lock </td></tr>
    <tr><td class="paramname">file_name</td><td>in: file name where lock requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a461109512901bbb42f1317ba16c0dabc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void rw_lock_x_unlock_func </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrw__lock__t.html">rw_lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases an exclusive mode lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pass</td><td>in: pass value; != 0, if the lock may have been passed to another thread to unlock </td></tr>
    <tr><td class="paramname">lock</td><td>in/out: rw-lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="a536d52293912f9ecfa49addcaa4877c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> const char* file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; in: pass value; != 0, if the lock will be passed to another thread to unlock in: file name where lock requested </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:21 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
