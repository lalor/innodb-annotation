<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/pars0pars.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pars0pars.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="usr0types_8h_source.html">usr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pars0types_8h_source.html">pars0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pars0pars_8ic.html">pars0pars.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pars0pars.h:</div>
<div class="dyncontent">
<div class="center"><img src="pars0pars_8h__incl.png" border="0" usemap="#include_2pars0pars_8h" alt=""/></div>
<map name="include_2pars0pars_8h" id="include_2pars0pars_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="655,315,708,343"/><area shape="rect" id="node28" href="que0types_8h.html" title="que0types.h" alt="" coords="591,83,692,111"/><area shape="rect" id="node39" href="usr0types_8h.html" title="usr0types.h" alt="" coords="716,83,812,111"/><area shape="rect" id="node41" href="pars0types_8h.html" title="pars0types.h" alt="" coords="836,83,940,111"/><area shape="rect" id="node43" href="row0types_8h.html" title="row0types.h" alt="" coords="964,83,1063,111"/><area shape="rect" id="node45" href="trx0types_8h.html" title="trx0types.h" alt="" coords="1087,83,1180,111"/><area shape="rect" id="node47" href="ut0vec_8h.html" title="ut0vec.h" alt="" coords="493,161,571,189"/><area shape="rect" id="node53" href="pars0pars_8ic.html" title="pars0pars.ic" alt="" coords="1255,83,1353,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="787,393,864,421"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="888,393,955,421"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="919,470,993,498"/><area shape="rect" id="node30" href="data0data_8h.html" title="data0data.h" alt="" coords="609,161,708,189"/><area shape="rect" id="node36" href="dict0types_8h.html" title="dict0types.h" alt="" coords="765,238,864,266"/><area shape="rect" id="node33" href="mem0mem_8h.html" title="mem0mem.h" alt="" coords="581,238,691,266"/><area shape="rect" id="node51" href="ut0vec_8ic.html" title="ut0vec.ic" alt="" coords="480,238,557,266"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="pars0pars_8h__dep__incl.png" border="0" usemap="#include_2pars0pars_8hdep" alt=""/></div>
<map name="include_2pars0pars_8hdep" id="include_2pars0pars_8hdep">
<area shape="rect" id="node3" href="eval0eval_8h.html" title="include/eval0eval.h" alt="" coords="5,83,147,111"/><area shape="rect" id="node5" href="eval0proc_8ic.html" title="include/eval0proc.ic" alt="" coords="51,161,197,189"/><area shape="rect" id="node7" href="eval0proc_8h.html" title="include/eval0proc.h" alt="" coords="107,238,251,266"/><area shape="rect" id="node11" href="fts0priv_8h.html" title="include/fts0priv.h" alt="" coords="276,83,404,111"/><area shape="rect" id="node13" href="row0ftsort_8h.html" title="include/row0ftsort.h" alt="" coords="272,161,419,189"/></map>
</div>
</div>
<p><a href="pars0pars_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpars__info__t.html">pars_info_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpars__user__func__t.html">pars_user_func_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpars__bound__lit__t.html">pars_bound_lit_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpars__bound__id__t.html">pars_bound_id_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfunc__node__t.html">func_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structorder__node__t.html">order_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structproc__node__t.html">proc_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structelsif__node__t.html">elsif_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structif__node__t.html">if_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwhile__node__t.html">while_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfor__node__t.html">for_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexit__node__t.html">exit_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreturn__node__t.html">return_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structassign__node__t.html">assign_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcol__assign__node__t.html">col_assign_node_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a939fd66ca63e9f8f7e43221b56825da7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a939fd66ca63e9f8f7e43221b56825da7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PARS_INPUT</b>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a8501a9fcd3fbd4f2f2225a73d1b90de2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8501a9fcd3fbd4f2f2225a73d1b90de2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PARS_OUTPUT</b>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:aee026f6cda977c42145cf22cc6e99390"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee026f6cda977c42145cf22cc6e99390"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PARS_NOT_PARAM</b>&#160;&#160;&#160;2</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8329df42cb52906a730edb5682723424"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a8329df42cb52906a730edb5682723424">PARS_FUNC_ARITH</a>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:a3bc7140ac637012bfcd3dca48ff1502e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a3bc7140ac637012bfcd3dca48ff1502e">PARS_FUNC_LOGICAL</a>&#160;&#160;&#160;2</td></tr>
<tr class="memitem:a63f24c0b3eb0ebbfad88166cdd47cef9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a63f24c0b3eb0ebbfad88166cdd47cef9">PARS_FUNC_CMP</a>&#160;&#160;&#160;3</td></tr>
<tr class="memitem:ad0ecb24f53349268063e02ffc38fe3e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad0ecb24f53349268063e02ffc38fe3e5">PARS_FUNC_PREDEFINED</a>&#160;&#160;&#160;4</td></tr>
<tr class="memitem:a2dace9a7c2327026ba629bc98465425d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a2dace9a7c2327026ba629bc98465425d">PARS_FUNC_AGGREGATE</a>&#160;&#160;&#160;5</td></tr>
<tr class="memitem:a09a4e425d9ca56fe6275fada91bcfa15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a09a4e425d9ca56fe6275fada91bcfa15">PARS_FUNC_OTHER</a>&#160;&#160;&#160;6</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1e9efbd37c0721ae8149e5d2f10250da"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a1e9efbd37c0721ae8149e5d2f10250da">pars_user_func_cb_t</a> )(void *arg, void *user_arg)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a847a2de5c1c28c9d7055a2b89ed7dad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a847a2de5c1c28c9d7055a2b89ed7dad7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>yyparse</b> (void)</td></tr>
<tr class="memitem:a577d882907b30b31b8255269ab05dffa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a577d882907b30b31b8255269ab05dffa">pars_sql</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *str)</td></tr>
<tr class="memitem:a3401ee39a02d034d302f7d52151ea13a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a3401ee39a02d034d302f7d52151ea13a">pars_get_lex_chars</a> (char *buf, int max_size)</td></tr>
<tr class="memitem:a375b7efc8260487647d928b38b0ecdb3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a375b7efc8260487647d928b38b0ecdb3">yyerror</a> (const char *s)</td></tr>
<tr class="memitem:ae8f066df77f8e6ef90971def778f8a0a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ae8f066df77f8e6ef90971def778f8a0a">pars_variable_declaration</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *node, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *type)</td></tr>
<tr class="memitem:a5cef0ffef4b90ab658711f8812417118"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a5cef0ffef4b90ab658711f8812417118">pars_func</a> (que_node_t *res_word, que_node_t *arg)</td></tr>
<tr class="memitem:ac40cf2056ec117725c812bb7e43bcd96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac40cf2056ec117725c812bb7e43bcd96"></a>
UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>pars_like_rebind</b> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *node, const byte *ptr, ulint len)</td></tr>
<tr class="memitem:ac707acf5a583b175c05917bc6d901e30"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ac707acf5a583b175c05917bc6d901e30">pars_op</a> (int func, que_node_t *arg1, que_node_t *arg2)</td></tr>
<tr class="memitem:af9ea40f4c875f6ad8baef2b522f10590"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structorder__node__t.html">order_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#af9ea40f4c875f6ad8baef2b522f10590">pars_order_by</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *column, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *asc)</td></tr>
<tr class="memitem:a9b005c62a8c5107f5e2ef03a546afe2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a9b005c62a8c5107f5e2ef03a546afe2f">pars_select_list</a> (que_node_t *select_list, <a class="el" href="structsym__node__t.html">sym_node_t</a> *into_list)</td></tr>
<tr class="memitem:a4eb10bce26f22c9a2d96be19ae9ac58d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN que_node_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a4eb10bce26f22c9a2d96be19ae9ac58d">pars_cursor_declaration</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *sym_node, <a class="el" href="structsel__node__t.html">sel_node_t</a> *select_node)</td></tr>
<tr class="memitem:a31d80603746de744d1426de38b5a59f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN que_node_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a31d80603746de744d1426de38b5a59f9">pars_function_declaration</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *sym_node)</td></tr>
<tr class="memitem:a7ea0262d4649d1cf2602f6a133deab1f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a7ea0262d4649d1cf2602f6a133deab1f">pars_select_statement</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *select_node, <a class="el" href="structsym__node__t.html">sym_node_t</a> *table_list, que_node_t *search_cond, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *for_update, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *consistent_read, <a class="el" href="structorder__node__t.html">order_node_t</a> *order_by)</td></tr>
<tr class="memitem:aeca7e5c8abc6e0dce9a9fcd9dd1788da"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structcol__assign__node__t.html">col_assign_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#aeca7e5c8abc6e0dce9a9fcd9dd1788da">pars_column_assignment</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *column, que_node_t *exp)</td></tr>
<tr class="memitem:a14158e32981d31e26fb2f75777a43cf4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a14158e32981d31e26fb2f75777a43cf4">pars_update_statement_start</a> (<a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> is_delete, <a class="el" href="structsym__node__t.html">sym_node_t</a> *table_sym, <a class="el" href="structcol__assign__node__t.html">col_assign_node_t</a> *col_assign_list)</td></tr>
<tr class="memitem:a60a9a0a1bcaa65f80fb99a6e8ef2c8a4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a60a9a0a1bcaa65f80fb99a6e8ef2c8a4">pars_update_statement</a> (<a class="el" href="structupd__node__t.html">upd_node_t</a> *node, <a class="el" href="structsym__node__t.html">sym_node_t</a> *cursor_sym, que_node_t *search_cond)</td></tr>
<tr class="memitem:a59667f25cdf0fcfbdcce05a5f0918a86"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structins__node__t.html">ins_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a59667f25cdf0fcfbdcce05a5f0918a86">pars_insert_statement</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *table_sym, que_node_t *values_list, <a class="el" href="structsel__node__t.html">sel_node_t</a> *select)</td></tr>
<tr class="memitem:ad7c08668782c3449f2fc14eb9bff1093"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad7c08668782c3449f2fc14eb9bff1093">pars_parameter_declaration</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *node, ulint param_type, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *type)</td></tr>
<tr class="memitem:a265d892e8dee608735705809c63eb31a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structelsif__node__t.html">elsif_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a265d892e8dee608735705809c63eb31a">pars_elsif_element</a> (que_node_t *cond, que_node_t *stat_list)</td></tr>
<tr class="memitem:afea713d9ab7fc8392537327e2508816b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structif__node__t.html">if_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#afea713d9ab7fc8392537327e2508816b">pars_if_statement</a> (que_node_t *cond, que_node_t *stat_list, que_node_t *else_part)</td></tr>
<tr class="memitem:a6961064bfa366b96fca4e5800ee2f97e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfor__node__t.html">for_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a6961064bfa366b96fca4e5800ee2f97e">pars_for_statement</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *loop_var, que_node_t *loop_start_limit, que_node_t *loop_end_limit, que_node_t *stat_list)</td></tr>
<tr class="memitem:ac14e05873827f02abab279e1028235bb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structwhile__node__t.html">while_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ac14e05873827f02abab279e1028235bb">pars_while_statement</a> (que_node_t *cond, que_node_t *stat_list)</td></tr>
<tr class="memitem:a2d6c28515822508b986584ec81b67d06"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structexit__node__t.html">exit_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a2d6c28515822508b986584ec81b67d06">pars_exit_statement</a> (void)</td></tr>
<tr class="memitem:addccf3d4b70f4cb0a8e68b54440676e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structreturn__node__t.html">return_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#addccf3d4b70f4cb0a8e68b54440676e8">pars_return_statement</a> (void)</td></tr>
<tr class="memitem:ac3ec5be1f8f0203aeec3286226adaa66"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ac3ec5be1f8f0203aeec3286226adaa66">pars_procedure_call</a> (que_node_t *res_word, que_node_t *args)</td></tr>
<tr class="memitem:ad30f7c2babb607e41b6887b6583aa690"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structassign__node__t.html">assign_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad30f7c2babb607e41b6887b6583aa690">pars_assignment_statement</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *var, que_node_t *val)</td></tr>
<tr class="memitem:a93b3d020acba5ac93309e7802e2e7beb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structfetch__node__t.html">fetch_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a93b3d020acba5ac93309e7802e2e7beb">pars_fetch_statement</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *cursor, <a class="el" href="structsym__node__t.html">sym_node_t</a> *into_list, <a class="el" href="structsym__node__t.html">sym_node_t</a> *user_func)</td></tr>
<tr class="memitem:a9ee5721fe08d4aac591ac2f0a1c2ce65"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structopen__node__t.html">open_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a9ee5721fe08d4aac591ac2f0a1c2ce65">pars_open_statement</a> (ulint type, <a class="el" href="structsym__node__t.html">sym_node_t</a> *cursor)</td></tr>
<tr class="memitem:a01e693ae15bcde3e48e1df14b6275f6c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structrow__printf__node__t.html">row_printf_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a01e693ae15bcde3e48e1df14b6275f6c">pars_row_printf_statement</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *sel_node)</td></tr>
<tr class="memitem:a4b9c9a6cc3613878fac178965a559c1e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structcommit__node__t.html">commit_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a4b9c9a6cc3613878fac178965a559c1e">pars_commit_statement</a> (void)</td></tr>
<tr class="memitem:a3e024a622ebf31d292eced939b3b5d6a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structroll__node__t.html">roll_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a3e024a622ebf31d292eced939b3b5d6a">pars_rollback_statement</a> (void)</td></tr>
<tr class="memitem:a0394e00b44c76aa2c31a9ca4e073529b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a0394e00b44c76aa2c31a9ca4e073529b">pars_column_def</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *sym_node, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *type, <a class="el" href="structsym__node__t.html">sym_node_t</a> *len, void *is_unsigned, void *is_not_null)</td></tr>
<tr class="memitem:a0790ecc26853ba94b679f155b53e3db0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structtab__node__t.html">tab_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a0790ecc26853ba94b679f155b53e3db0">pars_create_table</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *table_sym, <a class="el" href="structsym__node__t.html">sym_node_t</a> *column_defs, <a class="el" href="structsym__node__t.html">sym_node_t</a> *compact, <a class="el" href="structsym__node__t.html">sym_node_t</a> *block_size, void *not_fit_in_memory)</td></tr>
<tr class="memitem:a28ddbcee6ba521d0e14391d1483d744b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structind__node__t.html">ind_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a28ddbcee6ba521d0e14391d1483d744b">pars_create_index</a> (<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *unique_def, <a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *clustered_def, <a class="el" href="structsym__node__t.html">sym_node_t</a> *index_sym, <a class="el" href="structsym__node__t.html">sym_node_t</a> *table_sym, <a class="el" href="structsym__node__t.html">sym_node_t</a> *column_list)</td></tr>
<tr class="memitem:a8b5805f7ea6a4a7724e440d2ff8bf109"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a8b5805f7ea6a4a7724e440d2ff8bf109">pars_procedure_definition</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *sym_node, <a class="el" href="structsym__node__t.html">sym_node_t</a> *param_list, que_node_t *stat_list)</td></tr>
<tr class="memitem:ad127719c3358c5a4468528d8383e6287"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad127719c3358c5a4468528d8383e6287">pars_stored_procedure_call</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *sym_node)</td></tr>
<tr class="memitem:aeb6b09e3a164df06c1fb1645654ca741"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#aeb6b09e3a164df06c1fb1645654ca741">pars_complete_graph_for_exec</a> (que_node_t *node, <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a53ec7954ea446ad0d1f392287107a416"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a53ec7954ea446ad0d1f392287107a416">pars_info_create</a> (void)</td></tr>
<tr class="memitem:a4580cf09148b6861ee843bebcf8a0d31"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a4580cf09148b6861ee843bebcf8a0d31">pars_info_free</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info)</td></tr>
<tr class="memitem:ad28523c7117567dd7de44add50d046cb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad28523c7117567dd7de44add50d046cb">pars_info_add_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const void *address, ulint length, ulint type, ulint prtype)</td></tr>
<tr class="memitem:a1640ca682554baec29910ac665795f0d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a1640ca682554baec29910ac665795f0d">pars_info_add_str_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const char *str)</td></tr>
<tr class="memitem:a32e55ed6cad9d5aecf00f82dee250f7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e55ed6cad9d5aecf00f82dee250f7e"></a>
UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>pars_info_bind_literal</b> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const void *address, ulint length, ulint type, ulint prtype)</td></tr>
<tr class="memitem:af7d5c4197e71853b12cc063fa5eb94d9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#af7d5c4197e71853b12cc063fa5eb94d9">pars_info_bind_varchar_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const byte *str, ulint str_len)</td></tr>
<tr class="memitem:a1705050979ef4d2dd13c510631c773ab"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a1705050979ef4d2dd13c510631c773ab">pars_info_bind_int4_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const ib_uint32_t *val)</td></tr>
<tr class="memitem:a0f6b2657f30eeb7f96bc793750543733"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a0f6b2657f30eeb7f96bc793750543733">pars_info_bind_int8_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const ib_uint64_t *val)</td></tr>
<tr class="memitem:a5f22c7dac2e785364a3dc3c4336320b1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a5f22c7dac2e785364a3dc3c4336320b1">pars_info_bind_function</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, <a class="el" href="pars0pars_8h.html#a1e9efbd37c0721ae8149e5d2f10250da">pars_user_func_cb_t</a> func, void *arg)</td></tr>
<tr class="memitem:a3e047aadbc74cd3bfd418de7835d1435"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a3e047aadbc74cd3bfd418de7835d1435">pars_info_bind_id</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> copy_name, const char *name, const char *id)</td></tr>
<tr class="memitem:ad4dd7f60bdc5d3044379ef55151b25fc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ad4dd7f60bdc5d3044379ef55151b25fc">pars_info_add_int4_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, lint val)</td></tr>
<tr class="memitem:a2a65825bbd30d41ebf54cada3655feb1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a2a65825bbd30d41ebf54cada3655feb1">pars_info_add_ull_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, ib_uint64_t val)</td></tr>
<tr class="memitem:af5d779ad65692e4516509a281654f3da"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#af5d779ad65692e4516509a281654f3da">pars_info_bind_ull_literal</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const ib_uint64_t *val))</td></tr>
<tr class="memitem:a0daadcb3a47c9920a20f04dfcc3260eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a0daadcb3a47c9920a20f04dfcc3260eb">pars_info_add_id</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name, const char *id)</td></tr>
<tr class="memitem:a0a8696a3cc21880647b86e53337066d9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structpars__bound__lit__t.html">pars_bound_lit_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a0a8696a3cc21880647b86e53337066d9">pars_info_get_bound_lit</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name)</td></tr>
<tr class="memitem:a6331298c1c9434913faae0339a2d747a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structpars__bound__id__t.html">pars_bound_id_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a6331298c1c9434913faae0339a2d747a">pars_info_get_bound_id</a> (<a class="el" href="structpars__info__t.html">pars_info_t</a> *info, const char *name)</td></tr>
<tr class="memitem:a6be680514f082f754ec00c218003d8a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#a6be680514f082f754ec00c218003d8a7">pars_lexer_close</a> (void)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab138aa8e11f58bcdcc7134adf240ea8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pars0pars_8h.html#ab138aa8e11f58bcdcc7134adf240ea8c">yydebug</a></td></tr>
<tr class="memitem:aa33263c37bd1317c7bd674cc7ec5652a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa33263c37bd1317c7bd674cc7ec5652a"></a>
<a class="el" href="structsym__tab__t.html">sym_tab_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pars_sym_tab_global</b></td></tr>
<tr class="memitem:a819227e0e33719127b288d580d82baa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a819227e0e33719127b288d580d82baa3"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_to_char_token</b></td></tr>
<tr class="memitem:a811f13789dfb8f3dd4ca094dd60920bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a811f13789dfb8f3dd4ca094dd60920bc"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_to_number_token</b></td></tr>
<tr class="memitem:aca9b2878b0188b245696fd172a6a49a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9b2878b0188b245696fd172a6a49a0"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_to_binary_token</b></td></tr>
<tr class="memitem:ae9ab5b56edc21f77af716298f28c08e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9ab5b56edc21f77af716298f28c08e1"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_binary_to_number_token</b></td></tr>
<tr class="memitem:a9f578ab9f1ecf43877d616ed94774812"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f578ab9f1ecf43877d616ed94774812"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_substr_token</b></td></tr>
<tr class="memitem:a0004eaec38b1e9c686be13d3f2d62d2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0004eaec38b1e9c686be13d3f2d62d2d"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_replstr_token</b></td></tr>
<tr class="memitem:ab03a2a02207cd0246c03962de66d0e29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab03a2a02207cd0246c03962de66d0e29"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_concat_token</b></td></tr>
<tr class="memitem:a332711322d67c1510f238bdce5829b59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a332711322d67c1510f238bdce5829b59"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_length_token</b></td></tr>
<tr class="memitem:a001730b31a5212b5be1ca2721ce7458e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a001730b31a5212b5be1ca2721ce7458e"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_instr_token</b></td></tr>
<tr class="memitem:a8091c2671d276f62467d7aec4bef2363"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8091c2671d276f62467d7aec4bef2363"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_sysdate_token</b></td></tr>
<tr class="memitem:a730a36f61ba971faa383065c74b30002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a730a36f61ba971faa383065c74b30002"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_printf_token</b></td></tr>
<tr class="memitem:ae95665ad9c380d14eb4de659d821f33d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95665ad9c380d14eb4de659d821f33d"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_assert_token</b></td></tr>
<tr class="memitem:abeec697fa232d66f99766047e1c14764"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeec697fa232d66f99766047e1c14764"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_rnd_token</b></td></tr>
<tr class="memitem:a49f439473210439ef07e3ad07147b692"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f439473210439ef07e3ad07147b692"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_rnd_str_token</b></td></tr>
<tr class="memitem:ac0349c412dd969e70f39162c07391bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0349c412dd969e70f39162c07391bf5"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_count_token</b></td></tr>
<tr class="memitem:a1d5acf7fcec11a872799f049cc7716be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d5acf7fcec11a872799f049cc7716be"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_sum_token</b></td></tr>
<tr class="memitem:a7c83d0024057499cfda7eb0f13bfb4d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c83d0024057499cfda7eb0f13bfb4d6"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_distinct_token</b></td></tr>
<tr class="memitem:aa4a2738f2b34689c57edd1222a25b6ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a2738f2b34689c57edd1222a25b6ae"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_binary_token</b></td></tr>
<tr class="memitem:a707c44bf2ddd10b5942982fddcf8a27b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707c44bf2ddd10b5942982fddcf8a27b"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_blob_token</b></td></tr>
<tr class="memitem:a3f4baffb64f2fde0a1bf29e28851998e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f4baffb64f2fde0a1bf29e28851998e"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_int_token</b></td></tr>
<tr class="memitem:a9280206bffe70792100acc6d03e274ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9280206bffe70792100acc6d03e274ef"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_bigint_token</b></td></tr>
<tr class="memitem:acdfbf27f37f98e8a87dbd3e82a8d33b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdfbf27f37f98e8a87dbd3e82a8d33b4"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_char_token</b></td></tr>
<tr class="memitem:a61c404c674e054039f2e4212c0963cfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61c404c674e054039f2e4212c0963cfe"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_float_token</b></td></tr>
<tr class="memitem:adeba4491e9a5b2203a6db870938c1353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeba4491e9a5b2203a6db870938c1353"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_update_token</b></td></tr>
<tr class="memitem:aca4a552071b015349b7335929513c0e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4a552071b015349b7335929513c0e1"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_asc_token</b></td></tr>
<tr class="memitem:a62b00dc4912ca6764b10ae30db30ba4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b00dc4912ca6764b10ae30db30ba4c"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_desc_token</b></td></tr>
<tr class="memitem:af95787120d7b25d08ab9f74fd58d6031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af95787120d7b25d08ab9f74fd58d6031"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_open_token</b></td></tr>
<tr class="memitem:acceb3987d0782990189e6243bcb4c2bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acceb3987d0782990189e6243bcb4c2bf"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_close_token</b></td></tr>
<tr class="memitem:a3c8d13a9942d46a447dc4dc0263c147e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c8d13a9942d46a447dc4dc0263c147e"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_share_token</b></td></tr>
<tr class="memitem:a75e94b7d7a0088ee12ab6b8b9f43451f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e94b7d7a0088ee12ab6b8b9f43451f"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_unique_token</b></td></tr>
<tr class="memitem:adfb45a0926b687080e422f23e0f103c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb45a0926b687080e422f23e0f103c0"></a>
<a class="el" href="structpars__res__word__t.html">pars_res_word_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pars_clustered_token</b></td></tr>
<tr class="memitem:a1a51b1f992eb09832b569cadae52f9c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a51b1f992eb09832b569cadae52f9c5"></a>
ulint&#160;</td><td class="memItemRight" valign="bottom"><b>pars_star_denoter</b></td></tr>
<tr class="memitem:a9f2f369144c590feb5afaeed2cdfe3df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2f369144c590feb5afaeed2cdfe3df"></a>
UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>SQL parser</p>
<p>Created 11/19/1996 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a2dace9a7c2327026ba629bc98465425d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_AGGREGATE&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>COUNT, DISTINCT, SUM </p>

</div>
</div>
<a class="anchor" id="a8329df42cb52906a730edb5682723424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_ARITH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Classes of functions +, -, *, / </p>

</div>
</div>
<a class="anchor" id="a63f24c0b3eb0ebbfad88166cdd47cef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_CMP&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>comparison operators </p>

</div>
</div>
<a class="anchor" id="a3bc7140ac637012bfcd3dca48ff1502e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_LOGICAL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>AND, OR, NOT </p>

</div>
</div>
<a class="anchor" id="a09a4e425d9ca56fe6275fada91bcfa15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_OTHER&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>these are not real functions, e.g., := </p>

</div>
</div>
<a class="anchor" id="ad0ecb24f53349268063e02ffc38fe3e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PARS_FUNC_PREDEFINED&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TO_NUMBER, SUBSTR, ... </p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="a1e9efbd37c0721ae8149e5d2f10250da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>(* pars_user_func_cb_t)(void *arg, void *user_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Type of the user functions. The first argument is always InnoDB-supplied
</pre><p> and varies in type, while 'user_arg' is a user-supplied argument. The meaning of the return type also varies. See the individual use cases, e.g. the FETCH statement, for details on them. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ad30f7c2babb607e41b6887b6583aa690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structassign__node__t.html">assign_node_t</a>* pars_assignment_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an assignment statement. </p>
<dl class="section return"><dt>Returns</dt><dd>assignment statement node in: value to assign </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>in: variable to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeca7e5c8abc6e0dce9a9fcd9dd1788da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structcol__assign__node__t.html">col_assign_node_t</a>* pars_column_assignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a column assignment in an update. </p>
<dl class="section return"><dt>Returns</dt><dd>column assignment node in: value to assign </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>in: column to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0394e00b44c76aa2c31a9ca4e073529b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a>* pars_column_def </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>sym_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>is_unsigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>is_not_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a column definition at a table creation. </p>
<dl class="section return"><dt>Returns</dt><dd>column sym table node in: if not NULL, column is of type NOT NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_node</td><td>in: column node in the symbol table </td></tr>
    <tr><td class="paramname">type</td><td>in: data type </td></tr>
    <tr><td class="paramname">len</td><td>in: length of column, or NULL </td></tr>
    <tr><td class="paramname">is_unsigned</td><td>in: if not NULL, column is of type UNSIGNED. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b9c9a6cc3613878fac178965a559c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structcommit__node__t.html">commit_node_t</a>* pars_commit_statement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a commit statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: commit node struct </dd></dl>

</div>
</div>
<a class="anchor" id="aeb6b09e3a164df06c1fb1645654ca741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* pars_complete_graph_for_exec </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes a query graph by adding query thread and fork nodes above it and prepares the graph for running. The fork created is of type QUE_FORK_MYSQL_INTERFACE. </p>
<dl class="section return"><dt>Returns</dt><dd>query thread node to run </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: root node for an incomplete query graph, or NULL for dummy graph </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction handle </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28ddbcee6ba521d0e14391d1483d744b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structind__node__t.html">ind_node_t</a>* pars_create_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>unique_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>clustered_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>index_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>table_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an index creation operation. </p>
<dl class="section return"><dt>Returns</dt><dd>index create subgraph in: list of column names </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unique_def</td><td>in: not NULL if a unique index </td></tr>
    <tr><td class="paramname">clustered_def</td><td>in: not NULL if a clustered index </td></tr>
    <tr><td class="paramname">index_sym</td><td>in: index name node in the symbol table </td></tr>
    <tr><td class="paramname">table_sym</td><td>in: table name node in the symbol table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0790ecc26853ba94b679f155b53e3db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structtab__node__t.html">tab_node_t</a>* pars_create_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>table_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column_defs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>compact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>not_fit_in_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a table creation operation. </p>
<dl class="section return"><dt>Returns</dt><dd>table create subgraph in: a non-NULL pointer means that this is a table which in simulations should be simulated as not fitting in memory; thread is put to sleep to simulate disk accesses; NOTE that this flag is not stored to the data dictionary on disk, and the database will forget about non-NULL value if it has to reload the table definition from disk </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_sym</td><td>in: table name node in the symbol table </td></tr>
    <tr><td class="paramname">column_defs</td><td>in: list of column names </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4eb10bce26f22c9a2d96be19ae9ac58d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN que_node_t* pars_cursor_declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>sym_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>select_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a cursor declaration. </p>
<dl class="section return"><dt>Returns</dt><dd>sym_node in: select node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_node</td><td>in: cursor id node in the symbol table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a265d892e8dee608735705809c63eb31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structelsif__node__t.html">elsif_node_t</a>* pars_elsif_element </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>stat_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an elsif element. </p>
<dl class="section return"><dt>Returns</dt><dd>elsif node in: statement list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>in: if-condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d6c28515822508b986584ec81b67d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structexit__node__t.html">exit_node_t</a>* pars_exit_statement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an exit statement. </p>
<dl class="section return"><dt>Returns</dt><dd>exit statement node </dd></dl>

</div>
</div>
<a class="anchor" id="a93b3d020acba5ac93309e7802e2e7beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfetch__node__t.html">fetch_node_t</a>* pars_fetch_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>into_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>user_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a fetch statement. into_list or user_func (but not both) must be non-NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>fetch statement node in: user function name, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor node </td></tr>
    <tr><td class="paramname">into_list</td><td>in: variables to set, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6961064bfa366b96fca4e5800ee2f97e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfor__node__t.html">for_node_t</a>* pars_for_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>loop_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>loop_start_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>loop_end_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>stat_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a for-loop-statement. </p>
<dl class="section return"><dt>Returns</dt><dd>for-statement node in: statement list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop_var</td><td>in: loop variable </td></tr>
    <tr><td class="paramname">loop_start_limit</td><td>in: loop start expression </td></tr>
    <tr><td class="paramname">loop_end_limit</td><td>in: loop end expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cef0ffef4b90ab658711f8812417118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a>* pars_func </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>res_word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a function expression. </p>
<dl class="section return"><dt>Returns</dt><dd>own: function node in a query tree in: first argument in the argument list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_word</td><td>in: function name reserved word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31d80603746de744d1426de38b5a59f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN que_node_t* pars_function_declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>sym_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a function declaration. </p>
<dl class="section return"><dt>Returns</dt><dd>sym_node in: function id node in the symbol table </dd></dl>

</div>
</div>
<a class="anchor" id="a3401ee39a02d034d302f7d52151ea13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int pars_get_lex_chars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves characters to the lexical analyzer. </p>
<dl class="section return"><dt>Returns</dt><dd>number of characters copied or 0 on EOF in: maximum number of characters which fit in the buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer where to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afea713d9ab7fc8392537327e2508816b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structif__node__t.html">if_node_t</a>* pars_if_statement </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>stat_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>else_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an if-statement. </p>
<dl class="section return"><dt>Returns</dt><dd>if-statement node in: else-part statement list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>in: if-condition </td></tr>
    <tr><td class="paramname">stat_list</td><td>in: statement list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0daadcb3a47c9920a20f04dfcc3260eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_add_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add bound id. in: id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4dd7f60bdc5d3044379ef55151b25fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_add_int4_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lint&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to:</p>
<p>char buf[4]; mach_write_to_4(buf, val); pars_info_add_literal(info, name, buf, 4, DATA_INT, 0);</p>
<p>except that the buffer is dynamically allocated from the info struct's heap. in: value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad28523c7117567dd7de44add50d046cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_add_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add bound literal. in: precise type, e.g. DATA_UNSIGNED </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
    <tr><td class="paramname">address</td><td>in: address </td></tr>
    <tr><td class="paramname">length</td><td>in: length of data </td></tr>
    <tr><td class="paramname">type</td><td>in: type, e.g. DATA_FIXBINARY </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1640ca682554baec29910ac665795f0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_add_str_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to pars_info_add_literal(info, name, str, strlen(str), DATA_VARCHAR, DATA_ENGLISH). in: string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a65825bbd30d41ebf54cada3655feb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_add_ull_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to:</p>
<p>char buf[8]; mach_write_to_8(buf, val); pars_info_add_literal(info, name, buf, 8, DATA_FIXBINARY, 0);</p>
<p>except that the buffer is dynamically allocated from the info struct's heap. in: value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f22c7dac2e785364a3dc3c4336320b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pars0pars_8h.html#a1e9efbd37c0721ae8149e5d2f10250da">pars_user_func_cb_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add user function. in: user-supplied argument </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: function name </td></tr>
    <tr><td class="paramname">func</td><td>in: function address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e047aadbc74cd3bfd418de7835d1435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>copy_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add bound id. in: id </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1705050979ef4d2dd13c510631c773ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_int4_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ib_uint32_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to:</p>
<p>char buf[4]; mach_write_to_4(buf, val); pars_info_add_literal(info, name, buf, 4, DATA_INT, 0);</p>
<p>except that the buffer is dynamically allocated from the info struct's heap. in: value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f6b2657f30eeb7f96bc793750543733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_int8_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ib_uint64_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5d779ad65692e4516509a281654f3da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_ull_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ib_uint64_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the literal value already exists then it rebinds otherwise it creates a new entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
    <tr><td class="paramname">val</td><td>in: value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7d5c4197e71853b12cc063fa5eb94d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_bind_varchar_literal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>str_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in: string length </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
    <tr><td class="paramname">name</td><td>in: name </td></tr>
    <tr><td class="paramname">str</td><td>in: string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53ec7954ea446ad0d1f392287107a416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structpars__info__t.html">pars_info_t</a>* pars_info_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create parser info struct. </p>
<dl class="section return"><dt>Returns</dt><dd>own: info struct </dd></dl>

</div>
</div>
<a class="anchor" id="a4580cf09148b6861ee843bebcf8a0d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_info_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free info struct and everything it contains. in, own: info struct </p>

</div>
</div>
<a class="anchor" id="a6331298c1c9434913faae0339a2d747a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structpars__bound__id__t.html">pars_bound_id_t</a>* pars_info_get_bound_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get bound id with the given name. </p>
<dl class="section return"><dt>Returns</dt><dd>bound id, or NULL if not found in: bound id name to find </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a8696a3cc21880647b86e53337066d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structpars__bound__lit__t.html">pars_bound_lit_t</a>* pars_info_get_bound_lit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get bound literal with the given name. </p>
<dl class="section return"><dt>Returns</dt><dd>bound literal, or NULL if not found in: bound literal name to find </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: info struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59667f25cdf0fcfbdcce05a5f0918a86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structins__node__t.html">ins_node_t</a>* pars_insert_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>table_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>values_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an insert statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node in a query tree in: select condition or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_sym</td><td>in: table name node </td></tr>
    <tr><td class="paramname">values_list</td><td>in: value expression list or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6be680514f082f754ec00c218003d8a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void pars_lexer_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release any resources used by the lexer. </p>

</div>
</div>
<a class="anchor" id="ac707acf5a583b175c05917bc6d901e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a>* pars_op </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an operator expression. </p>
<dl class="section return"><dt>Returns</dt><dd>own: function node in a query tree in: second argument or NULL for an unary operator </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>in: operator token code </td></tr>
    <tr><td class="paramname">arg1</td><td>in: first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ee5721fe08d4aac591ac2f0a1c2ce65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structopen__node__t.html">open_node_t</a>* pars_open_statement </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an open or close cursor statement. </p>
<dl class="section return"><dt>Returns</dt><dd>fetch statement node in: cursor node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>in: ROW_SEL_OPEN_CURSOR or ROW_SEL_CLOSE_CURSOR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9ea40f4c875f6ad8baef2b522f10590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structorder__node__t.html">order_node_t</a>* pars_order_by </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>asc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an ORDER BY clause. Order by a single column only is supported. </p>
<dl class="section return"><dt>Returns</dt><dd>own: order-by node in a query tree in: &amp;pars_asc_token or pars_desc_token </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>in: column name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7c08668782c3449f2fc14eb9bff1093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a>* pars_parameter_declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>param_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a procedure parameter declaration. </p>
<dl class="section return"><dt>Returns</dt><dd>own: symbol table node of type SYM_VAR in: pointer to a type token </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: symbol table node allocated for the id of the parameter </td></tr>
    <tr><td class="paramname">param_type</td><td>in: PARS_INPUT or PARS_OUTPUT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3ec5be1f8f0203aeec3286226adaa66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structfunc__node__t.html">func_node_t</a>* pars_procedure_call </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>res_word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a procedure call. </p>
<dl class="section return"><dt>Returns</dt><dd>function node in: argument list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_word</td><td>in: procedure name reserved word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b5805f7ea6a4a7724e440d2ff8bf109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a>* pars_procedure_definition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>sym_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>param_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>stat_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a procedure definition. </p>
<dl class="section return"><dt>Returns</dt><dd>query fork node in: statement list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sym_node</td><td>in: procedure id node in the symbol table </td></tr>
    <tr><td class="paramname">param_list</td><td>in: parameter declaration list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addccf3d4b70f4cb0a8e68b54440676e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structreturn__node__t.html">return_node_t</a>* pars_return_statement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a return-statement. </p>
<dl class="section return"><dt>Returns</dt><dd>return-statement node </dd></dl>

</div>
</div>
<a class="anchor" id="a3e024a622ebf31d292eced939b3b5d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structroll__node__t.html">roll_node_t</a>* pars_rollback_statement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a rollback statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: rollback node struct </dd></dl>

</div>
</div>
<a class="anchor" id="a01e693ae15bcde3e48e1df14b6275f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structrow__printf__node__t.html">row_printf_node_t</a>* pars_row_printf_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>sel_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a row_printf-statement. </p>
<dl class="section return"><dt>Returns</dt><dd>row_printf-statement node in: select node </dd></dl>

</div>
</div>
<a class="anchor" id="a9b005c62a8c5107f5e2ef03a546afe2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsel__node__t.html">sel_node_t</a>* pars_select_list </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>select_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>into_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a select list; creates a query graph node for the whole SELECT statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: select node in a query tree in: variables list or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_list</td><td>in: select list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ea0262d4649d1cf2602f6a133deab1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsel__node__t.html">sel_node_t</a>* pars_select_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>select_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>search_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>for_update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>consistent_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorder__node__t.html">order_node_t</a> *&#160;</td>
          <td class="paramname"><em>order_by</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a select statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: select node in a query tree in: NULL or an order-by node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_node</td><td>in: select node already containing the select list </td></tr>
    <tr><td class="paramname">table_list</td><td>in: table list </td></tr>
    <tr><td class="paramname">search_cond</td><td>in: search condition or NULL </td></tr>
    <tr><td class="paramname">for_update</td><td>in: NULL or &amp;pars_update_token </td></tr>
    <tr><td class="paramname">consistent_read</td><td>in: NULL or &amp;pars_consistent_token </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a577d882907b30b31b8255269ab05dffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_t</a>* pars_sql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpars__info__t.html">pars_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an SQL string returning the query graph. </p>
<dl class="section return"><dt>Returns</dt><dd>own: the query graph in: SQL string </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>in: extra information, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad127719c3358c5a4468528d8383e6287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__fork__t.html">que_fork_t</a>* pars_stored_procedure_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>sym_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a stored procedure call, when this is not within another stored procedure, that is, the client issues a procedure call directly. In MySQL/InnoDB, stored InnoDB procedures are invoked via the parsed procedure tree, not via InnoDB SQL, so this function is not used. </p>
<dl class="section return"><dt>Returns</dt><dd>query graph in: stored procedure name </dd></dl>

</div>
</div>
<a class="anchor" id="a60a9a0a1bcaa65f80fb99a6e8ef2c8a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a>* pars_update_statement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>cursor_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>search_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses an update or delete statement. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node in a query tree in: search condition or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: update node </td></tr>
    <tr><td class="paramname">cursor_sym</td><td>in: pointer to a cursor entry in the symbol table or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14158e32981d31e26fb2f75777a43cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a>* pars_update_statement_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>is_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>table_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcol__assign__node__t.html">col_assign_node_t</a> *&#160;</td>
          <td class="paramname"><em>col_assign_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a delete or update statement start. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node in a query tree in: column assignment list, NULL if delete </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_delete</td><td>in: TRUE if delete </td></tr>
    <tr><td class="paramname">table_sym</td><td>in: table name node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f066df77f8e6ef90971def778f8a0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structsym__node__t.html">sym_node_t</a>* pars_variable_declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpars__res__word__t.html">pars_res_word_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a variable declaration. </p>
<dl class="section return"><dt>Returns</dt><dd>own: symbol table node of type SYM_VAR in: pointer to a type token </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: symbol table node allocated for the id of the variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac14e05873827f02abab279e1028235bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structwhile__node__t.html">while_node_t</a>* pars_while_statement </td>
          <td>(</td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">que_node_t *&#160;</td>
          <td class="paramname"><em>stat_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a while-statement. </p>
<dl class="section return"><dt>Returns</dt><dd>while-statement node in: statement list </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>in: while-condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a375b7efc8260487647d928b38b0ecdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void yyerror </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by yyparse on error. in: error message string </p>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="ab138aa8e11f58bcdcc7134adf240ea8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int yydebug</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If the following is set TRUE, the parser will emit debugging
</pre><p> information </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:26 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
