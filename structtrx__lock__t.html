<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: trx_lock_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">trx_lock_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for trx_lock_t:</div>
<div class="dyncontent">
<div class="center"><img src="structtrx__lock__t__coll__graph.png" border="0" usemap="#trx__lock__t_coll__map" alt="Collaboration graph"/></div>
<map name="trx__lock__t_coll__map" id="trx__lock__t_coll__map">
<area shape="rect" id="node2" href="structut__list__base.html" title="ut_list_base\&lt; ib_lock_t \&gt;" alt="" coords="588,269,769,297"/><area shape="rect" id="node4" href="structib__vector__t.html" title="ib_vector_t" alt="" coords="633,319,724,347"/><area shape="rect" id="node6" href="structib__alloc__t.html" title="ib_alloc_t" alt="" coords="321,269,401,297"/><area shape="rect" id="node9" href="structmem__block__info__t.html" title="mem_block_info_t" alt="" coords="5,349,144,377"/><area shape="rect" id="node11" href="structut__list__base.html" title="ut_list_base\&lt; mem_block_t \&gt;" alt="" coords="255,319,468,347"/><area shape="rect" id="node14" href="structut__list__node.html" title="ut_list_node\&lt; mem_block_t \&gt;" alt="" coords="255,446,468,474"/><area shape="rect" id="node27" href="structque__fork__t.html" title="que_fork_t" alt="" coords="317,146,405,174"/><area shape="rect" id="node17" href="structque__thr__t.html" title="que_thr_t" alt="" coords="637,99,720,127"/><area shape="rect" id="node19" href="structut__list__node.html" title="ut_list_node\&lt; que_thr_t \&gt;" alt="" coords="897,139,1087,167"/><area shape="rect" id="node24" href="structsrv__slot__t.html" title="srv_slot_t" alt="" coords="951,14,1033,42"/><area shape="rect" id="node22" href="structque__common__t.html" title="que_common_t" alt="" coords="13,85,136,113"/><area shape="rect" id="node33" href="structlock__t.html" title="lock_t" alt="" coords="649,421,708,449"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a8b7f840c1deb4b3322a24bff1a9d11b8"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a8b7f840c1deb4b3322a24bff1a9d11b8">n_active_thrs</a></td></tr>
<tr class="memitem:a5b5a11c3bcbef8f9f71497710587ba90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">que_state</a></td></tr>
<tr class="memitem:a3e14b7f69b10d6046cfddc88f9b0d5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a3e14b7f69b10d6046cfddc88f9b0d5df">wait_lock</a></td></tr>
<tr class="memitem:a09444e637794a39a2b97482d1256b73b"><td class="memItemLeft" align="right" valign="top">ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a09444e637794a39a2b97482d1256b73b">deadlock_mark</a></td></tr>
<tr class="memitem:afb2f454ead49718d7f34152f605f2eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#afb2f454ead49718d7f34152f605f2eec">was_chosen_as_deadlock_victim</a></td></tr>
<tr class="memitem:a4ab2bc88e411af161ff3c1e447c30ae4"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a4ab2bc88e411af161ff3c1e447c30ae4">wait_started</a></td></tr>
<tr class="memitem:affae4ec9c18be6c1f774472fae0bfbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#affae4ec9c18be6c1f774472fae0bfbc9">wait_thr</a></td></tr>
<tr class="memitem:a2b3a26f3c5dc889837e30b8bccd2f572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a2b3a26f3c5dc889837e30b8bccd2f572">lock_heap</a></td></tr>
<tr class="memitem:ab2d5e03e23cf0ef7dcccf98bf6508140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; ib_lock_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#ab2d5e03e23cf0ef7dcccf98bf6508140">trx_locks</a></td></tr>
<tr class="memitem:a5616df6a5e28c150a2c9fe90b8351fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structib__vector__t.html">ib_vector_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#a5616df6a5e28c150a2c9fe90b8351fac">table_locks</a></td></tr>
<tr class="memitem:ad1d5c7bfeea5d55b9b71a6ed2e016486"><td class="memItemLeft" align="right" valign="top"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrx__lock__t.html#ad1d5c7bfeea5d55b9b71a6ed2e016486">cancel</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Latching protocol for <a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">trx_lock_t::que_state</a>. <a class="el" href="structtrx__lock__t.html#a5b5a11c3bcbef8f9f71497710587ba90">trx_lock_t::que_state</a> captures the state of the query thread during the execution of a query. This is different from a transaction state. The query state of a transaction can be updated asynchronously by other threads. The other threads can be system threads, like the timeout monitor thread or user threads executing other queries. Another thing to be mindful of is that there is a delay between when a query thread is put into LOCK_WAIT state and before it actually starts waiting. Between these two events it is possible that the query thread is granted the lock it was waiting for, which implies that the state can be changed asynchronously.</p>
<p>All these operations take place within the context of locking. Therefore state changes within the locking code must acquire both the lock mutex and the trx-&gt;mutex when changing trx-&gt;lock.que_state to TRX_QUE_LOCK_WAIT or trx-&gt;lock.wait_lock to non-NULL but when the lock wait ends it is sufficient to only acquire the trx-&gt;mutex. To query the state either of the mutexes is sufficient within the locking code and no mutex is required when the query thread is no longer waiting. The locks and state of an active transaction. Protected by lock_sys-&gt;mutex, trx-&gt;mutex or both. </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="ad1d5c7bfeea5d55b9b71a6ed2e016486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> trx_lock_t::cancel</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TRUE if the transaction is being rolled back either via deadlock detection or due to lock timeout. The caller has to acquire the <a class="el" href="structtrx__t.html#aea04c751aa48ef4eaddade1d4627ec32">trx_t::mutex</a> in order to cancel the locks. In lock_trx_table_locks_remove() we check for this cancel of a transaction's locks and avoid reacquiring the trx mutex to prevent recursive deadlocks. Protected by both the lock sys mutex and the <a class="el" href="structtrx__t.html#aea04c751aa48ef4eaddade1d4627ec32">trx_t::mutex</a>. </p>

</div>
</div>
<a class="anchor" id="a09444e637794a39a2b97482d1256b73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ib_uint64_t trx_lock_t::deadlock_mark</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mark field that is initialized to and checked against lock_mark_counter by lock_deadlock_recursive(). </p>

</div>
</div>
<a class="anchor" id="a2b3a26f3c5dc889837e30b8bccd2f572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a>* trx_lock_t::lock_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>memory heap for trx_locks; protected by lock_sys-&gt;mutex </p>

</div>
</div>
<a class="anchor" id="a8b7f840c1deb4b3322a24bff1a9d11b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint trx_lock_t::n_active_thrs</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of active query threads </p>

</div>
</div>
<a class="anchor" id="a5b5a11c3bcbef8f9f71497710587ba90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a34bba6fbd37f499f7874fc416547759f">trx_que_t</a> trx_lock_t::que_state</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>valid when trx-&gt;state == TRX_STATE_ACTIVE: TRX_QUE_RUNNING, TRX_QUE_LOCK_WAIT, ... </p>

</div>
</div>
<a class="anchor" id="a5616df6a5e28c150a2c9fe90b8351fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structib__vector__t.html">ib_vector_t</a>* trx_lock_t::table_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All table locks requested by this transaction, including AUTOINC locks </p>

</div>
</div>
<a class="anchor" id="ab2d5e03e23cf0ef7dcccf98bf6508140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structut__list__base.html">ut_list_base</a>&lt; ib_lock_t &gt; trx_lock_t::trx_locks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>locks requested by the transaction; insertions are protected by trx-&gt;mutex and lock_sys-&gt;mutex; removals are protected by lock_sys-&gt;mutex </p>

</div>
</div>
<a class="anchor" id="a3e14b7f69b10d6046cfddc88f9b0d5df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__t.html">lock_t</a>* trx_lock_t::wait_lock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if trx execution state is TRX_QUE_LOCK_WAIT, this points to the lock request, otherwise this is NULL; set to non-NULL when holding both trx-&gt;mutex and lock_sys-&gt;mutex; set to NULL when holding lock_sys-&gt;mutex; readers should hold lock_sys-&gt;mutex, except when they are holding trx-&gt;mutex and wait_lock==NULL </p>

</div>
</div>
<a class="anchor" id="a4ab2bc88e411af161ff3c1e447c30ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t trx_lock_t::wait_started</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lock wait started at this time, protected only by lock_sys-&gt;mutex </p>

</div>
</div>
<a class="anchor" id="affae4ec9c18be6c1f774472fae0bfbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* trx_lock_t::wait_thr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>query thread belonging to this trx that is in QUE_THR_LOCK_WAIT state. For threads suspended in a lock wait, this is protected by lock_sys-&gt;mutex. Otherwise, this may only be modified by the thread that is serving the running transaction. </p>

</div>
</div>
<a class="anchor" id="afb2f454ead49718d7f34152f605f2eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> trx_lock_t::was_chosen_as_deadlock_victim</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when the transaction decides to wait for a lock, it sets this to FALSE; if another transaction chooses this transaction as a victim in deadlock resolution, it sets this to TRUE. Protected by trx-&gt;mutex. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:28 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
