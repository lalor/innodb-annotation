<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/ut0mem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ut0mem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="os0sync_8h_source.html">os0sync.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0mem_8ic.html">ut0mem.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ut0mem.h:</div>
<div class="dyncontent">
<div class="center"><img src="ut0mem_8h__incl.png" border="0" usemap="#include_2ut0mem_8h" alt=""/></div>
<map name="include_2ut0mem_8h" id="include_2ut0mem_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="646,315,700,343"/><area shape="rect" id="node27" href="os0sync_8h.html" title="os0sync.h" alt="" coords="845,470,930,498"/><area shape="rect" id="node34" href="ut0mem_8ic.html" title="ut0mem.ic" alt="" coords="709,83,800,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="682,393,760,421"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="784,393,850,421"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="348,470,422,498"/><area shape="rect" id="node36" href="ut0byte_8h.html" title="ut0byte.h" alt="" coords="672,238,754,266"/><area shape="rect" id="node39" href="mach0data_8h.html" title="mach0data.h" alt="" coords="738,161,845,189"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ut0mem_8h__dep__incl.png" border="0" usemap="#include_2ut0mem_8hdep" alt=""/></div>
<map name="include_2ut0mem_8hdep" id="include_2ut0mem_8hdep">
<area shape="rect" id="node3" href="mach0data_8ic.html" title="include/mach0data.ic" alt="" coords="388,83,545,111"/><area shape="rect" id="node7" href="mem0mem_8h.html" title="include/mem0mem.h" alt="" coords="504,238,661,266"/><area shape="rect" id="node13" href="dict0mem_8h.html" title="include/dict0mem.h" alt="" coords="373,470,520,498"/><area shape="rect" id="node15" href="dict0dict_8h.html" title="include/dict0dict.h" alt="" coords="252,547,388,575"/><area shape="rect" id="node38" href="sync0sync_8h.html" title="include/sync0sync.h" alt="" coords="644,161,793,189"/><area shape="rect" id="node61" href="sync0arr_8h.html" title="include/sync0arr.h" alt="" coords="671,83,807,111"/><area shape="rect" id="node64" href="ut0rbt_8h.html" title="include/ut0rbt.h" alt="" coords="939,315,1061,343"/><area shape="rect" id="node69" href="ut0bh_8ic.html" title="include/ut0bh.ic" alt="" coords="1339,83,1461,111"/><area shape="rect" id="node5" href="mach0data_8h.html" title="include/mach0data.h" alt="" coords="389,161,544,189"/><area shape="rect" id="node35" href="mtr0mtr_8ic.html" title="include/mtr0mtr.ic" alt="" coords="144,315,283,343"/><area shape="rect" id="node9" href="hash0hash_8h.html" title="include/hash0hash.h" alt="" coords="509,315,661,343"/><area shape="rect" id="node11" href="fts0fts_8h.html" title="include/fts0fts.h" alt="" coords="611,393,733,421"/><area shape="rect" id="node23" href="trx0sys_8h.html" title="include/trx0sys.h" alt="" coords="1144,470,1272,498"/><area shape="rect" id="node21" href="buf0buf_8h.html" title="include/buf0buf.h" alt="" coords="960,393,1091,421"/><area shape="rect" id="node19" href="fts0types_8h.html" title="include/fts0types.h" alt="" coords="640,470,781,498"/><area shape="rect" id="node17" href="lock0lock_8ic.html" title="include/lock0lock.ic" alt="" coords="863,625,1004,653"/><area shape="rect" id="node26" href="buf0buddy_8ic.html" title="include/buf0buddy.ic" alt="" coords="971,470,1120,498"/><area shape="rect" id="node41" href="log0log_8h.html" title="include/log0log.h" alt="" coords="787,315,915,343"/><area shape="rect" id="node44" href="srv0srv_8h.html" title="include/srv0srv.h" alt="" coords="757,393,885,421"/><area shape="rect" id="node47" href="sync0rw_8h.html" title="include/sync0rw.h" alt="" coords="347,238,480,266"/><area shape="rect" id="node71" href="ut0bh_8h.html" title="include/ut0bh.h" alt="" coords="1340,161,1460,189"/></map>
</div>
</div>
<p><a href="ut0mem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af45d7208632c06d0806165cc2b84370b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#af45d7208632c06d0806165cc2b84370b">ut_malloc</a>(n)&#160;&#160;&#160;<a class="el" href="ut0mem_8h.html#ad2c66896f8ae1dd338e10c202d4a2410">ut_malloc_low</a>(n, TRUE)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae46ac5cb8be8d1cba812480a71007cfd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ae46ac5cb8be8d1cba812480a71007cfd">ut_memcpy</a> (void *dest, const void *sour, ulint n)</td></tr>
<tr class="memitem:ae3869c7f784b9bf5979a9d52e6562523"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ae3869c7f784b9bf5979a9d52e6562523">ut_memmove</a> (void *dest, const void *sour, ulint n)</td></tr>
<tr class="memitem:a606e39d960b5c600f7f02dfd378d4597"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a606e39d960b5c600f7f02dfd378d4597">ut_memcmp</a> (const void *str1, const void *str2, ulint n)</td></tr>
<tr class="memitem:a76b2a56b2abf87ef97001adf5d443513"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a76b2a56b2abf87ef97001adf5d443513">ut_mem_init</a> (void)</td></tr>
<tr class="memitem:ad2c66896f8ae1dd338e10c202d4a2410"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ad2c66896f8ae1dd338e10c202d4a2410">ut_malloc_low</a> (ulint n, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> assert_on_error))</td></tr>
<tr class="memitem:a9b62984945c78f9b88ff6b857faf6fd4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a9b62984945c78f9b88ff6b857faf6fd4">ut_free</a> (void *ptr)</td></tr>
<tr class="memitem:a7c82273ea2d85aaa920f319ee6f886e6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a7c82273ea2d85aaa920f319ee6f886e6">ut_realloc</a> (void *ptr, ulint size)</td></tr>
<tr class="memitem:abc3e259f2b4397229654e3ff855600fc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#abc3e259f2b4397229654e3ff855600fc">ut_free_all_mem</a> (void)</td></tr>
<tr class="memitem:a6ffcb9c007799972d8166369e540309d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a6ffcb9c007799972d8166369e540309d">ut_strcpy</a> (char *dest, const char *sour)</td></tr>
<tr class="memitem:a5def94673c888fec3317cef51176abd1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a5def94673c888fec3317cef51176abd1">ut_strlen</a> (const char *str)</td></tr>
<tr class="memitem:a57d6cde2c9e72b100abd9387345f8d5a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a57d6cde2c9e72b100abd9387345f8d5a">ut_strcmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="memitem:af40bcb512f5d8c45a601852e49a5eaeb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#af40bcb512f5d8c45a601852e49a5eaeb">ut_strlcpy</a> (char *dst, const char *src, ulint size)</td></tr>
<tr class="memitem:a05589b775b882e0e83716df0616073fd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a05589b775b882e0e83716df0616073fd">ut_strlcpy_rev</a> (char *dst, const char *src, ulint size)</td></tr>
<tr class="memitem:ac771c7309a91527bb7b5cfe40e6a2a5c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ac771c7309a91527bb7b5cfe40e6a2a5c">ut_strcount</a> (const char *s1, const char *s2)</td></tr>
<tr class="memitem:a2c268612b98795d01d49e2e741537dab"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#a2c268612b98795d01d49e2e741537dab">ut_strreplace</a> (const char *str, const char *s1, const char *s2)</td></tr>
<tr class="memitem:a0d84dac6ac30f3108a78a94680cfffe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d84dac6ac30f3108a78a94680cfffe9"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>ut_str3cat</b> (const char *s1, const char *s2, const char *s3)</td></tr>
<tr class="memitem:ab0c428872995f7520e57a3f9e1e91a01"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ab0c428872995f7520e57a3f9e1e91a01">ut_raw_to_hex</a> (const void *raw, ulint raw_size, char *hex, ulint hex_size)</td></tr>
<tr class="memitem:aa8dbe1fcbd03258c2d8698fbfc8474dc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#aa8dbe1fcbd03258c2d8698fbfc8474dc">ut_str_sql_format</a> (const char *str, ulint str_len, char *buf, ulint buf_size)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad184ac85bd316658026a02cb5b1f265c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#ad184ac85bd316658026a02cb5b1f265c">ut_total_allocated_memory</a></td></tr>
<tr class="memitem:aacb3ef99ba2b05249a1d71ddc03f836b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structos__fast__mutex__t.html">os_fast_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0mem_8h.html#aacb3ef99ba2b05249a1d71ddc03f836b">ut_list_mutex</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Memory primitives</p>
<p>Created 5/30/1994 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="af45d7208632c06d0806165cc2b84370b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ut_malloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ut0mem_8h.html#ad2c66896f8ae1dd338e10c202d4a2410">ut_malloc_low</a>(n, TRUE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a9b62984945c78f9b88ff6b857faf6fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a memory block allocated with ut_malloc. Freeing a NULL pointer is a nop. in, own: memory block, can be NULL </p>

</div>
</div>
<a class="anchor" id="abc3e259f2b4397229654e3ff855600fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_free_all_mem </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees in shutdown all allocated memory not freed yet. </p>

</div>
</div>
<a class="anchor" id="ad2c66896f8ae1dd338e10c202d4a2410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* ut_malloc_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>assert_on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory. </p>
<dl class="section return"><dt>Returns</dt><dd>own: allocated memory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of bytes to allocate </td></tr>
    <tr><td class="paramname">assert_on_error</td><td>in: if TRUE, we crash mysqld if the memory cannot be allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76b2a56b2abf87ef97001adf5d443513"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void ut_mem_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the mem block list at database startup. </p>

</div>
</div>
<a class="anchor" id="a606e39d960b5c600f7f02dfd378d4597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE int ut_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for memcmp(3). Compare memory areas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>in: first memory block to compare </td></tr>
    <tr><td class="paramname">str2</td><td>in: second memory block to compare </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative, 0, or positive if str1 is smaller, equal, or greater than str2, respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="ae46ac5cb8be8d1cba812480a71007cfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* ut_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper for memcpy(3).  Copy memory area when the source and
</pre><p> target are not overlapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ae3869c7f784b9bf5979a9d52e6562523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void* ut_memmove </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>sour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrapper for memmove(3).  Copy memory area when the source and
</pre><p> target are overlapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
    <tr><td class="paramname">n</td><td>in: number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ab0c428872995f7520e57a3f9e1e91a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_raw_to_hex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>raw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>raw_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>hex_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a raw binary data to a NUL-terminated hex string. The output is truncated if there is not enough space in "hex", make sure "hex_size" is at least (2 * raw_size + 1) if you do not want this to happen. Returns the actual number of characters written to "hex" (including the NUL). </p>
<dl class="section return"><dt>Returns</dt><dd>number of chars written in: "hex" size in bytes</dd></dl>
<p>Converts a raw binary data to a NUL-terminated hex string. The output is truncated if there is not enough space in "hex", make sure "hex_size" is at least (2 * raw_size + 1) if you do not want this to happen. Returns the actual number of characters written to "hex" (including the NUL). </p>
<dl class="section return"><dt>Returns</dt><dd>number of chars written </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>in: raw data </td></tr>
    <tr><td class="paramname">raw_size</td><td>in: "raw" length in bytes </td></tr>
    <tr><td class="paramname">hex</td><td>out: hex string </td></tr>
    <tr><td class="paramname">hex_size</td><td>in: "hex" size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c82273ea2d85aaa920f319ee6f886e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void* ut_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements realloc. This is needed by /pars/lexyy.cc. Otherwise, you should not use this function because the allocation functions in <a class="el" href="mem0mem_8h.html">mem0mem.h</a> are the recommended ones in InnoDB.</p>
<p>man realloc in Linux, 2004: </p>
<pre class="fragment">   realloc()  changes the size of the memory block pointed to
   by ptr to size bytes.  The contents will be  unchanged  to
   the minimum of the old and new sizes; newly allocated mem­
   ory will be uninitialized.  If ptr is NULL,  the  call  is
   equivalent  to malloc(size); if size is equal to zero, the
   call is equivalent to free(ptr).  Unless ptr is  NULL,  it
   must  have  been  returned by an earlier call to malloc(),
   calloc() or realloc().
</pre><p>RETURN VALUE realloc() returns a pointer to the newly allocated memory, which is suitably aligned for any kind of variable and may be different from ptr, or NULL if the request fails. If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned. If realloc() fails the original block is left untouched - it is not freed or moved. </p>
<dl class="section return"><dt>Returns</dt><dd>own: pointer to new mem block or NULL in: desired size </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: pointer to old block or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8dbe1fcbd03258c2d8698fbfc8474dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_str_sql_format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>str_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds single quotes to the start and end of string and escapes any quotes by doubling them. Returns the number of bytes that were written to "buf" (including the terminating NUL). If buf_size is too small then the trailing bytes from "str" are discarded. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes that were written in: output buffer size in bytes</dd></dl>
<p>Adds single quotes to the start and end of string and escapes any quotes by doubling them. Returns the number of bytes that were written to "buf" (including the terminating NUL). If buf_size is too small then the trailing bytes from "str" are discarded. </p>
<dl class="section return"><dt>Returns</dt><dd>number of bytes that were written </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string </td></tr>
    <tr><td class="paramname">str_len</td><td>in: string length in bytes </td></tr>
    <tr><td class="paramname">buf</td><td>out: output buffer </td></tr>
    <tr><td class="paramname">buf_size</td><td>in: output buffer size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57d6cde2c9e72b100abd9387345f8d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE int ut_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strcmp(3). Compare NUL-terminated strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>in: first string to compare </td></tr>
    <tr><td class="paramname">str2</td><td>in: second string to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative, 0, or positive if str1 is smaller, equal, or greater than str2, respectively. </dd></dl>

</div>
</div>
<a class="anchor" id="ac771c7309a91527bb7b5cfe40e6a2a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strcount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of times s2 occurs in s1. Overlapping instances of s2 are only counted once. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of times s2 occurs in s1 in: string to search for </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>in: string to search in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ffcb9c007799972d8166369e540309d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE char* ut_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strcpy(3). Copy a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>in: copy to </td></tr>
    <tr><td class="paramname">sour</td><td>in: copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="af40bcb512f5d8c45a601852e49a5eaeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies up to size - 1 characters from the NUL-terminated string src to dst, NUL-terminating the result. Returns strlen(src), so truncation occurred if the return value &gt;= size. </p>
<dl class="section return"><dt>Returns</dt><dd>strlen(src) in: size of destination buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>in: source buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05589b775b882e0e83716df0616073fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint ut_strlcpy_rev </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like ut_strlcpy, but if src doesn't fit in dst completely, copies the last (size - 1) bytes of src, not the first. </p>
<dl class="section return"><dt>Returns</dt><dd>strlen(src) in: size of destination buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>in: source buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5def94673c888fec3317cef51176abd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ut_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for strlen(3). Determine the length of a NUL-terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the string in bytes, excluding the terminating NUL </dd></dl>

</div>
</div>
<a class="anchor" id="a2c268612b98795d01d49e2e741537dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN char* ut_strreplace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace every occurrence of s1 in str with s2. Overlapping instances of s1 are only replaced once. </p>
<dl class="section return"><dt>Returns</dt><dd>own: modified string, must be freed with <a class="el" href="mem0mem_8h.html#a4cdeda261ea5f6db299898f33e6bbdbf">mem_free()</a> in: string to replace s1 with </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>in: string to operate on </td></tr>
    <tr><td class="paramname">s1</td><td>in: string to replace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="aacb3ef99ba2b05249a1d71ddc03f836b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structos__fast__mutex__t.html">os_fast_mutex_t</a> ut_list_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutex protecting ut_total_allocated_memory and ut_mem_block_list </p>

</div>
</div>
<a class="anchor" id="ad184ac85bd316658026a02cb5b1f265c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ut_total_allocated_memory</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The total amount of memory currently allocated from the operating
</pre><p> system with <a class="el" href="os0proc_8h.html#a52cad9f64959d2e729c09dcd0490f635">os_mem_alloc_large()</a> or malloc(). Does not count malloc() if srv_use_sys_malloc is set. Protected by ut_list_mutex. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:27 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
