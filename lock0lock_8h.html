<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/lock0lock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0lock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mtr0types_8h_source.html">mtr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rem0types_8h_source.html">rem0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lock0types_8h_source.html">lock0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="read0types_8h_source.html">read0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hash0hash_8h_source.html">hash0hash.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="srv0srv_8h_source.html">srv0srv.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="lock0lock_8ic.html">lock0lock.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for lock0lock.h:</div>
<div class="dyncontent">
<div class="center"><img src="lock0lock_8h__incl.png" border="0" usemap="#include_2lock0lock_8h" alt=""/></div>
<map name="include_2lock0lock_8h" id="include_2lock0lock_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="1321,702,1375,730"/><area shape="rect" id="node31" href="buf0types_8h.html" title="buf0types.h" alt="" coords="363,470,459,498"/><area shape="rect" id="node33" href="trx0types_8h.html" title="trx0types.h" alt="" coords="1344,470,1437,498"/><area shape="rect" id="node38" href="mtr0types_8h.html" title="mtr0types.h" alt="" coords="1069,470,1168,498"/><area shape="rect" id="node40" href="rem0types_8h.html" title="rem0types.h" alt="" coords="2328,470,2429,498"/><area shape="rect" id="node42" href="dict0types_8h.html" title="dict0types.h" alt="" coords="2139,547,2237,575"/><area shape="rect" id="node44" href="que0types_8h.html" title="que0types.h" alt="" coords="2051,393,2152,421"/><area shape="rect" id="node59" href="lock0types_8h.html" title="lock0types.h" alt="" coords="2864,393,2965,421"/><area shape="rect" id="node61" href="read0types_8h.html" title="read0types.h" alt="" coords="2581,393,2688,421"/><area shape="rect" id="node63" href="hash0hash_8h.html" title="hash0hash.h" alt="" coords="789,470,893,498"/><area shape="rect" id="node78" href="srv0srv_8h.html" title="srv0srv.h" alt="" coords="392,315,469,343"/><area shape="rect" id="node98" href="ut0vec_8h.html" title="ut0vec.h" alt="" coords="3141,393,3219,421"/><area shape="rect" id="node104" href="lock0lock_8ic.html" title="lock0lock.ic" alt="" coords="1528,83,1621,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="1213,779,1291,807"/><area shape="rect" id="node22" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="1315,779,1381,807"/><area shape="rect" id="node25" href="db0err_8h.html" title="db0err.h" alt="" coords="1381,857,1456,885"/><area shape="rect" id="node27" href="os0sync_8h.html" title="os0sync.h" alt="" coords="631,857,716,885"/><area shape="rect" id="node35" href="ut0byte_8h.html" title="ut0byte.h" alt="" coords="1307,625,1389,653"/><area shape="rect" id="node46" href="data0data_8h.html" title="data0data.h" alt="" coords="1968,470,2067,498"/><area shape="rect" id="node49" href="mem0mem_8h.html" title="mem0mem.h" alt="" coords="1480,547,1589,575"/><area shape="rect" id="node53" href="sync0sync_8h.html" title="sync0sync.h" alt="" coords="412,625,511,653"/><area shape="rect" id="node68" href="sync0rw_8h.html" title="sync0rw.h" alt="" coords="600,547,683,575"/><area shape="rect" id="node76" href="hash0hash_8ic.html" title="hash0hash.ic" alt="" coords="859,547,965,575"/><area shape="rect" id="node71" href="ut0counter_8h.html" title="ut0counter.h" alt="" coords="535,625,636,653"/><area shape="rect" id="node81" href="log0log_8h.html" title="log0log.h" alt="" coords="584,470,664,498"/><area shape="rect" id="node91" href="srv0conc_8h_source.html" title="srv0conc.h" alt="" coords="344,393,435,421"/><area shape="rect" id="node93" href="buf0checksum_8h_source.html" title="buf0checksum.h" alt="" coords="195,393,320,421"/><area shape="rect" id="node102" href="ut0vec_8ic.html" title="ut0vec.ic" alt="" coords="3141,470,3219,498"/><area shape="rect" id="node108" href="dict0dict_8h.html" title="dict0dict.h" alt="" coords="1533,393,1621,421"/><area shape="rect" id="node121" href="row0row_8h.html" title="row0row.h" alt="" coords="2253,315,2339,343"/><area shape="rect" id="node130" href="trx0sys_8h.html" title="trx0sys.h" alt="" coords="1161,315,1241,343"/><area shape="rect" id="node134" href="buf0buf_8h.html" title="buf0buf.h" alt="" coords="821,393,901,421"/><area shape="rect" id="node146" href="trx0trx_8h.html" title="trx0trx.h" alt="" coords="2621,315,2696,343"/><area shape="rect" id="node158" href="page0page_8h.html" title="page0page.h" alt="" coords="1347,315,1453,343"/><area shape="rect" id="node164" href="page0cur_8h.html" title="page0cur.h" alt="" coords="1528,238,1621,266"/><area shape="rect" id="node170" href="row0vers_8h.html" title="row0vers.h" alt="" coords="2363,315,2453,343"/><area shape="rect" id="node179" href="que0que_8h.html" title="que0que.h" alt="" coords="1917,238,2008,266"/><area shape="rect" id="node187" href="btr0cur_8h.html" title="btr0cur.h" alt="" coords="1696,161,1773,189"/><area shape="rect" id="node193" href="read0read_8h.html" title="read0read.h" alt="" coords="2528,238,2627,266"/><area shape="rect" id="node199" href="log0recv_8h.html" title="log0recv.h" alt="" coords="611,393,696,421"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="lock0lock_8h__dep__incl.png" border="0" usemap="#include_2lock0lock_8hdep" alt=""/></div>
<map name="include_2lock0lock_8hdep" id="include_2lock0lock_8hdep">
<area shape="rect" id="node3" href="row0upd_8ic.html" title="include/row0upd.ic" alt="" coords="7,83,145,111"/><area shape="rect" id="node5" href="row0upd_8h.html" title="include/row0upd.h" alt="" coords="8,161,144,189"/></map>
</div>
</div>
<p><a href="lock0lock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__op__t.html">lock_op_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlock__sys__t.html">lock_sys_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab55bf242eefa1adae272425906fb4fad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab55bf242eefa1adae272425906fb4fad">lock_mutex_enter_nowait</a>()&#160;&#160;&#160;mutex_enter_nowait(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;mutex)</td></tr>
<tr class="memitem:a2627320b3fe16bdedeed909919de3e58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2627320b3fe16bdedeed909919de3e58">lock_mutex_own</a>()&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;mutex)</td></tr>
<tr class="memitem:aa0bfbe3afb8e847cdafb2bb6457b6721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aa0bfbe3afb8e847cdafb2bb6457b6721">lock_mutex_enter</a>()</td></tr>
<tr class="memitem:a3974c25207bb78672d5c167125cc80ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3974c25207bb78672d5c167125cc80ff">lock_mutex_exit</a>()</td></tr>
<tr class="memitem:aaf586f74bea52a9f41cb48d219e03cda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aaf586f74bea52a9f41cb48d219e03cda">lock_wait_mutex_own</a>()&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;wait_mutex)</td></tr>
<tr class="memitem:af316b7272e81c47c1548d22025f542e3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af316b7272e81c47c1548d22025f542e3">lock_wait_mutex_enter</a>()</td></tr>
<tr class="memitem:acac7466a6379499864e831e92c950956"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acac7466a6379499864e831e92c950956">lock_wait_mutex_exit</a>()</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aea25ac33bd6692ef77c95c6a7da765a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aea25ac33bd6692ef77c95c6a7da765a8">LOCK_MODE_MASK</a>&#160;&#160;&#160;0xFUL</td></tr>
<tr class="memitem:a3f5d26fd94580daba78f376b8ca887dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3f5d26fd94580daba78f376b8ca887dd">LOCK_TABLE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memitem:a145ae646d1def688ee264b9d98c2e981"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a145ae646d1def688ee264b9d98c2e981">LOCK_REC</a>&#160;&#160;&#160;32</td></tr>
<tr class="memitem:a51876da8368dde6b362ce3c465dcc9eb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a51876da8368dde6b362ce3c465dcc9eb">LOCK_TYPE_MASK</a>&#160;&#160;&#160;0xF0UL</td></tr>
<tr class="memitem:a92ad796dd0adc2da08468a220376fe76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a92ad796dd0adc2da08468a220376fe76">LOCK_WAIT</a>&#160;&#160;&#160;256</td></tr>
<tr class="memitem:a95f8dd3d016d01aaa314160f0db74e75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a95f8dd3d016d01aaa314160f0db74e75">LOCK_ORDINARY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a8631af3f85d4c19484f6de819b2b2a37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a8631af3f85d4c19484f6de819b2b2a37">LOCK_GAP</a>&#160;&#160;&#160;512</td></tr>
<tr class="memitem:a5ec9b0cce21ee17de083d3bb96b1bec6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5ec9b0cce21ee17de083d3bb96b1bec6">LOCK_REC_NOT_GAP</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memitem:a7a448126f7465de2aa940d1751dd8b7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7a448126f7465de2aa940d1751dd8b7e">LOCK_INSERT_INTENTION</a>&#160;&#160;&#160;2048</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd6d281988732c472d3e0f7eac4d6e4e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afd6d281988732c472d3e0f7eac4d6e4e">lock_get_size</a> (void)</td></tr>
<tr class="memitem:a40ad348feb00e96aec397b06dbec7c64"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a40ad348feb00e96aec397b06dbec7c64">lock_sys_create</a> (ulint n_cells)</td></tr>
<tr class="memitem:a9c2350ce483b08686c48c19407f63da9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9c2350ce483b08686c48c19407f63da9">lock_sys_close</a> (void)</td></tr>
<tr class="memitem:a9d299943e5932310b8db82f441b885f5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9d299943e5932310b8db82f441b885f5">lock_get_min_heap_no</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a7273b2c3c75e90408bdc5a711effc73a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7273b2c3c75e90408bdc5a711effc73a">lock_move_reorganize_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *oblock)</td></tr>
<tr class="memitem:adb43b7be638bd32fa36b7c025d636bb6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adb43b7be638bd32fa36b7c025d636bb6">lock_move_rec_list_end</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec)</td></tr>
<tr class="memitem:a23e7197a446aee79574d335d277aaa84"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a23e7197a446aee79574d335d277aaa84">lock_move_rec_list_start</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, const rec_t *old_end)</td></tr>
<tr class="memitem:a9cd5be77aa944f96aa6ff0aeebc6eb98"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9cd5be77aa944f96aa6ff0aeebc6eb98">lock_update_split_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memitem:a9ec2bdadfd1e57ddbedfc05740e884eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a9ec2bdadfd1e57ddbedfc05740e884eb">lock_update_merge_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const rec_t *orig_succ, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memitem:a82e3b8ed16aaab0770730fb554e23af2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a82e3b8ed16aaab0770730fb554e23af2">lock_update_root_raise</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *root)</td></tr>
<tr class="memitem:a6cc8f00508ee648886c7d51046af30d1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a6cc8f00508ee648886c7d51046af30d1">lock_update_copy_and_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a5beb29b82077fbb4080d16b8214c1d57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5beb29b82077fbb4080d16b8214c1d57">lock_update_split_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memitem:a742d185fcf374672c516427602f386eb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a742d185fcf374672c516427602f386eb">lock_update_merge_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block, const rec_t *orig_pred, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block)</td></tr>
<tr class="memitem:af1a1ced4eeb3daa98b39ee2365df8b1a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af1a1ced4eeb3daa98b39ee2365df8b1a">lock_rec_reset_and_inherit_gap_locks</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="memitem:a47d322cfc717fe99e4c5c88f7b93512e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a47d322cfc717fe99e4c5c88f7b93512e">lock_update_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, ulint heir_heap_no, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>)</td></tr>
<tr class="memitem:a7b800d596ae20af9b8b28f7a879658b4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7b800d596ae20af9b8b28f7a879658b4">lock_update_insert</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec)</td></tr>
<tr class="memitem:acd33b69b0b70f3e6643e70275550a0a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#acd33b69b0b70f3e6643e70275550a0a7">lock_update_delete</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec)</td></tr>
<tr class="memitem:ad32bb2ec136f61df97fea7e90c94a7cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad32bb2ec136f61df97fea7e90c94a7cf">lock_rec_store_on_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec)</td></tr>
<tr class="memitem:ad04f9ddc87db84d8621e853f1a3434db"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad04f9ddc87db84d8621e853f1a3434db">lock_rec_restore_from_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator)</td></tr>
<tr class="memitem:a124246ec5efaf4cdad0272794195c3be"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a124246ec5efaf4cdad0272794195c3be">lock_rec_expl_exist_on_page</a> (ulint space, ulint page_no))</td></tr>
<tr class="memitem:ae628690c966c3d9851db3f77446677c5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae628690c966c3d9851db3f77446677c5">lock_rec_insert_check_and_lock</a> (ulint flags, const rec_t *rec, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> *inherit))</td></tr>
<tr class="memitem:a69804cc3ca063695e6e25cedb789e692"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a69804cc3ca063695e6e25cedb789e692">lock_clust_rec_modify_check_and_lock</a> (ulint flags, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr))</td></tr>
<tr class="memitem:a1e5043bb264dd626f758ec517a13e0dc"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1e5043bb264dd626f758ec517a13e0dc">lock_sec_rec_modify_check_and_lock</a> (ulint flags, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)))</td></tr>
<tr class="memitem:ab1d5f3bc41223f625ac09672a1ca19bf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab1d5f3bc41223f625ac09672a1ca19bf">lock_sec_rec_read_check_and_lock</a> (ulint flags, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, enum lock_mode mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:afa600625a4fffa2b7f0a68cdd64b1ad3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock</a> (ulint flags, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, enum lock_mode mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:ac58c7c37eb6a9450628f2f5b16fa4eac"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac58c7c37eb6a9450628f2f5b16fa4eac">lock_clust_rec_read_check_and_lock_alt</a> (ulint flags, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, enum lock_mode mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr))</td></tr>
<tr class="memitem:ac202bf2346684b96cfecca70ad64b002"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac202bf2346684b96cfecca70ad64b002">lock_clust_rec_cons_read_sees</a> (const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, <a class="el" href="structread__view__t.html">read_view_t</a> *view)</td></tr>
<tr class="memitem:a64b5ee9ca53f4a4b12e171ffeb051ea3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a64b5ee9ca53f4a4b12e171ffeb051ea3">lock_sec_rec_cons_read_sees</a> (const rec_t *rec, const <a class="el" href="structread__view__t.html">read_view_t</a> *view))</td></tr>
<tr class="memitem:a2243d35d09b7d7366053d117d4fe4c04"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a2243d35d09b7d7366053d117d4fe4c04">lock_table</a> (ulint flags, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, enum lock_mode mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr))</td></tr>
<tr class="memitem:a1056fa163c142cf71d21e6e3d046f060"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1056fa163c142cf71d21e6e3d046f060">lock_table_ix_resurrect</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memitem:a409999adb50ece16b81d59486af7af45"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a409999adb50ece16b81d59486af7af45">lock_rec_unlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, const rec_t *rec, enum lock_mode lock_mode)</td></tr>
<tr class="memitem:af056c93107ab266face88ec37bae94c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af056c93107ab266face88ec37bae94c7">lock_trx_release_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memitem:a430d15f2674ea7fb0d8cf61636192011"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a430d15f2674ea7fb0d8cf61636192011">lock_remove_all_on_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> remove_also_table_sx_locks)</td></tr>
<tr class="memitem:a08986ae02782fab6b1cfc47de24b52b5"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a08986ae02782fab6b1cfc47de24b52b5">lock_rec_fold</a> (ulint space, ulint page_no))</td></tr>
<tr class="memitem:a5f2ec292dd7525aff0dee8910ca3a99d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5f2ec292dd7525aff0dee8910ca3a99d">lock_rec_hash</a> (ulint space, ulint page_no)</td></tr>
<tr class="memitem:aeac31e933724030fe1aca76ebbd1b524"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aeac31e933724030fe1aca76ebbd1b524">lock_rec_find_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:ab663621ff9b0550c0f2caa5fe6facc3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab663621ff9b0550c0f2caa5fe6facc3e">lock_get_src_table</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__table__t.html">dict_table_t</a> *dest, enum lock_mode *mode)</td></tr>
<tr class="memitem:a833260684f4bacb8f1d0fc0d94c2cda2"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a833260684f4bacb8f1d0fc0d94c2cda2">lock_is_table_exclusive</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structtrx__t.html">trx_t</a> *trx))</td></tr>
<tr class="memitem:a4fa82401a7f43bcd7ee507b462151b50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a4fa82401a7f43bcd7ee507b462151b50">lock_has_to_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock1, const <a class="el" href="structlock__t.html">lock_t</a> *lock2)</td></tr>
<tr class="memitem:af1d774c75604930f2101623e2464d976"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af1d774c75604930f2101623e2464d976">lock_report_trx_id_insanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> max_trx_id))</td></tr>
<tr class="memitem:adf98b08ed2e93284570fc964e5b24c16"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#adf98b08ed2e93284570fc964e5b24c16">lock_table_print</a> (FILE *file, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:aed491db1a4f9e54c46b5618fda1a72dd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aed491db1a4f9e54c46b5618fda1a72dd">lock_rec_print</a> (FILE *file, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:af2ee3e69059ed1ce38e71842f6c6561a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af2ee3e69059ed1ce38e71842f6c6561a">lock_print_info_summary</a> (FILE *file, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> nowait))</td></tr>
<tr class="memitem:a96d8a6d0b9f2926b63ea83ec8b9633c7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a96d8a6d0b9f2926b63ea83ec8b9633c7">lock_print_info_all_transactions</a> (FILE *file)</td></tr>
<tr class="memitem:a0f2e76d58abde45b2f2e61a1175059e8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a0f2e76d58abde45b2f2e61a1175059e8">lock_number_of_rows_locked</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock))</td></tr>
<tr class="memitem:a3c17bbd1a704e818f0a9e93dcf7b0541"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3c17bbd1a704e818f0a9e93dcf7b0541">lock_get_type</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:ab9c9a06b5b21a1e4c04b5cafc68b6ccd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ab9c9a06b5b21a1e4c04b5cafc68b6ccd">lock_get_trx_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:ade2809d68943d3e72cbfd11885126356"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ade2809d68943d3e72cbfd11885126356">lock_get_mode_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:a5bdf57695b21f5d522b265090787f5d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5bdf57695b21f5d522b265090787f5d4">lock_get_type_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:a5ec13113aefe2d0c30da8e0b70d8529d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN table_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a5ec13113aefe2d0c30da8e0b70d8529d">lock_get_table_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:aec43fb602ff6a6cb8964d5c4c1c0d4f7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#aec43fb602ff6a6cb8964d5c4c1c0d4f7">lock_get_table_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:ad153d0b712ae422378a58151c8628efd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ad153d0b712ae422378a58151c8628efd">lock_rec_get_index</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:a3b0200bf5b9ee51f495a2ddf704c63ad"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3b0200bf5b9ee51f495a2ddf704c63ad">lock_rec_get_index_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:a90793ee45348397c09e6eb0938fa3e4a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a90793ee45348397c09e6eb0938fa3e4a">lock_rec_get_space_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:ae5cdf332f59754136d761b9fe0d88564"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ae5cdf332f59754136d761b9fe0d88564">lock_rec_get_page_no</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memitem:a97a934d7768a7c68d802e733fcf86f1c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a97a934d7768a7c68d802e733fcf86f1c">lock_table_has_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memitem:a7d3fb581b71eeb0fa35520a1fe944abb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN os_thread_ret_t <br class="typebreak"/>
<a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7d3fb581b71eeb0fa35520a1fe944abb">lock_wait_timeout_thread</a> (void *arg)</td></tr>
<tr class="memitem:a05119c03d5d3b065c5da4ae75d8aa1ff"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a05119c03d5d3b065c5da4ae75d8aa1ff">lock_wait_release_thread_if_suspended</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:addfdc852efca69d23054639668aa17b6"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#addfdc852efca69d23054639668aa17b6">lock_wait_suspend_thread</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:a838b492f61b92e3678c7b7be18a2f1be"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a838b492f61b92e3678c7b7be18a2f1be">lock_unlock_table_autoinc</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memitem:a1a25f116c152abe2e006af41af8f541a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a1a25f116c152abe2e006af41af8f541a">lock_trx_handle_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx))</td></tr>
<tr class="memitem:a3137e8790ad622d3a7664a69d54af034"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a3137e8790ad622d3a7664a69d54af034">lock_table_get_n_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table))</td></tr>
<tr class="memitem:a63bb8b70f1c54cd9b61ab364e55b2b2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a63bb8b70f1c54cd9b61ab364e55b2b2f">lock_check_trx_id_sanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets))</td></tr>
<tr class="memitem:a7b6aa13727e190a2f891b05087d4a019"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#a7b6aa13727e190a2f891b05087d4a019">lock_trx_has_sys_table_locks</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx))</td></tr>
<tr class="memitem:af86f4a34b1c27b52cc56467e83e26172"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#af86f4a34b1c27b52cc56467e83e26172">lock_trx_has_rec_x_lock</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, ulint heap_no))</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad6facaed4aa238ad53ce0f202bcadc54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6facaed4aa238ad53ce0f202bcadc54"></a>
<a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lock_print_waits</b></td></tr>
<tr class="memitem:ac5399aad1a992cb27e897fc806570ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__sys__t.html">lock_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The transaction lock system</p>
<p>Created 5/7/1996 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a8631af3f85d4c19484f6de819b2b2a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_GAP&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>when this bit is set, it means that the lock holds only on the gap before the record; for instance, an x-lock on the gap does not give permission to modify the record on which the bit is set; locks of this type are created when records are removed from the index chain of records </p>

</div>
</div>
<a class="anchor" id="a7a448126f7465de2aa940d1751dd8b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_INSERT_INTENTION&#160;&#160;&#160;2048</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this bit is set when we place a waiting gap type record lock request in order to let an insert of an index record to wait until there are no conflicting locks by other transactions on the gap; note that this flag remains set when the waiting lock is granted, or if the lock is inherited to a neighboring record </p>

</div>
</div>
<a class="anchor" id="aea25ac33bd6692ef77c95c6a7da765a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_MODE_MASK&#160;&#160;&#160;0xFUL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock modes and types mask used to extract mode from the type_mode field in a lock </p>

</div>
</div>
<a class="anchor" id="aa0bfbe3afb8e847cdafb2bb6457b6721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_enter</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        mutex_enter(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">mutex</a>);          \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Acquire the lock_sys-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="ab55bf242eefa1adae272425906fb4fad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_enter_nowait</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;mutex_enter_nowait(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;mutex can be acquired without waiting. </p>

</div>
</div>
<a class="anchor" id="a3974c25207bb78672d5c167125cc80ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_exit</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        mutex_exit(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a5cac6a7c287b4a2831854e39ccf7cb70">mutex</a>);           \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Release the lock_sys-&gt;mutex. </p>

</div>
</div>
<a class="anchor" id="a2627320b3fe16bdedeed909919de3e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_mutex_own</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;mutex is owned. </p>

</div>
</div>
<a class="anchor" id="a95f8dd3d016d01aaa314160f0db74e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_ORDINARY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this flag denotes an ordinary next-key lock in contrast to LOCK_GAP or LOCK_REC_NOT_GAP </p>

</div>
</div>
<a class="anchor" id="a145ae646d1def688ee264b9d98c2e981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>record lock </p>

</div>
</div>
<a class="anchor" id="a5ec9b0cce21ee17de083d3bb96b1bec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_REC_NOT_GAP&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this bit means that the lock is only on the index record and does NOT block inserts to the gap before the index record; this is used in the case when we retrieve a record with a unique key, and is also used in locking plain SELECTs (not part of UPDATE or DELETE) when the user has set the READ COMMITTED isolation level </p>

</div>
</div>
<a class="anchor" id="a3f5d26fd94580daba78f376b8ca887dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TABLE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock types table lock </p>

</div>
</div>
<a class="anchor" id="a51876da8368dde6b362ce3c465dcc9eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_TYPE_MASK&#160;&#160;&#160;0xF0UL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mask used to extract lock type from the type_mode field in a lock </p>

</div>
</div>
<a class="anchor" id="a92ad796dd0adc2da08468a220376fe76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_WAIT&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waiting lock flag; when set, it means that the lock has not yet been granted, it is just waiting for its turn in the wait queue </p>

</div>
</div>
<a class="anchor" id="af316b7272e81c47c1548d22025f542e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_enter</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        mutex_enter(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">wait_mutex</a>);     \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Acquire the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a class="anchor" id="acac7466a6379499864e831e92c950956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_exit</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {            \</div>
<div class="line">        mutex_exit(&amp;<a class="code" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;<a class="code" href="structlock__sys__t.html#a9fc1affce7ce17500f48fa8100067864">wait_mutex</a>);      \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Release the lock_sys-&gt;wait_mutex. </p>

</div>
</div>
<a class="anchor" id="aaf586f74bea52a9f41cb48d219e03cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lock_wait_mutex_own</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="sync0sync_8h.html#a40624491e0b49ffe0a3e02f69406343a">mutex_own</a>(&amp;<a class="el" href="lock0lock_8h.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a>-&gt;wait_mutex)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if lock_sys-&gt;wait_mutex is owned. </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a63bb8b70f1c54cd9b61ab364e55b2b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_check_trx_id_sanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a transaction id is sensible, i.e., not in the future. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac202bf2346684b96cfecca70ad64b002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_clust_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a record is seen in a consistent read. </p>
<dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved in: consistent read view </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69804cc3ca063695e6e25cedb789e692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record x-lock to the lock queue. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa600625a4fffa2b7f0a68cdd64b1ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED in: query thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac58c7c37eb6a9450628f2f5b16fa4eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock_alt </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. This is an alternative version of <a class="el" href="lock0lock_8h.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a> that does not require the parameter "offsets". </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d299943e5932310b8db82f441b885f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_get_min_heap_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the heap_no of the smallest user record on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>heap_no of smallest user record, or PAGE_HEAP_NO_SUPREMUM in: buffer block</dd></dl>
<p>Gets the heap_no of the smallest user record on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>heap_no of smallest user record, or PAGE_HEAP_NO_SUPREMUM </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade2809d68943d3e72cbfd11885126356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_mode_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the mode of a lock in a human readable string. The string should not be free()'d or modified. </p>
<dl class="section return"><dt>Returns</dt><dd>lock mode in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="afd6d281988732c472d3e0f7eac4d6e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of a lock struct. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="ab663621ff9b0550c0f2caa5fe6facc3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structdict__table__t.html">dict_table_t</a>* lock_get_src_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the source table of an ALTER TABLE transaction. The table must be covered by an IX or IS table lock. </p>
<dl class="section return"><dt>Returns</dt><dd>the source table of transaction, if it is covered by an IX or IS table lock; dest if there is no source table, and NULL if the transaction is locking more than two tables or an inconsistency is found out: lock mode of the source table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">dest</td><td>in: destination of ALTER TABLE </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ec13113aefe2d0c30da8e0b70d8529d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN table_id_t lock_get_table_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the table on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>id of the table in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="aec43fb602ff6a6cb8964d5c4c1c0d4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_table_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the table on which the lock is. The string should not be free()'d or modified. </p>
<dl class="section return"><dt>Returns</dt><dd>name of the table in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c9a06b5b21a1e4c04b5cafc68b6ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_get_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the id of the transaction owning a lock. </p>
<dl class="section return"><dt>Returns</dt><dd>transaction id in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a3c17bbd1a704e818f0a9e93dcf7b0541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock. Non-inline version for using outside of the lock module. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a5bdf57695b21f5d522b265090787f5d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_get_type_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of a lock in a human readable string. The string should not be free()'d or modified. </p>
<dl class="section return"><dt>Returns</dt><dd>lock type in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a4fa82401a7f43bcd7ee507b462151b50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> lock_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a lock request lock1 has to wait for request lock2. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if lock1 has to wait for lock2 to be removed in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock1</td><td>in: waiting lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a833260684f4bacb8f1d0fc0d94c2cda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> lock_is_table_exclusive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the given table is exclusively "owned" by the given transaction, i.e., transaction holds LOCK_IX and possibly LOCK_AUTO_INC on the table. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if table is only locked by trx, with LOCK_IX, and possibly LOCK_AUTO_INC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb43b7be638bd32fa36b7c025d636bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. in: record on page: this is the first record moved </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23e7197a446aee79574d335d277aaa84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_rec_list_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>old_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. in: old previous-to-last record on new_page before the records were copied </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to move to </td></tr>
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">rec</td><td>in: record on page: this is the first record NOT copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7273b2c3c75e90408bdc5a711effc73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_move_reorganize_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>oblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when we have reorganized a page. NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. in: copy of the old, not reorganized page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: old index page, now reorganized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f2e76d58abde45b2f2e61a1175059e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_number_of_rows_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return approximate number or record locks (bits set in the bitmap) for this transaction. Since delete-marked records may be removed, the record count will not be precise. The caller must be holding lock_sys-&gt;mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_lock</td><td>in: transaction locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96d8a6d0b9f2926b63ea83ec8b9633c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_print_info_all_transactions </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for each transaction. This function assumes that the caller holds the lock mutex and more importantly it will release the lock mutex on behalf of the caller. (This should be fixed in the future). in: file where to print </p>

</div>
</div>
<a class="anchor" id="af2ee3e69059ed1ce38e71842f6c6561a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> lock_print_info_summary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>nowait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of locks for all transactions. </p>
<dl class="section return"><dt>Returns</dt><dd>FALSE if not able to obtain lock mutex and exits without printing info </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">nowait</td><td>in: whether to wait for the lock mutex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a124246ec5efaf4cdad0272794195c3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_expl_exist_on_page </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if there are explicit record locks on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>an explicit record lock on the page, or NULL if there are none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeac31e933724030fe1aca76ebbd1b524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_find_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a set bit in a record lock bitmap. Returns ULINT_UNDEFINED, if none found. </p>
<dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found in: record lock with at least one bit set </dd></dl>

</div>
</div>
<a class="anchor" id="a08986ae02782fab6b1cfc47de24b52b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_fold </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the fold value of a page file address: used in inserting or searching for a lock in the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad153d0b712ae422378a58151c8628efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structdict__index__t.html">dict_index_t</a>* lock_rec_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the index on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>index in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a3b0200bf5b9ee51f495a2ddf704c63ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const char* lock_rec_get_index_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the name of the index on which the lock is. The string should not be free()'d or modified. </p>
<dl class="section return"><dt>Returns</dt><dd>name of the index in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="ae5cdf332f59754136d761b9fe0d88564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_page_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the page number on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>page number in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a90793ee45348397c09e6eb0938fa3e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_rec_get_space_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a record lock, gets the tablespace number on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>tablespace number in: lock </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2ec292dd7525aff0dee8910ca3a99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_hash </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the hash value of a page file address: used in inserting or searching for a lock in the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>hashed value in: page number</dd></dl>
<p>Calculates the hash value of a page file address: used in inserting or searching for a lock in the hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>hashed value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae628690c966c3d9851db3f77446677c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_insert_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate insert of a record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a gap x-lock to the lock queue. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: set to TRUE if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed491db1a4f9e54c46b5618fda1a72dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a record lock. in: record type lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1a1ced4eeb3daa98b39ee2365df8b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_reset_and_inherit_gap_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. in: heap_no of the donating record </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: block containing the record which inherits </td></tr>
    <tr><td class="paramname">block</td><td>in: block containing the record from which inherited; does NOT reset the locks on this record </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the inheriting record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad04f9ddc87db84d8621e853f1a3434db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_restore_from_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. in: page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is restored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad32bb2ec136f61df97fea7e90c94a7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_store_on_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores on the page infimum record the explicit locks of another record. This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is in such an update moved, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a409999adb50ece16b81d59486af7af45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_rec_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>lock_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. in: LOCK_S or LOCK_X </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that has set a record lock </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a430d15f2674ea7fb0d8cf61636192011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_remove_all_on_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes locks on a table to be dropped or truncated. If remove_also_table_sx_locks is TRUE then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. in: also removes table S and X locks </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped or truncated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1d774c75604930f2101623e2464d976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_report_trx_id_insanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>max_trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports that a transaction id is insensible, i.e., in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">max_trx_id</td><td>in: <a class="el" href="trx0sys_8h.html#aaf92577bb351b5b6e51fac1f36a0abd3">trx_sys_get_max_trx_id()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64b5ee9ca53f4a4b12e171ffeb051ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_sec_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structread__view__t.html">read_view_t</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a non-clustered index record is seen in a consistent read.</p>
<p>NOTE that a non-clustered index page contains so little information on its modifications that also in the case false, the present version of rec may be the right, but we must check this from the clustered index record.</p>
<dl class="section return"><dt>Returns</dt><dd>true if certainly sees, or false if an earlier version of the clustered index record might be needed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e5043bb264dd626f758ec517a13e0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified; NOTE: as this is a secondary index, we always have to modify the clustered index record first: see the comment below </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1d5f3bc41223f625ac09672a1ca19bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="lock0lock_8h.html#afa600625a4fffa2b7f0a68cdd64b1ad3">lock_clust_rec_read_check_and_lock()</a>, but reads a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED in: query thread </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c2350ce483b08686c48c19407f63da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the lock system at database shutdown. </p>

</div>
</div>
<a class="anchor" id="a40ad348feb00e96aec397b06dbec7c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the lock system at database start. in: number of slots in lock hash table </p>

</div>
</div>
<a class="anchor" id="a2243d35d09b7d7366053d117d4fe4c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lock_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the specified database table in the mode given. If the lock cannot be granted immediately, the query thread is put to wait. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3137e8790ad622d3a7664a69d54af034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint lock_table_get_n_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of locks on a table. </p>
<dl class="section return"><dt>Returns</dt><dd>number of locks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97a934d7768a7c68d802e733fcf86f1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> lock_table_has_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if there are any locks (table or rec) against table. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if locks exist in: check if there are any locks held on records in this table or on the table itself </dd></dl>

</div>
</div>
<a class="anchor" id="a1056fa163c142cf71d21e6e3d046f060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_ix_resurrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a table IX lock object for a resurrected transaction. in/out: transaction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf98b08ed2e93284570fc964e5b24c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_table_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of a table lock. in: table type lock </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a25f116c152abe2e006af41af8f541a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_trx_handle_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: trx lock state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af86f4a34b1c27b52cc56467e83e26172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool lock_trx_has_rec_x_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the transaction holds an exclusive lock on a record. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the locks are held </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction to check </td></tr>
    <tr><td class="paramname">table</td><td>in: table to check </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: record heap number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b6aa13727e190a2f891b05087d4a019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structlock__t.html">lock_t</a>* lock_trx_has_sys_table_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the transaction holds any locks on the sys tables or its records. </p>
<dl class="section return"><dt>Returns</dt><dd>the strongest lock found on any sys table or 0 for none </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af056c93107ab266face88ec37bae94c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_trx_release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. in/out: transaction </p>

</div>
</div>
<a class="anchor" id="a838b492f61b92e3678c7b7be18a2f1be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_unlock_table_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). in/out: transaction </p>

</div>
</div>
<a class="anchor" id="a6cc8f00508ee648886c7d51046af30d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_copy_and_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! in: index page; NOT the root! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_block</td><td>in: index page to which copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd33b69b0b70f3e6643e70275550a0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a record is removed. in: the record to be removed </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47d322cfc717fe99e4c5c88f7b93512e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is discarded. in: index page which will be discarded </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: index page which will inherit the locks </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the record which will inherit the locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b800d596ae20af9b8b28f7a879658b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a new user record is inserted. in: the inserted record </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a742d185fcf374672c516427602f386eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the left. in: merged index page which will be discarded </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_block</td><td>in: left page to which merged </td></tr>
    <tr><td class="paramname">orig_pred</td><td>in: original predecessor of supremum on the left page before merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ec2bdadfd1e57ddbedfc05740e884eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_merge_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>orig_succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is merged to the right. in: merged index page which will be discarded </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page to which merged </td></tr>
    <tr><td class="paramname">orig_succ</td><td>in: original successor of infimum on the right page before merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e3b8ed16aaab0770730fb554e23af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_root_raise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. in: root page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5beb29b82077fbb4080d16b8214c1d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the left. in: left page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cd5be77aa944f96aa6ff0aeebc6eb98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_update_split_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the lock table when a page is split to the right. in: left page </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right_block</td><td>in: right page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05119c03d5d3b065c5da4ae75d8aa1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_wait_release_thread_if_suspended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a user OS thread waiting for a lock to be released, if the thread is already suspended. in: query thread associated with the user OS thread </p>

</div>
</div>
<a class="anchor" id="addfdc852efca69d23054639668aa17b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void lock_wait_suspend_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts a user OS thread to wait for a lock to be released. If an error occurs during the wait trx-&gt;error_state associated with thr is != DB_SUCCESS when we return. DB_LOCK_WAIT_TIMEOUT and DB_DEADLOCK are possible errors. DB_DEADLOCK is returned if selective deadlock resolution chose this transaction as a victim. in: query thread associated with the user OS thread </p>

</div>
</div>
<a class="anchor" id="a7d3fb581b71eeb0fa35520a1fe944abb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN os_thread_ret_t <a class="el" href="os0thread_8h.html#a973a9b61391e09b9846b41b469363aa5">DECLARE_THREAD</a>() lock_wait_timeout_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A thread which wakes up threads whose lock wait may have lasted too long. </p>
<dl class="section return"><dt>Returns</dt><dd>a dummy parameter in: a dummy parameter required by os_thread_create </dd></dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="ac5399aad1a992cb27e897fc806570ba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__sys__t.html">lock_sys_t</a>* lock_sys</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The lock system </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:26 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
