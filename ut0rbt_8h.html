<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/ut0rbt.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ut0rbt.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ut0rbt.h:</div>
<div class="dyncontent">
<div class="center"><img src="ut0rbt_8h__incl.png" border="0" usemap="#include_2ut0rbt_8h" alt=""/></div>
<map name="include_2ut0rbt_8h" id="include_2ut0rbt_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="ut0rbt_8h__dep__incl.png" border="0" usemap="#include_2ut0rbt_8hdep" alt=""/></div>
<map name="include_2ut0rbt_8hdep" id="include_2ut0rbt_8hdep">
</map>
</div>
</div>
<p><a href="ut0rbt_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abbcd716ac5577397bc81f82417d86337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbcd716ac5577397bc81f82417d86337"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_size</b>(t)&#160;&#160;&#160;(t-&gt;n_nodes)</td></tr>
<tr class="memitem:a4bf4e25de6b4252aa93c17bdf4bad67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf4e25de6b4252aa93c17bdf4bad67b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_empty</b>(t)&#160;&#160;&#160;(rbt_size(t) == 0)</td></tr>
<tr class="memitem:a5870ca128fed1c26f19cb8a52987ba06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5870ca128fed1c26f19cb8a52987ba06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_value</b>(t, n)&#160;&#160;&#160;((t*) &amp;n-&gt;value[0])</td></tr>
<tr class="memitem:af451a2d6740076a82080c1fddb8f7af1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af451a2d6740076a82080c1fddb8f7af1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>rbt_compare</b>(t, k, n)&#160;&#160;&#160;(t-&gt;compare(k, n-&gt;value))</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a888c2eaefacb0a59d694bdc867a47328"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a888c2eaefacb0a59d694bdc867a47328"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_print_node</b> )(const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *node)</td></tr>
<tr class="memitem:a12fd620be28fdb86cd9dcdcaab01fdfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12fd620be28fdb86cd9dcdcaab01fdfc"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_compare</b> )(const void *p1, const void *p2)</td></tr>
<tr class="memitem:accbd8f2fb72970907de69b4359fbbe55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accbd8f2fb72970907de69b4359fbbe55"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>ib_rbt_arg_compare</b> )(const void *, const void *p1, const void *p2)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1715bf199a80c83f5be40165079ed339"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a1715bf199a80c83f5be40165079ed339">ib_rbt_color_t</a> { <b>IB_RBT_RED</b>, 
<b>IB_RBT_BLACK</b>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a160680a842fc674633f59f527c7bcdfd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a160680a842fc674633f59f527c7bcdfd">rbt_free</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="memitem:ae582d916e935fac8ec45850cb1255082"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ae582d916e935fac8ec45850cb1255082">rbt_create</a> (size_t sizeof_value, ib_rbt_compare compare)</td></tr>
<tr class="memitem:a88cfa8f5baa48789af0e457bd3c57bd0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a88cfa8f5baa48789af0e457bd3c57bd0">rbt_create_arg_cmp</a> (size_t sizeof_value, ib_rbt_arg_compare compare, void *cmp_arg)</td></tr>
<tr class="memitem:ad8a776fb52186a413fc859d393c90165"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ad8a776fb52186a413fc859d393c90165">rbt_delete</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="memitem:a75d12d6639f6ab93891188f7fe1b802b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a75d12d6639f6ab93891188f7fe1b802b">rbt_remove_node</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *node)</td></tr>
<tr class="memitem:ada0cf8e2e61d016b06c22ae5eb26234b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ada0cf8e2e61d016b06c22ae5eb26234b">rbt_lookup</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="memitem:a97d037d4ead5e59454a7e11ac3e5c97c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a97d037d4ead5e59454a7e11ac3e5c97c">rbt_insert</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key, const void *value)</td></tr>
<tr class="memitem:abda0e7602a733198120cc93e21be2cef"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#abda0e7602a733198120cc93e21be2cef">rbt_add_node</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *value)</td></tr>
<tr class="memitem:a51bfcc467fec46eb6670b0bebd2ac993"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a51bfcc467fec46eb6670b0bebd2ac993">rbt_first</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="memitem:a21d9ec1c12b3e25cd4d2a5e5d2ddf292"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a21d9ec1c12b3e25cd4d2a5e5d2ddf292">rbt_last</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="memitem:aaa4f896a1d07d6014b439a9090f78fd7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aaa4f896a1d07d6014b439a9090f78fd7">rbt_next</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *current)</td></tr>
<tr class="memitem:a5870b12e1ec4fe06556c1d5e54290cb3"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a5870b12e1ec4fe06556c1d5e54290cb3">rbt_prev</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *current)</td></tr>
<tr class="memitem:af0c8a8983d0db6dd18936255f0600b0a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#af0c8a8983d0db6dd18936255f0600b0a">rbt_lower_bound</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="memitem:a7811896fd44ca0e33013fe3968843e3c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a7811896fd44ca0e33013fe3968843e3c">rbt_upper_bound</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, const void *key)</td></tr>
<tr class="memitem:a570e162e588a362ad5ce2af9c0d7917f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a570e162e588a362ad5ce2af9c0d7917f">rbt_search</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *key)</td></tr>
<tr class="memitem:a200f386d57dffaa8835bbb663c0aef4c"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a200f386d57dffaa8835bbb663c0aef4c">rbt_search_cmp</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, <a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *parent, const void *key, ib_rbt_compare compare, ib_rbt_arg_compare arg_compare)</td></tr>
<tr class="memitem:a2c18f12889d9fd2ce0fb1515bc534637"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a2c18f12889d9fd2ce0fb1515bc534637">rbt_clear</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="memitem:aa6691fac5e02bca98466ba10c371989b"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aa6691fac5e02bca98466ba10c371989b">rbt_merge_uniq</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *dst, const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *src)</td></tr>
<tr class="memitem:ac7a2d6cc0999684a60bee9f5185a0c3e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#ac7a2d6cc0999684a60bee9f5185a0c3e">rbt_merge_uniq_destructive</a> (<a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *dst, <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *src)</td></tr>
<tr class="memitem:a4a95ee9e8fb929ee4336d27cb2aacb2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#a4a95ee9e8fb929ee4336d27cb2aacb2f">rbt_validate</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree)</td></tr>
<tr class="memitem:aaec7ec29a13db727194019b3bf13b6b0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ut0rbt_8h.html#aaec7ec29a13db727194019b3bf13b6b0">rbt_print</a> (const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *tree, ib_rbt_print_node print)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2007, 2010, Oracle and/or its affiliates. All Rights Reserved.</p>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; version 2 of the License.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA</p>
<p>Various utilities</p>
<p>Created 2007-03-20 Sunny Bains </p>
</div><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a1715bf199a80c83f5be40165079ed339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ut0rbt_8h.html#a1715bf199a80c83f5be40165079ed339">ib_rbt_color_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Red black tree color types </p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="abda0e7602a733198120cc93e21be2cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new node to the tree, useful for data that is pre-sorted. </p>
<dl class="section return"><dt>Returns</dt><dd>appended node in: this value is copied to the node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c18f12889d9fd2ce0fb1515bc534637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the tree, deletes (and free's) all the nodes. in: rb tree </p>

</div>
</div>
<a class="anchor" id="ae582d916e935fac8ec45850cb1255082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a>* rbt_create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an instance of a red black tree </p>
<dl class="section return"><dt>Returns</dt><dd>rb tree instance in: comparator </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeof_value</td><td>in: size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88cfa8f5baa48789af0e457bd3c57bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__t.html">ib_rbt_t</a>* rbt_create_arg_cmp </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_arg_compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an instance of a red black tree, whose comparison function takes an argument </p>
<dl class="section return"><dt>Returns</dt><dd>rb tree instance in: compare fn arg </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeof_value</td><td>in: size in bytes </td></tr>
    <tr><td class="paramname">compare</td><td>in: comparator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8a776fb52186a413fc859d393c90165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rbt_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a node from the red black tree, identified by key </p>

</div>
</div>
<a class="anchor" id="a51bfcc467fec46eb6670b0bebd2ac993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the left most data node in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>left most node in: rb tree </dd></dl>

</div>
</div>
<a class="anchor" id="a160680a842fc674633f59f527c7bcdfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an instance of a red black tree in: rb tree to free </p>

</div>
</div>
<a class="anchor" id="a97d037d4ead5e59454a7e11ac3e5c97c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add data to the red black tree, identified by key (no dups yet!) </p>
<dl class="section return"><dt>Returns</dt><dd>inserted node in: data that will be copied to the node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">key</td><td>in: key for ordering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21d9ec1c12b3e25cd4d2a5e5d2ddf292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_last </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the right most data node in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>right most node in: rb tree </dd></dl>

</div>
</div>
<a class="anchor" id="ada0cf8e2e61d016b06c22ae5eb26234b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a node from the red black tree, identified by key, NULL if not found </p>
<dl class="section return"><dt>Returns</dt><dd>node if found else return NULL in: key to lookup </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree to search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0c8a8983d0db6dd18936255f0600b0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node that has the lowest key that is &gt;= key. </p>
<dl class="section return"><dt>Returns</dt><dd>node that satisfies the lower bound constraint or NULL in: key to search </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6691fac5e02bca98466ba10c371989b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint rbt_merge_uniq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the node from dst into src. Return the number of nodes merged. </p>
<dl class="section return"><dt>Returns</dt><dd>no. of recs merged in: src rb tree </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: dst rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7a2d6cc0999684a60bee9f5185a0c3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint rbt_merge_uniq_destructive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the node from dst into src. Return the number of nodes merged. Delete the nodes from src after copying node to dst. As a side effect the duplicates will be left untouched in the src, since we don't support duplicates (yet). NOTE: src and dst must be similar, the function doesn't check for this condition (yet). </p>
<dl class="section return"><dt>Returns</dt><dd>no. of recs merged in: src rb tree </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>in: dst rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa4f896a1d07d6014b439a9090f78fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the next node from current. </p>
<dl class="section return"><dt>Returns</dt><dd>successor node to current that is passed in. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5870b12e1ec4fe06556c1d5e54290cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the prev node from current. </p>
<dl class="section return"><dt>Returns</dt><dd>precedessor node to current that is passed in </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaec7ec29a13db727194019b3bf13b6b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void rbt_print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_print_node&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the tree in depth first order. in: print function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: tree to traverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75d12d6639f6ab93891188f7fe1b802b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a node from the red black tree, NOTE: This function will not delete the node instance, THAT IS THE CALLERS RESPONSIBILITY. </p>
<dl class="section return"><dt>Returns</dt><dd>the deleted node with the const. in: node to delete, this is a fudge and declared const because the caller has access only to const nodes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a570e162e588a362ad5ce2af9c0d7917f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int rbt_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the key, a node will be retuned in parent.last, whether it was found or not. If not found then parent.last will contain the parent node for the possibly new key otherwise the matching node. </p>
<dl class="section return"><dt>Returns</dt><dd>result of last comparison in: key to search </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: search bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a200f386d57dffaa8835bbb663c0aef4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN int rbt_search_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structib__rbt__bound__t.html">ib_rbt_bound_t</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_rbt_arg_compare&#160;</td>
          <td class="paramname"><em>arg_compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for the key, a node will be retuned in parent.last, whether it was found or not. If not found then parent.last will contain the parent node for the possibly new key otherwise the matching node. </p>
<dl class="section return"><dt>Returns</dt><dd>result of last comparison in: fn to compare items with argument </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
    <tr><td class="paramname">parent</td><td>in: search bounds </td></tr>
    <tr><td class="paramname">key</td><td>in: key to search </td></tr>
    <tr><td class="paramname">compare</td><td>in: comparator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7811896fd44ca0e33013fe3968843e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structib__rbt__node__t.html">ib_rbt_node_t</a>* rbt_upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the node that has the greatest key that is &lt;= key. </p>
<dl class="section return"><dt>Returns</dt><dd>node that satisifies the upper bound constraint or NULL in: key to search </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>in: rb tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a95ee9e8fb929ee4336d27cb2aacb2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> rbt_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structib__rbt__t.html">ib_rbt_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify the integrity of the RB tree. For debugging. 0 failure else height of tree (in count of black nodes). </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if OK FALSE if tree invalid. in: tree to validate </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:21 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
