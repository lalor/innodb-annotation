<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/row0upd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">row0upd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="data0data_8h_source.html">data0data.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0types_8h_source.html">dict0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="trx0types_8h_source.html">trx0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pars0types_8h_source.html">pars0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="row0upd_8ic.html">row0upd.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for row0upd.h:</div>
<div class="dyncontent">
<div class="center"><img src="row0upd_8h__incl.png" border="0" usemap="#include_2row0upd_8h" alt=""/></div>
<map name="include_2row0upd_8h" id="include_2row0upd_8h">
</map>
</div>
</div>
<p><a href="row0upd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__field__t.html">upd_field_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__t.html">upd_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structupd__node__t.html">upd_node_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a908c0370d392197d4d1b745e3d464985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908c0370d392197d4d1b745e3d464985"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>row_upd_changes_ord_field_binary</b>(index, update, thr, row, ext)&#160;&#160;&#160;<a class="el" href="row0upd_8h.html#a37f2c0898b0bb030dc40214e558610bb">row_upd_changes_ord_field_binary_func</a>(index,update,thr,row,ext)</td></tr>
<tr class="memitem:a96c347f996e51f6fb49ef6c067ba04bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c347f996e51f6fb49ef6c067ba04bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_MAGIC_N</b>&#160;&#160;&#160;1579975</td></tr>
<tr class="memitem:a44102f8533c40d47458f13aac650ef38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_SET_IX_LOCK</b></td></tr>
<tr class="memitem:a78ed1fcdf27db3b4ada62729f09fd233"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_CLUSTERED</b></td></tr>
<tr class="memitem:a0446f02f1cc4570e730ed640bf311493"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_INSERT_CLUSTERED</b></td></tr>
<tr class="memitem:af8ffe141c170c94d10b218c89ae19b18"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_INSERT_BLOB</b></td></tr>
<tr class="memitem:acc1678d94ec05825c81d2a4748f19c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_ALL_SEC</b></td></tr>
<tr class="memitem:abe5381bd0d873234a70f103df73b1b02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_UPDATE_SOME_SEC</b></td></tr>
<tr class="memitem:a521a1927c7f930bb014e8697bcc579cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_NO_ORD_CHANGE</b></td></tr>
<tr class="memitem:ac1f48e6b565f0a43dce9888b2d23d16e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>UPD_NODE_NO_SIZE_CHANGE</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae4662cf8a186586e3caad5a7a28cf9ec"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ae4662cf8a186586e3caad5a7a28cf9ec">upd_create</a> (ulint n, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:adc0bebe9c2bdc7ec292e9784374476f2"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#adc0bebe9c2bdc7ec292e9784374476f2">upd_get_n_fields</a> (const <a class="el" href="structupd__t.html">upd_t</a> *update)</td></tr>
<tr class="memitem:a1cc9824c435b30f9957b9864ce39c8ad"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a1cc9824c435b30f9957b9864ce39c8ad">upd_get_nth_field</a> (const <a class="el" href="structupd__t.html">upd_t</a> *update, ulint n)</td></tr>
<tr class="memitem:abba68102b6521acae8f0d8c3e6ba0a26"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#abba68102b6521acae8f0d8c3e6ba0a26">upd_field_set_field_no</a> (<a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field, ulint field_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memitem:a34246967bad8ff4d10daac7e83e5e3c1"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a34246967bad8ff4d10daac7e83e5e3c1">upd_get_field_by_field_no</a> (const <a class="el" href="structupd__t.html">upd_t</a> *update, ulint no))</td></tr>
<tr class="memitem:a51d7c8cfa676ad73cf68f61cd4fc3068"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a51d7c8cfa676ad73cf68f61cd4fc3068">row_upd_write_sys_vals_to_log</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, byte *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aa0dbc3d05e7439c1afdb28063ab827cf"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aa0dbc3d05e7439c1afdb28063ab827cf">row_upd_rec_sys_fields</a> (rec_t *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr)</td></tr>
<tr class="memitem:a26ad2921018c2e34da12dff331f17308"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a26ad2921018c2e34da12dff331f17308">row_upd_index_entry_sys_field</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint type, ib_uint64_t val)</td></tr>
<tr class="memitem:adcbf24a5f1842095a0aea1bde91e66f0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#adcbf24a5f1842095a0aea1bde91e66f0">upd_node_create</a> (<a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a813e11390074690cd46e0a2831e465cf"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a813e11390074690cd46e0a2831e465cf">row_upd_index_write_log</a> (const <a class="el" href="structupd__t.html">upd_t</a> *update, byte *log_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aed5b95f92367fcb6d487efcbd1e3a8d4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aed5b95f92367fcb6d487efcbd1e3a8d4">row_upd_changes_field_size_or_external</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *update)</td></tr>
<tr class="memitem:a9a5e67bf51f7e4dd63cda6c6441867e4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a9a5e67bf51f7e4dd63cda6c6441867e4">row_upd_changes_disowned_external</a> (const <a class="el" href="structupd__t.html">upd_t</a> *update))</td></tr>
<tr class="memitem:a736d5872d84c0e81c7c63d308e66e2f8"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a736d5872d84c0e81c7c63d308e66e2f8">row_upd_rec_in_place</a> (rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="memitem:a8a1d77457cf60f6cd6bb06763ef895f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a8a1d77457cf60f6cd6bb06763ef895f1">row_upd_build_sec_rec_difference_binary</a> (const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap))</td></tr>
<tr class="memitem:aae7023dc40ba3e966750a32d90bb2faa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#aae7023dc40ba3e966750a32d90bb2faa">row_upd_build_difference_binary</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, const rec_t *rec, const ulint *offsets, bool no_sys, <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a403403b3ed25959ce4c9039ca8517e91"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a403403b3ed25959ce4c9039ca8517e91">row_upd_index_replace_new_col_vals_index_pos</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> order_only, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap))</td></tr>
<tr class="memitem:a28a55a00dcdfa4addbf72fe71e7ed5f1"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a28a55a00dcdfa4addbf72fe71e7ed5f1">row_upd_index_replace_new_col_vals</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap))</td></tr>
<tr class="memitem:a7169668781a556da74cd6b6821986ca5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a7169668781a556da74cd6b6821986ca5">row_upd_replace</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *row, <a class="el" href="structrow__ext__t.html">row_ext_t</a> **ext, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a37f2c0898b0bb030dc40214e558610bb"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a37f2c0898b0bb030dc40214e558610bb">row_upd_changes_ord_field_binary_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structupd__t.html">upd_t</a> *update, const <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *row, const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *ext)</td></tr>
<tr class="memitem:a703e5befbbafbade1b692d71b5ad4968"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a703e5befbbafbade1b692d71b5ad4968">row_upd_changes_fts_column</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field)</td></tr>
<tr class="memitem:ac193d8dfef61212e38fd4f4a8f62e1f0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ac193d8dfef61212e38fd4f4a8f62e1f0">row_upd_changes_doc_id</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structupd__field__t.html">upd_field_t</a> *upd_field))</td></tr>
<tr class="memitem:af6ca86abc5e48fd642b989e9c0b9b509"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#af6ca86abc5e48fd642b989e9c0b9b509">row_upd_changes_some_index_ord_field_binary</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structupd__t.html">upd_t</a> *update)</td></tr>
<tr class="memitem:a6ef8c0ae6eea82f02c7ba30a644f1b57"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a6ef8c0ae6eea82f02c7ba30a644f1b57">row_upd_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memitem:a941717af7d57a7b6bf841f0c98948199"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a941717af7d57a7b6bf841f0c98948199">row_upd_parse_sys_vals</a> (byte *ptr, byte *end_ptr, ulint *pos, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *roll_ptr)</td></tr>
<tr class="memitem:a23cb047352eff637ca3adc6816d7bfd4"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#a23cb047352eff637ca3adc6816d7bfd4">row_upd_rec_sys_fields_in_recovery</a> (rec_t *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, const ulint *offsets, ulint pos, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr)</td></tr>
<tr class="memitem:ab65084faf3a9b76b650131636bdc1497"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0upd_8h.html#ab65084faf3a9b76b650131636bdc1497">row_upd_index_parse</a> (byte *ptr, byte *end_ptr, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap, <a class="el" href="structupd__t.html">upd_t</a> **update_out)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae1a94bb37549cf37ef3bf90e756f4e23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1a94bb37549cf37ef3bf90e756f4e23"></a>
UNIV_INTERN const <a class="el" href="structupd__t.html">upd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Update of a row</p>
<p>Created 12/27/1996 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="af8ffe141c170c94d10b218c89ae19b18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_INSERT_BLOB</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">4       <span class="comment">/* clustered index record should be</span></div>
<div class="line"><span class="comment">                                        inserted, old record is already</span></div>
<div class="line"><span class="comment">                                        delete-marked; non-updated BLOBs</span></div>
<div class="line"><span class="comment">                                        should be inherited by the new record</span></div>
<div class="line"><span class="comment">                                        and disowned by the old record */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0446f02f1cc4570e730ed640bf311493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_INSERT_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">3       <span class="comment">/* clustered index record should be</span></div>
<div class="line"><span class="comment">                                        inserted, old record is already delete</span></div>
<div class="line"><span class="comment">                                        marked */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a521a1927c7f930bb014e8697bcc579cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_ORD_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1       <span class="comment">/* no secondary index record will be</span></div>
<div class="line"><span class="comment">                                        changed in the update and no ordering</span></div>
<div class="line"><span class="comment">                                        field of the clustered index */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac1f48e6b565f0a43dce9888b2d23d16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_NO_SIZE_CHANGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* no record field size will be</span></div>
<div class="line"><span class="comment">                                        changed in the update */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a44102f8533c40d47458f13aac650ef38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_SET_IX_LOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">1       <span class="comment">/* execution came to the node from</span></div>
<div class="line"><span class="comment">                                        a node above and if the field</span></div>
<div class="line"><span class="comment">                                        has_clust_rec_x_lock is FALSE, we</span></div>
<div class="line"><span class="comment">                                        should set an intention x-lock on</span></div>
<div class="line"><span class="comment">                                        the table */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acc1678d94ec05825c81d2a4748f19c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_ALL_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">5       <span class="comment">/* an ordering field of the clustered</span></div>
<div class="line"><span class="comment">                                        index record was changed, or this is</span></div>
<div class="line"><span class="comment">                                        a delete operation: should update</span></div>
<div class="line"><span class="comment">                                        all the secondary index records */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a78ed1fcdf27db3b4ada62729f09fd233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_CLUSTERED</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">2       <span class="comment">/* clustered index record should be</span></div>
<div class="line"><span class="comment">                                        updated */</span></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe5381bd0d873234a70f103df73b1b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UPD_NODE_UPDATE_SOME_SEC</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">6       <span class="comment">/* secondary index entries should be</span></div>
<div class="line"><span class="comment">                                        looked at and updated if an ordering</span></div>
<div class="line"><span class="comment">                                        field changed */</span></div>
</div><!-- fragment -->
</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="aae7023dc40ba3e966750a32d90bb2faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN const <a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_difference_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_sys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds an update vector from those fields, excluding the roll ptr and trx id fields, which in an index entry differ from a record that has the equal ordering fields. NOTE: we compare the fields as binary strings! </p>
<dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields, excluding roll ptr and trx id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>in: clustered index record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec,index), or NULL </td></tr>
    <tr><td class="paramname">no_sys</td><td>in: skip the system columns DB_TRX_ID and DB_ROLL_PTR </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction (for diagnostics), or NULL </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a1d77457cf60f6cd6bb06763ef895f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__t.html">upd_t</a>* row_upd_build_sec_rec_difference_binary </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds an update vector from those fields which in a secondary index entry differ from a record that has the equal ordering fields. NOTE: we compare the fields as binary strings! </p>
<dl class="section return"><dt>Returns</dt><dd>own: update vector of differing fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: secondary index record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry to insert </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap from which allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a5e67bf51f7e4dd63cda6c6441867e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool row_upd_changes_disowned_external </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if row update contains disowned external fields. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the update contains disowned external fields. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac193d8dfef61212e38fd4f4a8f62e1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool row_upd_changes_doc_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an FTS Doc ID column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>whether Doc ID column is affected </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">upd_field</td><td>in: field to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed5b95f92367fcb6d487efcbd1e3a8d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> row_upd_changes_field_size_or_external </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if row update changes size of some field in index or if some field to be updated is stored externally in rec or update. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the update changes the size of some field in index or the field is external in rec or update in: update vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a703e5befbbafbade1b692d71b5ad4968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint row_upd_changes_fts_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an FTS indexed column is affected by an UPDATE. </p>
<dl class="section return"><dt>Returns</dt><dd>offset within <a class="el" href="structfts__t.html#afc118c175b3dfcf1e30290bb68f2284e">fts_t::indexes</a> if FTS indexed column updated else ULINT_UNDEFINED in: field to check </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f2c0898b0bb030dc40214e558610bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> row_upd_changes_ord_field_binary_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrow__ext__t.html">row_ext_t</a> *&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an update vector changes an ordering field of an index record.</p>
<p>This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if update vector changes an ordering field in the index record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector for the row; NOTE: the field numbers in this MUST be clustered index positions! </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">row</td><td>in: old value of row, or NULL if the row and the data values in update are not known when this function is called, e.g., at compile time </td></tr>
    <tr><td class="paramname">ext</td><td>NULL, or prefixes of the externally stored columns in the old row </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6ca86abc5e48fd642b989e9c0b9b509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> row_upd_changes_some_index_ord_field_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if an update vector changes an ordering field of an index record. This function is fast if the update vector is short or the number of ordering fields in the index is small. Otherwise, this can be quadratic. NOTE: we compare the fields as binary strings! </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if update vector may change an ordering field in an index record in: update vector for the row </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26ad2921018c2e34da12dff331f17308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_entry_sys_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the trx id or roll ptr field of a clustered index entry. in: value to write </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry, where the memory buffers for sys fields are already allocated: the function just copies the new values to them </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">type</td><td>in: DATA_TRX_ID or DATA_ROLL_PTR </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab65084faf3a9b76b650131636bdc1497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_index_parse </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structupd__t.html">upd_t</a> **&#160;</td>
          <td class="paramname"><em>update_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the log data written by row_upd_index_write_log. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: update vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap where update vector is built </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28a55a00dcdfa4addbf72fe71e7ed5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_replace_new_col_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">index</td><td>in: index; NOTE that this may also be a non-clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the CLUSTERED index so that the field number in an upd_field is the clustered index position </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a403403b3ed25959ce4c9039ca8517e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>order_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the index entry given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in/out: index entry where replaced; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">index</td><td>in: index; NOTE that this may also be a non-clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the index so that the field number in an upd_field is the index position </td></tr>
    <tr><td class="paramname">order_only</td><td>in: if TRUE, limit the replacement to ordering fields of index; note that this does not work for non-clustered indexes. </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap for allocating and copying the new values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a813e11390074690cd46e0a2831e465cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_index_write_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the redo log the new values of the fields occurring in the index. in: mtr into whose log to write </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">log_ptr</td><td>in: pointer to mlog buffer: must contain at least MLOG_BUF_MARGIN bytes of free space; the buffer is closed within this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941717af7d57a7b6bf841f0c98948199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_parse_sys_vals </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> *&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> *&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the log data of system field values. </p>
<dl class="section return"><dt>Returns</dt><dd>log data end or NULL out: roll ptr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">pos</td><td>out: TRX_ID position in record </td></tr>
    <tr><td class="paramname">trx_id</td><td>out: trx id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a736d5872d84c0e81c7c63d308e66e2f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_rec_in_place </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector to the record given. No field size changes are allowed. This function is usually invoked on a clustered index. The only use case for a secondary index is row_ins_sec_index_entry_by_modify() or its counterpart in ibuf_insert_to_index_page(). in: compressed page with enough space available, or NULL </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record where replaced </td></tr>
    <tr><td class="paramname">index</td><td>in: the index the record belongs to </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0dbc3d05e7439c1afdb28063ab827cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_upd_rec_sys_fields </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the trx id and roll ptr field in a clustered index record when a row is updated or marked deleted. in: roll ptr of the undo log record, can be 0 during IMPORT</p>
<p>Updates the trx id and roll ptr field in a clustered index record when a row is updated or marked deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record, can be 0 during IMPORT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23cb047352eff637ca3adc6816d7bfd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_rec_sys_fields_in_recovery </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the trx id and roll ptr field in a clustered index record in database recovery. in: roll ptr of the undo log record </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">pos</td><td>in: TRX_ID position in rec </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7169668781a556da74cd6b6821986ca5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void row_upd_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__ext__t.html">row_ext_t</a> **&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the new column values stored in the update vector. in: memory heap </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>in/out: row where replaced, indexed by col_no; the clustered index record must be covered by a lock or a page latch to prevent deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">ext</td><td>out, own: NULL, or externally stored column prefixes </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">update</td><td>in: an update vector built for the clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ef8c0ae6eea82f02c7ba30a644f1b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structque__thr__t.html">que_thr_t</a>* row_upd_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a row in a table. This is a high-level function used in SQL execution graphs. </p>
<dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL in: query thread </dd></dl>

</div>
</div>
<a class="anchor" id="a51d7c8cfa676ad73cf68f61cd4fc3068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* row_upd_write_sys_vals_to_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>log_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes into the redo log the values of trx id and roll ptr and enough info to determine their positions within a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>new pointer to mlog in: mtr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr of the undo log record </td></tr>
    <tr><td class="paramname">log_ptr</td><td>pointer to a buffer of size &gt; 20 opened in mlog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4662cf8a186586e3caad5a7a28cf9ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structupd__t.html">upd_t</a>* upd_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an update vector object. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update vector object in: heap from which memory allocated</dd></dl>
<p>Creates an update vector object. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update vector object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of fields </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap from which memory allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abba68102b6521acae8f0d8c3e6ba0a26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void upd_field_set_field_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structupd__field__t.html">upd_field_t</a> *&#160;</td>
          <td class="paramname"><em>upd_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an index field number to be updated by an update vector field. in: transaction</p>
<p>Sets an index field number to be updated by an update vector field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upd_field</td><td>in: update vector field </td></tr>
    <tr><td class="paramname">field_no</td><td>in: field number in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34246967bad8ff4d10daac7e83e5e3c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structupd__field__t.html">upd_field_t</a>* upd_get_field_by_field_no </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a field of an update vector by field_no. </p>
<dl class="section return"><dt>Returns</dt><dd>update vector field, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">no</td><td>in: field_no </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc0bebe9c2bdc7ec292e9784374476f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint upd_get_n_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of fields in the update vector == number of columns to be updated by an update vector. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields in: update vector</dd></dl>
<p>Returns the number of fields in the update vector == number of columns to be updated by an update vector. </p>
<dl class="section return"><dt>Returns</dt><dd>number of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cc9824c435b30f9957b9864ce39c8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structupd__field__t.html">upd_field_t</a>* upd_get_nth_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth field of an update vector. </p>
<dl class="section return"><dt>Returns</dt><dd>update vector field in: field position in update vector</dd></dl>
<p>Returns the nth field of an update vector. </p>
<dl class="section return"><dt>Returns</dt><dd>update vector field </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">n</td><td>in: field position in update vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcbf24a5f1842095a0aea1bde91e66f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="structupd__node__t.html">upd_node_t</a>* upd_node_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an update node for a query graph. </p>
<dl class="section return"><dt>Returns</dt><dd>own: update node in: mem heap where created </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:21 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
