<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/btr0cur.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">btr0cur.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="page0cur_8h_source.html">page0cur.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0types_8h_source.html">btr0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="que0types_8h_source.html">que0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="row0types_8h_source.html">row0types.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ha0ha_8h_source.html">ha0ha.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="btr0cur_8ic.html">btr0cur.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for btr0cur.h:</div>
<div class="dyncontent">
<div class="center"><img src="btr0cur_8h__incl.png" border="0" usemap="#include_2btr0cur_8h" alt=""/></div>
<map name="include_2btr0cur_8h" id="include_2btr0cur_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="btr0cur_8h__dep__incl.png" border="0" usemap="#include_2btr0cur_8hdep" alt=""/></div>
<map name="include_2btr0cur_8hdep" id="include_2btr0cur_8hdep">
</map>
</div>
</div>
<p><a href="btr0cur_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtr__path__t.html">btr_path_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a89f1a6886c93a569c625ff76e4445e3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f1a6886c93a569c625ff76e4445e3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_CUR_ADAPT</b></td></tr>
<tr class="memitem:ababcccef629f8c18436f6a1df93b01ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ababcccef629f8c18436f6a1df93b01ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BTR_CUR_HASH_ADAPT</b></td></tr>
<tr class="memitem:a5a7d338c847f204984733a9fdbe14789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5a7d338c847f204984733a9fdbe14789">btr_cur_get_index</a>(cursor)&#160;&#160;&#160;((cursor)-&gt;index)</td></tr>
<tr class="memitem:a5c8f65d3ff6c409b5a5a948098916698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c8f65d3ff6c409b5a5a948098916698"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_open_at_index_side</b>(f, i, l, c, lv, m)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#a9b6c9a553d567c08035bc1ece4bc451d">btr_cur_open_at_index_side_func</a>(f,i,l,c,lv,__FILE__,__LINE__,m)</td></tr>
<tr class="memitem:a945c2e96d9be4a7c908eab83dbbfea40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a945c2e96d9be4a7c908eab83dbbfea40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_open_at_rnd_pos</b>(i, l, c, m)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#ac6b17c00c932d341c9b0cbe9e0b23642">btr_cur_open_at_rnd_pos_func</a>(i,l,c,__FILE__,__LINE__,m)</td></tr>
<tr class="memitem:a5762abb71e85466cd85e563461bacc18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5762abb71e85466cd85e563461bacc18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_update_alloc_zip</b>(page_zip, cursor, index, offsets, len, cr, mtr)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#affea492f6a0857289bc35922cf9521aa">btr_cur_update_alloc_zip_func</a>(page_zip,cursor,index,offsets,len,cr,mtr)</td></tr>
<tr class="memitem:abee4744ed5f9d94ff1ad4026226475c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abee4744ed5f9d94ff1ad4026226475c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_optimistic_delete</b>(cursor, flags, mtr)&#160;&#160;&#160;<a class="el" href="btr0cur_8h.html#a1fc39bef164c51a15dc4bb1c98710f2f">btr_cur_optimistic_delete_func</a>(cursor, flags, mtr)</td></tr>
<tr class="memitem:a304f2cc2922cdde4941f42d38d984db9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a304f2cc2922cdde4941f42d38d984db9">BTR_CUR_PAGE_COMPRESS_LIMIT</a>&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> / 2)</td></tr>
<tr class="memitem:a4d03f55936b83f0125d0d45116459421"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a4d03f55936b83f0125d0d45116459421">BTR_PATH_ARRAY_N_SLOTS</a>&#160;&#160;&#160;250</td></tr>
<tr class="memitem:a5bff9b3a120d816b69c28745df3a1c74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5bff9b3a120d816b69c28745df3a1c74">BTR_CUR_RETRY_DELETE_N_TIMES</a>&#160;&#160;&#160;100</td></tr>
<tr class="memitem:a275ba443abeacaaaf592c871624ce84b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a275ba443abeacaaaf592c871624ce84b">BTR_CUR_RETRY_SLEEP_TIME</a>&#160;&#160;&#160;50000</td></tr>
<tr class="memitem:a2aae65cf0e896285b40f88c4b6da04ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2aae65cf0e896285b40f88c4b6da04ee">BTR_EXTERN_SPACE_ID</a>&#160;&#160;&#160;0</td></tr>
<tr class="memitem:a6b5ce803aaeda0b57a2a9df787e6fbfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a6b5ce803aaeda0b57a2a9df787e6fbfe">BTR_EXTERN_PAGE_NO</a>&#160;&#160;&#160;4</td></tr>
<tr class="memitem:af2f4fdf4020b5635b568e2c281974d89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#af2f4fdf4020b5635b568e2c281974d89">BTR_EXTERN_OFFSET</a>&#160;&#160;&#160;8</td></tr>
<tr class="memitem:a8aa982d3e1451a9520baadb6d6e4394e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a8aa982d3e1451a9520baadb6d6e4394e">BTR_EXTERN_LEN</a>&#160;&#160;&#160;12</td></tr>
<tr class="memitem:a5e9a69e0b59d0aefc436131d51b72e93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a5e9a69e0b59d0aefc436131d51b72e93">BTR_EXTERN_OWNER_FLAG</a>&#160;&#160;&#160;128</td></tr>
<tr class="memitem:abb40edeff5f816dea0643db34370ff33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#abb40edeff5f816dea0643db34370ff33">BTR_EXTERN_INHERITED_FLAG</a>&#160;&#160;&#160;64</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1fb016f118032fcb677c3b2a4f107e2b">BTR_NO_UNDO_LOG_FLAG</a> =  1, 
<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba046932973ff414437088666363342436">BTR_NO_LOCKING_FLAG</a> =  2, 
<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba159501d7bc944849faa8082ce7b55466">BTR_KEEP_SYS_FLAG</a> =  4, 
<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1a9e17a40a357b5194b5b12eccdf9eee">BTR_KEEP_POS_FLAG</a> =  8, 
<br/>
&#160;&#160;<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55baa2e940baf537747a3cda3db0a2cbb865">BTR_CREATE_FLAG</a> =  16, 
<a class="el" href="btr0cur_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba1891f77b4a41b153e3445a43c806efcf">BTR_KEEP_IBUF_BITMAP</a> =  32
<br/>
 }</td></tr>
<tr class="memitem:a3361a59faf9e0a4f09a76ecf15177dfa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> { <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaace3dea2a3d10c4fb37196ff5cb6e5201">BTR_STORE_INSERT</a> =  0, 
<a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaa1ff8c4d532e7e416faa55e72f9beca51">BTR_STORE_INSERT_UPDATE</a>, 
<a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfaa7f978bffba76536408f3c51cacc0b916">BTR_STORE_UPDATE</a>
 }</td></tr>
<tr class="memitem:acafc257d9789b9b946149978d1934a96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96">btr_cur_method</a> { <br/>
&#160;&#160;<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96aa5e657955c98714ac4df0abd6c2856c0">BTR_CUR_HASH</a> =  1, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a0c0b480a0e2ff01e08a968319e27135d">BTR_CUR_HASH_FAIL</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a9e995eb02ca7ee7e67da00cbe8bf2eda">BTR_CUR_BINARY</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a6c64e9fa37d7185525aa24d3dcffd915">BTR_CUR_INSERT_TO_IBUF</a>, 
<br/>
&#160;&#160;<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96aee5660b8b720720ebbf507080a04739f">BTR_CUR_DEL_MARK_IBUF</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96acf08a9d1477925822b67557699699f67">BTR_CUR_DELETE_IBUF</a>, 
<a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96a3761d0d9cf510bcb30c8a63336f4d4c7">BTR_CUR_DELETE_REF</a>
<br/>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9fbd32cfc53ed0bdd7cc7f50ad7c8e24"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a9fbd32cfc53ed0bdd7cc7f50ad7c8e24">btr_cur_get_page_cur</a> (const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:a0ed1c2c1c1cd96ec7b4a61206e74e0f9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a0ed1c2c1c1cd96ec7b4a61206e74e0f9">btr_cur_get_block</a> (const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:ac2f6fdb5778c30d2f44cddb90e21c70e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE rec_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac2f6fdb5778c30d2f44cddb90e21c70e">btr_cur_get_rec</a> (const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:a16857b9aaf748152f3d8729a81adc742"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a16857b9aaf748152f3d8729a81adc742">btr_cur_get_page_zip</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:ac7421ec8e267ec27fb024146eaa431dd"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac7421ec8e267ec27fb024146eaa431dd">btr_cur_invalidate</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:aed5024b078b665885c29921798da75dc"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aed5024b078b665885c29921798da75dc">btr_cur_get_page</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:aefd6e4cb05606cefb5d21f1e73825d41"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aefd6e4cb05606cefb5d21f1e73825d41">btr_cur_position</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, rec_t *rec, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor)</td></tr>
<tr class="memitem:a82a13fbc0aaa77d0f1164914785757c0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint level, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, ulint mode, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint has_search_latch, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a9b6c9a553d567c08035bc1ece4bc451d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a9b6c9a553d567c08035bc1ece4bc451d">btr_cur_open_at_index_side_func</a> (bool from_left, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint level, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ac6b17c00c932d341c9b0cbe9e0b23642"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac6b17c00c932d341c9b0cbe9e0b23642">btr_cur_open_at_rnd_pos_func</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint latch_mode, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:aedcc2ada2a58da05de9b82cb8aeac9a7"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aedcc2ada2a58da05de9b82cb8aeac9a7">btr_cur_optimistic_insert</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **heap, <a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, rec_t **rec, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, ulint n_ext, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:a34fdcfe6aa08e8d6f9ce4af72d05ddb0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a34fdcfe6aa08e8d6f9ce4af72d05ddb0">btr_cur_pessimistic_insert</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **heap, <a class="el" href="structdtuple__t.html">dtuple_t</a> *entry, rec_t **rec, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, ulint n_ext, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memitem:affea492f6a0857289bc35922cf9521aa"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#affea492f6a0857289bc35922cf9521aa">btr_cur_update_alloc_zip_func</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *cursor, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, ulint *offsets, ulint length, bool create, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:af3788e3f20b10774faad5b1c977fc6d9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#af3788e3f20b10774faad5b1c977fc6d9">btr_cur_update_in_place</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *update, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a3c6b8d23045f7eae26a9a31dcb39c531"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3c6b8d23045f7eae26a9a31dcb39c531">btr_cur_update_in_place_log</a> (ulint flags, const rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a> roll_ptr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ab848492a23a0ee248aa41e57625319bd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ab848492a23a0ee248aa41e57625319bd">btr_cur_optimistic_update</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **heap, const <a class="el" href="structupd__t.html">upd_t</a> *update, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a3ee38b66667c7bd3a1b30b466e6b881f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3ee38b66667c7bd3a1b30b466e6b881f">btr_cur_pessimistic_update</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint **offsets, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **offsets_heap, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *entry_heap, <a class="el" href="structbig__rec__t.html">big_rec_t</a> **big_rec, const <a class="el" href="structupd__t.html">upd_t</a> *update, ulint cmpl_info, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ad1dd9c89e7a295ce17302f382a7666c5"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ad1dd9c89e7a295ce17302f382a7666c5">btr_cur_del_mark_set_clust_rec</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *<a class="el" href="mem0mem_8ic.html#a17afa58b2bc574dedcd1cc02e1fdf165">block</a>, rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a44d47600bf3eaa8e61202dda9c7804db"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a44d47600bf3eaa8e61202dda9c7804db">btr_cur_del_mark_set_sec_rec</a> (ulint flags, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> val, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a9a020ba9861f42773a64bf856b543fbd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a9a020ba9861f42773a64bf856b543fbd">btr_cur_compress_if_useful</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> adjust, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a1fc39bef164c51a15dc4bb1c98710f2f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a1fc39bef164c51a15dc4bb1c98710f2f">btr_cur_optimistic_delete_func</a> (<a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint flags, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:a48fccd878bd7fdfeb4dea52271dd5a01"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a48fccd878bd7fdfeb4dea52271dd5a01">btr_cur_pessimistic_delete</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *err, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> has_reserved_extents, <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *cursor, ulint flags, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr))</td></tr>
<tr class="memitem:ad06c6cbe14c2af25f2240b5e54aa1d5a"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ad06c6cbe14c2af25f2240b5e54aa1d5a">btr_cur_parse_update_in_place</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index)</td></tr>
<tr class="memitem:a67626b88e4c9b6e4bd41bc71d432e095"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a67626b88e4c9b6e4bd41bc71d432e095">btr_cur_parse_del_mark_set_clust_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index)</td></tr>
<tr class="memitem:a3d8d168c724c8ac87371442df85fc233"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a3d8d168c724c8ac87371442df85fc233">btr_cur_parse_del_mark_set_sec_rec</a> (byte *ptr, byte *end_ptr, <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *page, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip)</td></tr>
<tr class="memitem:ac56a487d045ea12d204c0cbe34ff4c95"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ib_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac56a487d045ea12d204c0cbe34ff4c95">btr_estimate_n_rows_in_range</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple1, ulint mode1, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple2, ulint mode2)</td></tr>
<tr class="memitem:ab50de491c34525f93cbe27307044ea89"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ab50de491c34525f93cbe27307044ea89">btr_estimate_number_of_different_key_vals</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index)</td></tr>
<tr class="memitem:a58003b4ea2270cb2170f97974b5f36fa"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a58003b4ea2270cb2170f97974b5f36fa">btr_rec_get_externally_stored_len</a> (const rec_t *rec, const ulint *offsets)</td></tr>
<tr class="memitem:a4158fa13ed38d59d252a9f4fc302c19e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a4158fa13ed38d59d252a9f4fc302c19e">btr_cur_disown_inherited_fields</a> (<a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, rec_t *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *index, const ulint *offsets, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)))</td></tr>
<tr class="memitem:a8dbf5deafa675fdb552348508e8893b7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a8dbf5deafa675fdb552348508e8893b7">btr_blob_op_is_update</a> (enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> op))</td></tr>
<tr class="memitem:a4ee76d244b2f81a3424850e53ed3677f"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a4ee76d244b2f81a3424850e53ed3677f">btr_store_big_rec_extern_fields</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *rec_block, rec_t *rec, const ulint *offsets, const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *big_rec_vec, <a class="el" href="structmtr__t.html">mtr_t</a> *btr_mtr, enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a> op))</td></tr>
<tr class="memitem:ac74d8a6bde9542fcafed8fa7ca14ab7d"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac74d8a6bde9542fcafed8fa7ca14ab7d">btr_free_externally_stored_field</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *index, byte *field_ref, const rec_t *rec, const ulint *offsets, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, ulint i, enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a> rb_ctx, <a class="el" href="structmtr__t.html">mtr_t</a> *local_mtr)</td></tr>
<tr class="memitem:ab24703540cfa917a52abe379751f5004"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ab24703540cfa917a52abe379751f5004">btr_copy_externally_stored_field_prefix</a> (byte *buf, ulint len, ulint zip_size, const byte *data, ulint local_len)</td></tr>
<tr class="memitem:ac3c5f0fcaabcc7487018ae03937c2412"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ac3c5f0fcaabcc7487018ae03937c2412">btr_copy_externally_stored_field</a> (ulint *len, const byte *data, ulint zip_size, ulint local_len, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a2c383bd105f982d216a7a430935f5706"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a2c383bd105f982d216a7a430935f5706">btr_rec_copy_externally_stored_field</a> (const rec_t *rec, const ulint *offsets, ulint zip_size, ulint no, ulint *len, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap)</td></tr>
<tr class="memitem:a4002c48c14a35d9a541835e68eec9f55"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a4002c48c14a35d9a541835e68eec9f55">btr_push_update_extern_fields</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, const <a class="el" href="structupd__t.html">upd_t</a> *update, <a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *heap))</td></tr>
<tr class="memitem:a0c43a7dff2e949e99467e0323bcc24f9"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a0c43a7dff2e949e99467e0323bcc24f9">btr_cur_set_deleted_flag_for_ibuf</a> (rec_t *rec, <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *page_zip, <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> val, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9de1fa5a5c99bbc84b5678762a623cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9de1fa5a5c99bbc84b5678762a623cf3"></a>
UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>warn_unused_result</b></td></tr>
<tr class="memitem:a7b7a92b1123d6493729904f846f05a03"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a7b7a92b1123d6493729904f846f05a03">btr_cur_n_non_sea</a></td></tr>
<tr class="memitem:ae0b3d4f868488aa0addf8d9fa32df663"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#ae0b3d4f868488aa0addf8d9fa32df663">btr_cur_n_sea</a></td></tr>
<tr class="memitem:aefef1d2e4bf03540d18ff799bf9c0a74"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#aefef1d2e4bf03540d18ff799bf9c0a74">btr_cur_n_non_sea_old</a></td></tr>
<tr class="memitem:a8df6a65d39b12848a998a57d2cc328d0"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="btr0cur_8h.html#a8df6a65d39b12848a998a57d2cc328d0">btr_cur_n_sea_old</a></td></tr>
<tr class="memitem:a2f6f6e317169b84969361e99eb711b3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f6f6e317169b84969361e99eb711b3b"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>btr_cur_limit_optimistic_insert_debug</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The index tree cursor</p>
<p>Created 10/16/1994 Heikki Tuuri </p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a5a7d338c847f204984733a9fdbe14789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define btr_cur_get_index</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cursor</td><td>)</td>
          <td>&#160;&#160;&#160;((cursor)-&gt;index)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of a cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>b-tree cursor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index </dd></dl>

</div>
</div>
<a class="anchor" id="a304f2cc2922cdde4941f42d38d984db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_PAGE_COMPRESS_LIMIT&#160;&#160;&#160;(<a class="el" href="univ_8i.html#a43a8a62f5267962c41fa964d0b3aecae">UNIV_PAGE_SIZE</a> / 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">In the pessimistic delete, if the page data size drops below this
</pre><p> limit, merging it to a neighbor is tried </p>

</div>
</div>
<a class="anchor" id="a5bff9b3a120d816b69c28745df3a1c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_RETRY_DELETE_N_TIMES&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If pessimistic delete fails because of lack of file space, there
</pre><p> is still a good change of success a little later. Try this many times. </p>

</div>
</div>
<a class="anchor" id="a275ba443abeacaaaf592c871624ce84b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_CUR_RETRY_SLEEP_TIME&#160;&#160;&#160;50000</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If pessimistic delete fails because of lack of file space, there
</pre><p> is still a good change of success a little later. Sleep this many microseconds between retries. </p>

</div>
</div>
<a class="anchor" id="abb40edeff5f816dea0643db34370ff33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_INHERITED_FLAG&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If the second most significant bit of BTR_EXTERN_LEN (i.e., the
</pre><p> second most significant bit of the byte at smallest address) is 1 then it means that the externally stored field was inherited from an earlier version of the row. In rollback we are not allowed to free an inherited external field. </p>

</div>
</div>
<a class="anchor" id="a8aa982d3e1451a9520baadb6d6e4394e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_LEN&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>8 bytes containing the length of the externally stored part of the BLOB. The 2 highest bits are reserved to the flags below. </p>

</div>
</div>
<a class="anchor" id="af2f4fdf4020b5635b568e2c281974d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_OFFSET&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>offset of BLOB header on that page </p>

</div>
</div>
<a class="anchor" id="a5e9a69e0b59d0aefc436131d51b72e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_OWNER_FLAG&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The most significant bit of BTR_EXTERN_LEN (i.e., the most
</pre><p> significant bit of the byte at smallest address) is set to 1 if this field does not 'own' the externally stored field; only the owner field is allowed to free the field in purge! </p>

</div>
</div>
<a class="anchor" id="a6b5ce803aaeda0b57a2a9df787e6fbfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_PAGE_NO&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>page no where stored </p>

</div>
</div>
<a class="anchor" id="a2aae65cf0e896285b40f88c4b6da04ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_EXTERN_SPACE_ID&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The reference in a field for which data is stored on a different page.
</pre><p> The reference is at the end of the 'locally' stored part of the field. 'Locally' means storage in the index record. We store locally a long enough prefix of each column so that we can determine the ordering parts of each index record without looking into the externally stored part. space id where stored </p>

</div>
</div>
<a class="anchor" id="a4d03f55936b83f0125d0d45116459421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BTR_PATH_ARRAY_N_SLOTS&#160;&#160;&#160;250</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>size of path array (in slots) </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mode flags for btr_cur operations; these can be ORed </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba1fb016f118032fcb677c3b2a4f107e2b"></a>BTR_NO_UNDO_LOG_FLAG</em>&nbsp;</td><td>
<p>do no undo logging </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba046932973ff414437088666363342436"></a>BTR_NO_LOCKING_FLAG</em>&nbsp;</td><td>
<p>do no record lock checking </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba159501d7bc944849faa8082ce7b55466"></a>BTR_KEEP_SYS_FLAG</em>&nbsp;</td><td>
<p>sys fields will be found in the update vector or inserted entry </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba1a9e17a40a357b5194b5b12eccdf9eee"></a>BTR_KEEP_POS_FLAG</em>&nbsp;</td><td>
<p><a class="el" href="btr0cur_8h.html#a3ee38b66667c7bd3a1b30b466e6b881f">btr_cur_pessimistic_update()</a> must keep cursor position when moving columns to big_rec </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55baa2e940baf537747a3cda3db0a2cbb865"></a>BTR_CREATE_FLAG</em>&nbsp;</td><td>
<p>the caller is creating the index or wants to bypass the index-&gt;info.online creation log </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fc87d81c62e9abb8790b6e5713c55ba1891f77b4a41b153e3445a43c806efcf"></a>BTR_KEEP_IBUF_BITMAP</em>&nbsp;</td><td>
<p>the caller of <a class="el" href="btr0cur_8h.html#ab848492a23a0ee248aa41e57625319bd">btr_cur_optimistic_update()</a> or <a class="el" href="btr0cur_8h.html#af3788e3f20b10774faad5b1c977fc6d9">btr_cur_update_in_place()</a> will take care of updating IBUF_BITMAP_FREE </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3361a59faf9e0a4f09a76ecf15177dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation code for <a class="el" href="btr0cur_8h.html#a4ee76d244b2f81a3424850e53ed3677f">btr_store_big_rec_extern_fields()</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3361a59faf9e0a4f09a76ecf15177dfaace3dea2a3d10c4fb37196ff5cb6e5201"></a>BTR_STORE_INSERT</em>&nbsp;</td><td>
<p>Store off-page columns for a freshly inserted record </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3361a59faf9e0a4f09a76ecf15177dfaa1ff8c4d532e7e416faa55e72f9beca51"></a>BTR_STORE_INSERT_UPDATE</em>&nbsp;</td><td>
<p>Store off-page columns for an insert by update </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3361a59faf9e0a4f09a76ecf15177dfaa7f978bffba76536408f3c51cacc0b916"></a>BTR_STORE_UPDATE</em>&nbsp;</td><td>
<p>Store off-page columns for an update </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acafc257d9789b9b946149978d1934a96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="btr0cur_8h.html#acafc257d9789b9b946149978d1934a96">btr_cur_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values for the flag documenting the used search method </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96aa5e657955c98714ac4df0abd6c2856c0"></a>BTR_CUR_HASH</em>&nbsp;</td><td>
<p>successful shortcut using the hash index </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96a0c0b480a0e2ff01e08a968319e27135d"></a>BTR_CUR_HASH_FAIL</em>&nbsp;</td><td>
<p>failure using hash, success using binary search: the misleading hash reference is stored in the field hash_node, and might be necessary to update </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96a9e995eb02ca7ee7e67da00cbe8bf2eda"></a>BTR_CUR_BINARY</em>&nbsp;</td><td>
<p>success using the binary search </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96a6c64e9fa37d7185525aa24d3dcffd915"></a>BTR_CUR_INSERT_TO_IBUF</em>&nbsp;</td><td>
<p>performed the intended insert to the insert buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96aee5660b8b720720ebbf507080a04739f"></a>BTR_CUR_DEL_MARK_IBUF</em>&nbsp;</td><td>
<p>performed the intended delete mark in the insert/delete buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96acf08a9d1477925822b67557699699f67"></a>BTR_CUR_DELETE_IBUF</em>&nbsp;</td><td>
<p>performed the intended delete in the insert/delete buffer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acafc257d9789b9b946149978d1934a96a3761d0d9cf510bcb30c8a63336f4d4c7"></a>BTR_CUR_DELETE_REF</em>&nbsp;</td><td>
<p><a class="el" href="row0purge_8h.html#a5ce2d96d1a406210101d620bb934512e">row_purge_poss_sec()</a> failed </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a8dbf5deafa675fdb552348508e8893b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_blob_op_is_update </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if an operation on off-page columns is an update. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if op != BTR_STORE_INSERT </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3c5f0fcaabcc7487018ae03937c2412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. The clustered index record must be protected by a lock or a page latch. </p>
<dl class="section return"><dt>Returns</dt><dd>the whole field copied to heap in: mem heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>out: length of the whole field </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">local_len</td><td>in: length of data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab24703540cfa917a52abe379751f5004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_copy_externally_stored_field_prefix </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>local_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the prefix of an externally stored field of a record. The clustered index record must be protected by a lock or a page latch. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the copied field, or 0 if the column was being or has been deleted in: length of data, in bytes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>out: the field, or a prefix of it </td></tr>
    <tr><td class="paramname">len</td><td>in: length of buf, in bytes </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">data</td><td>in: 'internally' stored part of the field containing also the reference to the external part; must be protected by a lock or a page latch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a020ba9861f42773a64bf856b543fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_cur_compress_if_useful </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>adjust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to compress a page of the tree if it seems useful. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. NOTE: it is assumed that the caller has reserved enough free extents so that the compression will always succeed if done! </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the page to compress; cursor does not stay valid if compression occurs </td></tr>
    <tr><td class="paramname">adjust</td><td>in: TRUE if should adjust the cursor position even if compression occurs </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1dd9c89e7a295ce17302f382a7666c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a clustered index record deleted. Writes an undo log record to undo log on this delete marking. Writes in the trx id field the id of the deleting transaction, and in the roll ptr field pointer to the undo log record created. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: buffer block of the record </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index of the record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44d47600bf3eaa8e61202dda9c7804db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record delete mark to TRUE or FALSE. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: locking flag </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4158fa13ed38d59d252a9f4fc302c19e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_disown_inherited_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks non-updated off-page fields as disowned by this record. The ownership must be transferred to the updated record which is inserted elsewhere in the index tree. In purge only the owner of externally stored field is allowed to free the field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page whose uncompressed part will be updated, or NULL </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record in a clustered index </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the page </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ed1c2c1c1cd96ec7b4a61206e74e0f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structbuf__block__t.html">buf_block_t</a>* btr_cur_get_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer block on which the tree cursor is positioned. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to buffer block in: tree cursor</dd></dl>
<p>Returns the buffer block on which the tree cursor is positioned. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to buffer block </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed5024b078b665885c29921798da75dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* btr_cur_get_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the page of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to page in: tree cursor</dd></dl>
<p>Returns the page of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fbd32cfc53ed0bdd7cc7f50ad7c8e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structpage__cur__t.html">page_cur_t</a>* btr_cur_get_page_cur </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the page cursor component of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to page cursor component in: tree cursor</dd></dl>
<p>Returns the page cursor component of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to page cursor component </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16857b9aaf748152f3d8729a81adc742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a>* btr_cur_get_page_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the compressed page on which the tree cursor is positioned. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to compressed page, or NULL if the page is not compressed in: tree cursor</dd></dl>
<p>Returns the compressed page on which the tree cursor is positioned. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to compressed page, or NULL if the page is not compressed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2f6fdb5778c30d2f44cddb90e21c70e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE rec_t* btr_cur_get_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the record pointer of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to record in: tree cursor</dd></dl>
<p>Returns the record pointer of a tree cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7421ec8e267ec27fb024146eaa431dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalidates a tree cursor by setting record pointer to NULL. in: tree cursor</p>
<p>Invalidates a tree cursor by setting record pointer to NULL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: tree cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b6c9a553d567c08035bc1ece4bc451d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_index_side_func </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens a cursor at either end of an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_left</td><td>in: true if open to the low end, false if to the high end </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: latch mode </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor </td></tr>
    <tr><td class="paramname">level</td><td>in: level to search for (0=leaf) </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6b17c00c932d341c9b0cbe9e0b23642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_open_at_rnd_pos_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions a cursor at a randomly chosen position within a B-tree. in: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ... </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree cursor </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fc39bef164c51a15dc4bb1c98710f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_cur_optimistic_delete_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned. It is assumed that the mtr has an x-latch on the page where the cursor is positioned, but no latch on the whole tree. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if success, i.e., the page did not become too empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to delete; cursor stays valid: if deletion succeeds, on function exit it points to the successor of the deleted record </td></tr>
    <tr><td class="paramname">flags</td><td>in: BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; if this function returns TRUE on a leaf page of a secondary index, the mtr must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedcc2ada2a58da05de9b82cb8aeac9a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to perform an insert to a page in an index tree, next to cursor. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page. If there is just one record on the page, the insert will always succeed; this is to prevent trying to split a page with just one record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_WAIT_LOCK, DB_FAIL, or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameters index and thr should be specified </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on page after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this function returns DB_SUCCESS on a leaf page of a secondary index in a compressed tablespace, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab848492a23a0ee248aa41e57625319bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_optimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to update a record on a page in an index tree. It is assumed that mtr holds an x-latch on the page. The operation does not succeed if there is too little space on the page or if the update would result in too empty a page, so that tree compression is recommended. </p>
<dl class="section return"><dt>Returns</dt><dd>error code, including </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_OVERFLOW</td><td>if the updated record does not fit </td></tr>
    <tr><td class="paramname">DB_UNDERFLOW</td><td>if the page would become too empty </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to NULL or memory heap </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this must also contain trx id and roll ptr fields </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67626b88e4c9b6e4bd41bc71d432e095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_clust_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a clustered index record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: index corresponding to page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d8d168c724c8ac87371442df85fc233"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_del_mark_set_sec_rec </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the redo log record for delete marking or unmarking of a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in/out: compressed page, or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad06c6cbe14c2af25f2240b5e54aa1d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_cur_parse_update_in_place </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a redo log record of updating a record in-place. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL in: index corresponding to page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">page</td><td>in/out: page or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48fccd878bd7fdfeb4dea52271dd5a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> btr_cur_pessimistic_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> *&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>has_reserved_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the record on which the tree cursor is positioned. Tries to compress the page if its fillfactor drops below a threshold or if it is the only page on the level. It is assumed that mtr holds an x-latch on the tree and on the cursor page. To avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if compression occurred </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err</td><td>out: DB_SUCCESS or DB_OUT_OF_FILE_SPACE; the latter may occur because we may have to update node pointers on upper levels, and in the case of variable length keys these may actually grow in size </td></tr>
    <tr><td class="paramname">has_reserved_extents</td><td>in: TRUE if the caller has already reserved enough free extents so that he knows that the operation will succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to delete; if compression does not occur, the cursor stays valid: it points to successor of deleted record on function exit </td></tr>
    <tr><td class="paramname">flags</td><td>in: BTR_CREATE_FLAG or 0 </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34fdcfe6aa08e8d6f9ce4af72d05ddb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t **&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an insert on a page of an index tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the insert is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags: if not zero, the parameter thr should be specified; if no undo logging is specified, then the caller must have reserved enough free extents in the file space so that the insertion will certainly succeed </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor after which to insert; cursor stays valid </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry</td><td>in/out: entry to insert </td></tr>
    <tr><td class="paramname">rec</td><td>out: pointer to inserted record if succeed </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">n_ext</td><td>in: number of externally stored columns </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ee38b66667c7bd3a1b30b466e6b881f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_pessimistic_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offsets_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>entry_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbig__rec__t.html">big_rec_t</a> **&#160;</td>
          <td class="paramname"><em>big_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an update of a record on a page of a tree. It is assumed that mtr holds an x-latch on the tree and on the cursor page. If the update is made on the leaf level, to avoid deadlocks, mtr must also own x-latches to brothers of page, if those brothers exist. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging, locking, and rollback flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: cursor on the record to update; cursor may become invalid if *big_rec == NULL || !(flags &amp; BTR_KEEP_POS_FLAG) </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">offsets_heap</td><td>in/out: pointer to memory heap that can be emptied, or NULL </td></tr>
    <tr><td class="paramname">entry_heap</td><td>in/out: memory heap for allocating big_rec and the index tuple </td></tr>
    <tr><td class="paramname">big_rec</td><td>out: big rec vector whose fields have to be stored externally by the caller, or NULL </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector; this is allowed also contain trx id and roll ptr fields, but the values in update vector have no effect </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd6e4cb05606cefb5d21f1e73825d41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void btr_cur_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Positions a tree cursor at a given record. in: cursor</p>
<p>Positions a tree cursor at a given record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in tree </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">cursor</td><td>out: cursor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82a13fbc0aaa77d0f1164914785757c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_search_to_nth_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>has_search_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches an index tree and positions a tree cursor on a given level. NOTE: n_fields_cmp in tuple must be set so that it cannot be compared to node pointer page number fields on the upper levels of the tree! Note that if mode is PAGE_CUR_LE, which is used in inserts, then cursor-&gt;up_match and cursor-&gt;low_match both will have sensible values. If mode is PAGE_CUR_GE, then up_match will a have a sensible value. in: mtr </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">level</td><td>in: the tree level of search </td></tr>
    <tr><td class="paramname">tuple</td><td>in: data tuple; NOTE: n_fields_cmp in tuple must be set so that it cannot get compared to the node ptr page number field! </td></tr>
    <tr><td class="paramname">mode</td><td>in: PAGE_CUR_L, ...; NOTE that if the search is made using a unique prefix of a record, mode should be PAGE_CUR_LE, not PAGE_CUR_GE, as the latter may end up on the previous page of the record! Inserts should always be made using PAGE_CUR_LE to search the position! </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: BTR_SEARCH_LEAF, ..., ORed with at most one of BTR_INSERT, BTR_DELETE_MARK, BTR_DELETE, or BTR_ESTIMATE; cursor-&gt;left_block is used to store a pointer to the left neighbor page, in the cases BTR_SEARCH_PREV and BTR_MODIFY_PREV; NOTE that if has_search_latch is != 0, we maybe do not have a latch set on the cursor page, we assume the caller uses his search latch to protect the record! </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: tree cursor; the cursor page is s- or x-latched, but see also above! </td></tr>
    <tr><td class="paramname">has_search_latch</td><td>in: latch mode the caller currently has on btr_search_latch: RW_S_LATCH, or 0 </td></tr>
    <tr><td class="paramname">file</td><td>in: file name </td></tr>
    <tr><td class="paramname">line</td><td>in: line where called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c43a7dff2e949e99467e0323bcc24f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_set_deleted_flag_for_ibuf </td>
          <td>(</td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a secondary index record's delete mark to the given value. This function is only used by the insert buffer merge mechanism. in/out: mini-transaction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page corresponding to rec, or NULL when the tablespace is uncompressed </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affea492f6a0857289bc35922cf9521aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool btr_cur_update_alloc_zip_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See if there is enough place in the page modification log to log an update-in-place.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if out of space; IBUF_BITMAP_FREE will be reset outside mtr if the page was recompressed </td></tr>
    <tr><td class="paramname">true</td><td>if enough place;</td></tr>
  </table>
  </dd>
</dl>
<p>IMPORTANT: The caller will have to update IBUF_BITMAP_FREE if this is a secondary index leaf page. This has to be done either within the same mini-transaction, or by invoking <a class="el" href="ibuf0ibuf_8h.html#ac0fa1ac9abb6d51ec99ac39e3b9378d4">ibuf_reset_free_bits()</a> before mtr_commit(mtr). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_zip</td><td>in/out: compressed page </td></tr>
    <tr><td class="paramname">cursor</td><td>in/out: B-tree page cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: the index corresponding to cursor </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets of the cursor record </td></tr>
    <tr><td class="paramname">length</td><td>in: size needed </td></tr>
    <tr><td class="paramname">create</td><td>in: true=delete-and-insert, false=update-in-place </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3788e3f20b10774faad5b1c977fc6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_cur_update_in_place </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__cur__t.html">btr_cur_t</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>cmpl_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates a record when the update causes no size changes in its fields. </p>
<dl class="section return"><dt>Returns</dt><dd>locking or undo log related error code, or </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DB_SUCCESS</td><td>on success </td></tr>
    <tr><td class="paramname">DB_ZIP_OVERFLOW</td><td>if there is not enough space left on the compressed page (IBUF_BITMAP_FREE was reset outside mtr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: undo logging and locking flags </td></tr>
    <tr><td class="paramname">cursor</td><td>in: cursor on the record to update; cursor stays valid and positioned on the same record </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets on cursor-&gt;page_cur.rec </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">cmpl_info</td><td>in: compiler info on secondary index updates </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction; if this is a secondary index, the caller must mtr_commit(mtr) before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c6b8d23045f7eae26a9a31dcb39c531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_cur_update_in_place_log </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#ad3ccac613ce33a8680d147c4a4f12e94">roll_ptr_t</a>&#160;</td>
          <td class="paramname"><em>roll_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a redo log record of updating a record in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: flags </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">trx_id</td><td>in: transaction id </td></tr>
    <tr><td class="paramname">roll_ptr</td><td>in: roll ptr </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac56a487d045ea12d204c0cbe34ff4c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ib_int64_t btr_estimate_n_rows_in_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of rows in a given index range. </p>
<dl class="section return"><dt>Returns</dt><dd>estimated number of rows in: search mode for range end </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">tuple1</td><td>in: range start, may also be empty tuple </td></tr>
    <tr><td class="paramname">mode1</td><td>in: search mode for range start </td></tr>
    <tr><td class="paramname">tuple2</td><td>in: range end, may also be empty tuple </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab50de491c34525f93cbe27307044ea89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_estimate_number_of_different_key_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimates the number of different key values in a given index, for each n-column prefix of the index where 1 &lt;= n &lt;= dict_index_get_n_unique(index). The estimates are stored in the array index-&gt;stat_n_diff_key_vals[] (indexed 0..n_uniq-1) and the number of pages that were sampled is saved in index-&gt;stat_n_sample_sizes[]. If innodb_stats_method is nulls_ignored, we also record the number of non-null values for each prefix and stored the estimates in array index-&gt;stat_n_non_null_key_vals. in: index </p>

</div>
</div>
<a class="anchor" id="ac74d8a6bde9542fcafed8fa7ca14ab7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void btr_free_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>field_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__zip__des__t.html">page_zip_des_t</a> *&#160;</td>
          <td class="paramname"><em>page_zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trx0types_8h.html#af9c8cb5dde8e33f96634b07b215c6f16">trx_rb_ctx</a>&#160;</td>
          <td class="paramname"><em>rb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>local_mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the space in an externally stored field to the file space management if the field in data is owned the externally stored field, in a rollback we may have the additional condition that the field must not be inherited. in: mtr containing the latch to data an an X-latch to the index tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of the data, the index tree MUST be X-latched; if the tree height is 1, then also the root page must be X-latched! (this is relevant in the case this function is called from purge where 'data' is located on an undo log page, not an index page) </td></tr>
    <tr><td class="paramname">field_ref</td><td>in/out: field reference </td></tr>
    <tr><td class="paramname">rec</td><td>in: record containing field_ref, for <a class="el" href="page0zip_8h.html#acc25e4a17a4e12a1c9ab774fc8823eea">page_zip_write_blob_ptr()</a>, or NULL </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index), or NULL </td></tr>
    <tr><td class="paramname">page_zip</td><td>in: compressed page corresponding to rec, or NULL if rec == NULL </td></tr>
    <tr><td class="paramname">i</td><td>in: field number of field_ref; ignored if rec == NULL </td></tr>
    <tr><td class="paramname">rb_ctx</td><td>in: rollback context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4002c48c14a35d9a541835e68eec9f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN ulint btr_push_update_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structupd__t.html">upd_t</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags the data tuple fields that are marked as extern storage in the update vector. We use this function to remember which fields we must mark as extern storage in a record inserted for an update. </p>
<dl class="section return"><dt>Returns</dt><dd>number of flagged external columns </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: data tuple </td></tr>
    <tr><td class="paramname">update</td><td>in: update vector </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c383bd105f982d216a7a430935f5706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN byte* btr_rec_copy_externally_stored_field </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>zip_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__block__info__t.html">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies an externally stored field of a record to mem heap. </p>
<dl class="section return"><dt>Returns</dt><dd>the field copied to heap, or NULL if the field is incomplete in: mem heap </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: record in a clustered index; must be protected by a lock or a page latch </td></tr>
    <tr><td class="paramname">offsets</td><td>in: array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramname">zip_size</td><td>in: nonzero=compressed BLOB page size, zero for uncompressed BLOBs </td></tr>
    <tr><td class="paramname">no</td><td>in: field number </td></tr>
    <tr><td class="paramname">len</td><td>out: length of the field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58003b4ea2270cb2170f97974b5f36fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_rec_get_externally_stored_len </td>
          <td>(</td>
          <td class="paramtype">const rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets the externally stored size of a record, in units of a database page.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>externally stored part, in units of a database page </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee76d244b2f81a3424850e53ed3677f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> btr_store_big_rec_extern_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>rec_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rec_t *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbig__rec__t.html">big_rec_t</a> *&#160;</td>
          <td class="paramname"><em>big_rec_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>btr_mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="btr0cur_8h.html#a3361a59faf9e0a4f09a76ecf15177dfa">blob_op</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the fields in big_rec_vec to the tablespace and puts pointers to them in rec. The extern flags in rec will have to be set beforehand. The fields are stored on pages allocated from leaf node file segment of the index tree. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or DB_OUT_OF_FILE_SPACE</dd></dl>
<p>in: operation code </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index of rec; the index tree MUST be X-latched </td></tr>
    <tr><td class="paramname">rec_block</td><td>in/out: block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in/out: record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index); the "external storage" flags in offsets will not correspond to rec when this function returns </td></tr>
    <tr><td class="paramname">big_rec_vec</td><td>in: vector containing fields to be stored externally </td></tr>
    <tr><td class="paramname">btr_mtr</td><td>in: mtr containing the latches to the clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Variable Documentation</h2>
<a class="anchor" id="a7b7a92b1123d6493729904f846f05a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of searches down the B-tree in <a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a class="anchor" id="aefef1d2e4bf03540d18ff799bf9c0a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_non_sea_old</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Old value of btr_cur_n_non_sea.  Copied by
</pre><p> srv_refresh_innodb_monitor_stats(). Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
<a class="anchor" id="ae0b3d4f868488aa0addf8d9fa32df663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number of successful adaptive hash index lookups in
</pre><p> <a class="el" href="btr0cur_8h.html#a82a13fbc0aaa77d0f1164914785757c0">btr_cur_search_to_nth_level()</a>. </p>

</div>
</div>
<a class="anchor" id="a8df6a65d39b12848a998a57d2cc328d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint btr_cur_n_sea_old</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Old value of btr_cur_n_sea.  Copied by
</pre><p> srv_refresh_innodb_monitor_stats(). Referenced by <a class="el" href="srv0srv_8h.html#ad9cbe424aaafd2138998d34630066322">srv_printf_innodb_monitor()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 18:11:19 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
