<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>InnoDB Plugin: include/sync0arr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InnoDB Plugin
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sync0arr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="univ_8i.html">univ.i</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0lst_8h_source.html">ut0lst.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ut0mem_8h_source.html">ut0mem.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="os0thread_8h_source.html">os0thread.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sync0arr_8ic.html">sync0arr.ic</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for sync0arr.h:</div>
<div class="dyncontent">
<div class="center"><img src="sync0arr_8h__incl.png" border="0" usemap="#include_2sync0arr_8h" alt=""/></div>
<map name="include_2sync0arr_8h" id="include_2sync0arr_8h">
<area shape="rect" id="node3" href="univ_8i.html" title="univ.i" alt="" coords="724,161,777,189"/><area shape="rect" id="node22" href="os0thread_8h.html" title="os0thread.h" alt="" coords="13,315,112,343"/><area shape="rect" id="node33" href="ut0lst_8h.html" title="ut0lst.h" alt="" coords="1128,393,1197,421"/><area shape="rect" id="node38" href="ut0mem_8h.html" title="ut0mem.h" alt="" coords="1101,83,1189,111"/><area shape="rect" id="node47" href="sync0arr_8ic.html" title="sync0arr.ic" alt="" coords="1405,83,1496,111"/><area shape="rect" id="node19" href="ut0dbg_8h.html" title="ut0dbg.h" alt="" coords="24,238,101,266"/><area shape="rect" id="node25" href="ut0ut_8h.html" title="ut0ut.h" alt="" coords="811,238,877,266"/><area shape="rect" id="node28" href="db0err_8h.html" title="db0err.h" alt="" coords="660,315,735,343"/><area shape="rect" id="node30" href="os0sync_8h.html" title="os0sync.h" alt="" coords="1040,315,1125,343"/><area shape="rect" id="node44" href="ut0mem_8ic.html" title="ut0mem.ic" alt="" coords="1240,161,1331,189"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="sync0arr_8h__dep__incl.png" border="0" usemap="#include_2sync0arr_8hdep" alt=""/></div>
<map name="include_2sync0arr_8hdep" id="include_2sync0arr_8hdep">
<area shape="rect" id="node3" href="sync0sync_8h.html" title="include/sync0sync.h" alt="" coords="479,83,628,111"/><area shape="rect" id="node5" href="mem0mem_8h.html" title="include/mem0mem.h" alt="" coords="136,161,293,189"/><area shape="rect" id="node7" href="hash0hash_8h.html" title="include/hash0hash.h" alt="" coords="208,238,360,266"/><area shape="rect" id="node9" href="dict0dict_8h.html" title="include/dict0dict.h" alt="" coords="329,315,465,343"/><area shape="rect" id="node11" href="lock0lock_8ic.html" title="include/lock0lock.ic" alt="" coords="484,393,625,421"/><area shape="rect" id="node13" href="trx0sys_8h.html" title="include/trx0sys.h" alt="" coords="5,238,133,266"/><area shape="rect" id="node17" href="log0log_8h.html" title="include/log0log.h" alt="" coords="648,238,776,266"/><area shape="rect" id="node19" href="srv0srv_8h.html" title="include/srv0srv.h" alt="" coords="648,315,776,343"/><area shape="rect" id="node22" href="sync0rw_8h.html" title="include/sync0rw.h" alt="" coords="435,161,568,189"/><area shape="rect" id="node25" href="mtr0mtr_8ic.html" title="include/mtr0mtr.ic" alt="" coords="485,238,624,266"/><area shape="rect" id="node34" href="buf0buddy_8ic.html" title="include/buf0buddy.ic" alt="" coords="901,161,1051,189"/></map>
</div>
</div>
<p><a href="sync0arr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5acc8b6beae27cf5ee09409e2c1f9b4"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE sync_array_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae5acc8b6beae27cf5ee09409e2c1f9b4">sync_array_get_and_reserve_cell</a> (void *object, ulint type, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, ulint *index)</td></tr>
<tr class="memitem:ae7905f8df293f122783bfd1071067d50"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae7905f8df293f122783bfd1071067d50">sync_array_reserve_cell</a> (sync_array_t *arr, void *object, ulint type, const char *file, ulint <a class="el" href="sync0rw_8h.html#a9c7f0c6f9625ecd575d0dc773df2ee08">line</a>, ulint *index)</td></tr>
<tr class="memitem:a3fdf80f2a3f4036670fe332c38711030"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a3fdf80f2a3f4036670fe332c38711030">sync_array_wait_event</a> (sync_array_t *arr, ulint index)</td></tr>
<tr class="memitem:a74072ff39e7d9d49fcd56b5d7cfe716e"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a74072ff39e7d9d49fcd56b5d7cfe716e">sync_array_free_cell</a> (sync_array_t *arr, ulint index)</td></tr>
<tr class="memitem:a136a5980f17a2bcc44f264115e572247"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a136a5980f17a2bcc44f264115e572247">sync_array_object_signalled</a> (void)</td></tr>
<tr class="memitem:a63c59555400d611b0e377942612a10d0"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a63c59555400d611b0e377942612a10d0">sync_arr_wake_threads_if_sema_free</a> (void)</td></tr>
<tr class="memitem:a6be5ba82c6b2d87553adfa51786fb7fd"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a6be5ba82c6b2d87553adfa51786fb7fd">sync_array_print_long_waits</a> (<a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a> *waiter, const void **sema))</td></tr>
<tr class="memitem:a5d8c4d56bd2c8f4403a782c8ee5dfd71"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a5d8c4d56bd2c8f4403a782c8ee5dfd71">sync_array_validate</a> (sync_array_t *arr)</td></tr>
<tr class="memitem:aebdb84e90e504ac199cc908a94f96962"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#aebdb84e90e504ac199cc908a94f96962">sync_array_print</a> (FILE *file)</td></tr>
<tr class="memitem:ae2f1d0d6da6b67f04bb4c8b687c52911"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ae2f1d0d6da6b67f04bb4c8b687c52911">sync_array_init</a> (ulint n_threads)</td></tr>
<tr class="memitem:ad1fb04100e042c963a6637695a8bb329"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#ad1fb04100e042c963a6637695a8bb329">sync_array_close</a> (void)</td></tr>
<tr class="memitem:a818e0a7d2272a2bc4b529450359d9274"><td class="memItemLeft" align="right" valign="top">UNIV_INTERN sync_array_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sync0arr_8h.html#a818e0a7d2272a2bc4b529450359d9274">sync_array_get</a> (void)</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The wait array used in synchronization primitives</p>
<p>Created 9/5/1995 Heikki Tuuri </p>
</div><h2>Function Documentation</h2>
<a class="anchor" id="a63c59555400d611b0e377942612a10d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_arr_wake_threads_if_sema_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the wakeup algorithm does not work perfectly at semaphore relases, this function will do the waking (see the comment in mutex_exit). This function should be called about every 1 second in the server. </p>

</div>
</div>
<a class="anchor" id="ad1fb04100e042c963a6637695a8bb329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close sync array wait sub-system. </p>

</div>
</div>
<a class="anchor" id="a74072ff39e7d9d49fcd56b5d7cfe716e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_free_cell </td>
          <td>(</td>
          <td class="paramtype">sync_array_t *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees the cell. NOTE! sync_array_wait_event frees the cell automatically! in: index of the cell in array </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a818e0a7d2272a2bc4b529450359d9274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN sync_array_t* sync_array_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an instance of the sync wait array. </p>

</div>
</div>
<a class="anchor" id="ae5acc8b6beae27cf5ee09409e2c1f9b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE sync_array_t* sync_array_get_and_reserve_cell </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an instance of the sync wait array and reserve a wait array cell in the instance for waiting for an object. The event of the cell is reset to nonsignalled state. If reserving cell of the instance fails, try to get another new instance until we can reserve an empty cell of it. </p>
<dl class="section return"><dt>Returns</dt><dd>the instance found, never NULL. out: index of the reserved cell</dd></dl>
<p>Get an instance of the sync wait array and reserve a wait array cell in the instance for waiting for an object. The event of the cell is reset to nonsignalled state. If reserving cell of the instance fails, try to get another new instance until we can reserve an empty cell of it. </p>
<dl class="section return"><dt>Returns</dt><dd>the instance found, never NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>in: pointer to the object to wait for </td></tr>
    <tr><td class="paramname">type</td><td>in: lock request type </td></tr>
    <tr><td class="paramname">file</td><td>in: file where requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
    <tr><td class="paramname">index</td><td>out: index of the reserved cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae2f1d0d6da6b67f04bb4c8b687c52911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_init </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the primary system wait array(s), they are protected by an OS mutex in: Number of slots to create </p>

</div>
</div>
<a class="anchor" id="a136a5980f17a2bcc44f264115e572247"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_object_signalled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Note that one of the wait objects was signalled. </p>

</div>
</div>
<a class="anchor" id="aebdb84e90e504ac199cc908a94f96962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints info of the wait array. in: file where to print </p>

</div>
</div>
<a class="anchor" id="a6be5ba82c6b2d87553adfa51786fb7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN <a class="el" href="univ_8i.html#ab71ee9e321c01cd32b9facc463e1c8d2">ibool</a> sync_array_print_long_waits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="os0thread_8h.html#a0e87ca653f4358a387e610ee5c542f74">os_thread_id_t</a> *&#160;</td>
          <td class="paramname"><em>waiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>sema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints warnings of long semaphore waits to stderr. </p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if fatal semaphore wait threshold was exceeded </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waiter</td><td>out: longest waiting thread </td></tr>
    <tr><td class="paramname">sema</td><td>out: longest-waited-for semaphore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7905f8df293f122783bfd1071067d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN bool sync_array_reserve_cell </td>
          <td>(</td>
          <td class="paramtype">sync_array_t *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves a wait array cell for waiting for an object. The event of the cell is reset to nonsignalled state. </p>
<dl class="section return"><dt>Returns</dt><dd>true if free cell is found, otherwise false out: index of the reserved cell </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
    <tr><td class="paramname">object</td><td>in: pointer to the object to wait for </td></tr>
    <tr><td class="paramname">type</td><td>in: lock request type </td></tr>
    <tr><td class="paramname">file</td><td>in: file where requested </td></tr>
    <tr><td class="paramname">line</td><td>in: line where requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d8c4d56bd2c8f4403a782c8ee5dfd71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_validate </td>
          <td>(</td>
          <td class="paramtype">sync_array_t *&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validates the integrity of the wait array. Checks that the number of reserved cells equals the count variable. in: sync wait array </p>

</div>
</div>
<a class="anchor" id="a3fdf80f2a3f4036670fe332c38711030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INTERN void sync_array_wait_event </td>
          <td>(</td>
          <td class="paramtype">sync_array_t *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function should be called when a thread starts to wait on a wait array cell. In the debug version this function checks if the wait for a semaphore will result in a deadlock, in which case prints info and asserts. in: index of the reserved cell </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in: wait array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 21 2015 19:14:27 for InnoDB Plugin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
